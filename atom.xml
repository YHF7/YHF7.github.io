<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>不懂IT的男孩</title>
  
  <subtitle>不忘初心，方得始终</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-26T09:14:42.828Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Detail</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里云 Centos 7 安装/配置 Nginx  https</title>
    <link href="http://yoursite.com/2019/04/26/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEnginx/"/>
    <id>http://yoursite.com/2019/04/26/阿里云安装配置nginx/</id>
    <published>2019-04-26T06:20:26.650Z</published>
    <updated>2019-04-26T09:14:42.828Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>前段时间配置了php环境的https，但是我的服务器不只是有php还有其他的后端</li><li>所以只好用nginx做一个全局的配置，而且配置的时候一直出问题</li><li>一开始我也是被多个代理卡了好久，事实证明nginx配置比单个配置方便很多的，因为Apache只可以给php等使用，但是如果我要给个node那就不行了</li><li>今天花了点时间把之前的删除了重新安装配置</li><li>不看我的看官网也是可以的：<a href="https://help.aliyun.com/knowledge_detail/95491.html?spm=a2c4g.11186623.2.9.678d4c07Jh6m7U" target="_blank" rel="noopener">点击前往</a></li></ul><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>如果你安装了的，可以选择清空再安装配置</li><li>如果配置了其他的https请关闭，我就是配置了apache的https所以关闭了</li><li>我这里是做了端口重定向，100端口是我Apache php的应用你们按需配置就好</li><li>关闭Apache 的方法是找到配置https 和ssl文件把443端口关闭，和80端口重定向关闭了</li><li>密钥放在nginx文件夹下的cert文件下自己创建的，这个如果不会看我之前php配置的那个<a href="https://yhf7.github.io/2019/04/18/%E9%98%BF%E9%87%8C%E4%BA%91Apache%E9%85%8D%E7%BD%AEhttps/" target="_blank" rel="noopener">php配置https</a></li></ol><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h3 id="查看并清除nginx-（未安装的不需要看）"><a href="#查看并清除nginx-（未安装的不需要看）" class="headerlink" title="查看并清除nginx （未安装的不需要看）"></a>查看并清除nginx （未安装的不需要看）</h3><ol><li>查看安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ql nginx</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/ng1.png" alt="nginx"></p><ol start="2"><li>清除nginx<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum remove nginx</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/ng2.png" alt="nginx"></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install nginx</span><br></pre></td></tr></table></figure><p><img src="/aly/ng3.png" alt="nginx"></p><h3 id="配置-https-证书自己下不会的找我之前的php配置的去看-如果像我一样配置了apache的https的请自行关闭"><a href="#配置-https-证书自己下不会的找我之前的php配置的去看-如果像我一样配置了apache的https的请自行关闭" class="headerlink" title="配置 https (证书自己下不会的找我之前的php配置的去看,如果像我一样配置了apache的https的请自行关闭)"></a>配置 https (证书自己下不会的找我之前的php配置的去看,如果像我一样配置了apache的https的请自行关闭)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">------------</span><br><span class="line">http &#123;</span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line"></span><br><span class="line">    access_log  /var/<span class="built_in">log</span>/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    sendfile            on;</span><br><span class="line">    tcp_nopush          on;</span><br><span class="line">    tcp_nodelay         on;</span><br><span class="line">    keepalive_timeout   65;</span><br><span class="line">    types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">    include             /etc/nginx/mime.types;</span><br><span class="line">    default_type        application/octet-stream;</span><br><span class="line"></span><br><span class="line">    include /etc/nginx/conf.d/*.conf;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多端口使用https 代理8888 挂载node</span></span><br><span class="line">server &#123;</span><br><span class="line">        listen       8888 ssl;</span><br><span class="line">        server_name  yhf7.top; <span class="comment"># 域名</span></span><br><span class="line">        ssl on;</span><br><span class="line">        root         html;</span><br><span class="line"></span><br><span class="line">        index index.html index.htm;</span><br><span class="line">        ssl_certificate <span class="string">"cert/yhf7.top.pem"</span>; <span class="comment"># 密钥</span></span><br><span class="line">        ssl_certificate_key <span class="string">"cert/yhf7.top.key"</span>;<span class="comment"># 密钥</span></span><br><span class="line">        ssl_session_cache shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;<span class="comment"># 加密</span></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                root html;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">                proxy_pass http://yhf7.top:3000; <span class="comment"># 端口默认指向地</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># https 配置 80 443</span></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        listen       443 ssl;</span><br><span class="line">        server_name  yhf7.top; <span class="comment"># 域名</span></span><br><span class="line">        ssl on;</span><br><span class="line">        root         html;</span><br><span class="line"></span><br><span class="line">        index index.html index.htm;</span><br><span class="line">        ssl_certificate <span class="string">"cert/yhf7.top.pem"</span>; <span class="comment"># 密钥</span></span><br><span class="line">        ssl_certificate_key <span class="string">"cert/yhf7.top.key"</span>;<span class="comment"># 密钥</span></span><br><span class="line">        ssl_session_cache shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  5m;</span><br><span class="line">        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;<span class="comment"># 加密</span></span><br><span class="line">        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">                root html;</span><br><span class="line">                index index.html index.htm;</span><br><span class="line">                proxy_pass http://yhf7.top:100; <span class="comment"># 端口默认指向地</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/aly/ng4.png" alt="nginx"></p><h4 id="nginx重定向apache的应用-（Apache的默认80端口必须改变不然就和nginx冲突了）"><a href="#nginx重定向apache的应用-（Apache的默认80端口必须改变不然就和nginx冲突了）" class="headerlink" title="nginx重定向apache的应用 （Apache的默认80端口必须改变不然就和nginx冲突了）"></a>nginx重定向apache的应用 （Apache的默认80端口必须改变不然就和nginx冲突了）</h4><ul><li>由于前面配置了默认进入，所以改变端口 就可以了<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/ng6.png" alt="nginx"></p><h3 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nginx 开启</span><br><span class="line">$ nginx -s reload 重启</span><br><span class="line">$ nginx -s stop 关闭</span><br></pre></td></tr></table></figure><p><img src="/aly/ng5.png" alt="nginx"><br><img src="/aly/ng8.png" alt="nginx"></p><h3 id="预防不会关闭Apache-https"><a href="#预防不会关闭Apache-https" class="headerlink" title="预防不会关闭Apache https"></a>预防不会关闭Apache https</h3><ol><li>关闭httpd重定向<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/httpd/conf/httpd.conf</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/ng7.png" alt="nginx"></p><ol start="2"><li><p>关闭httpd ssl 端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/httpd/conf.d/ssl.conf</span><br></pre></td></tr></table></figure></li><li><p>重启httpd</p></li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>这就是我踩很多坑最后配置出来的笔记，希望能帮到有缘人，欢迎同行加微信交流学习！</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="反向代理" scheme="http://yoursite.com/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>vue-cli3 部局多页面开发/模块化</title>
    <link href="http://yoursite.com/2019/04/26/vue-cli3-%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/04/26/vue-cli3-多页面开发/</id>
    <published>2019-04-26T00:39:31.310Z</published>
    <updated>2019-04-26T01:25:28.785Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>vue我们众所周知的是单页面开发，那么我们想把它多页面化模块化呢</li><li>那该如何来个改才能达到多页面多模块的效果呢</li><li>如何可以模块之间无关联无污染呢</li><li>为什么要这样去写呢？有什么好处呢？</li><li>第一、一个项目中有两端同的业务可以很好的区分两个项目之间无污染无关联</li><li>第二、公共资源共享公共组件视图多项目共用</li><li>第三、打包方便一次打包就可以了不需要分开多次去打包配置也只是需要配置一次</li><li>那我们就来走入vue多页面开发系列吧跟着我一步一步的配置多页面</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>先看一下目录图<br><img src="/vue-cli/vue3-cli-1.png" alt="vue-cli"><br><img src="/vue-cli/vue3-cli-2.png" alt="vue-cli"></li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ul><li>文件的创建那些就不多说了不懂你私我好吧</li><li>直接配置一目了然<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    pages: &#123;</span><br><span class="line">        main: &#123;</span><br><span class="line">            entry: <span class="string">'src/module/index/main.js'</span>, <span class="comment">// 模块加载文件</span></span><br><span class="line">            <span class="comment">// 模板来源</span></span><br><span class="line">            template: <span class="string">'public/index.html'</span>,<span class="comment">// 模块入口文件, 默认进入文件（因为是放在根目录所以就会默认进入，如果不想可以改其他）</span></span><br><span class="line">            filename: <span class="string">'index.html'</span>,     </span><br><span class="line">            <span class="comment">// 当使用 title 选项时，</span></span><br><span class="line">            <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">            title: <span class="string">''</span></span><br><span class="line">        &#125;,</span><br><span class="line">        login: &#123;</span><br><span class="line">            entry: <span class="string">'src/module/login/main.js'</span>, <span class="comment">// 第二个页面的模版加载文件地址</span></span><br><span class="line">            <span class="comment">// 模板来源</span></span><br><span class="line">            template: <span class="string">'public/login/index.html'</span>, <span class="comment">// 入口文件</span></span><br><span class="line">            filename: <span class="string">'login/index.html'</span>,</span><br><span class="line">            <span class="comment">// 当使用 title 选项时，</span></span><br><span class="line">            <span class="comment">// template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;</span></span><br><span class="line">            title: <span class="string">''</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/vue-cli/vue3-cli-3.png" alt="vue-cli"></p><h3 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h3><p><img src="/vue-cli/vue3-cli-4.png" alt="vue-cli"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/vue-cli/vue3-cli-5.png" alt="vue-cli"></h2><h4 id="注意：-不是默认进入必须和我那样写，你也可以不需要默认进入，可以改成和login那样也是可以的只是改一下入口文件，吧index-html和login一样放到文件夹里面就可以了"><a href="#注意：-不是默认进入必须和我那样写，你也可以不需要默认进入，可以改成和login那样也是可以的只是改一下入口文件，吧index-html和login一样放到文件夹里面就可以了" class="headerlink" title="注意： 不是默认进入必须和我那样写，你也可以不需要默认进入，可以改成和login那样也是可以的只是改一下入口文件，吧index.html和login一样放到文件夹里面就可以了"></a>注意： 不是默认进入必须和我那样写，你也可以不需要默认进入，可以改成和login那样也是可以的只是改一下入口文件，吧index.html和login一样放到文件夹里面就可以了</h4><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>这就是vue多页面开发，是不是觉得很简单啊</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
      <category term="Vue 案例" scheme="http://yoursite.com/tags/Vue-%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 自学笔记9 高级类型</title>
    <link href="http://yoursite.com/2019/04/25/TypeScript%E7%AC%94%E8%AE%B09/"/>
    <id>http://yoursite.com/2019/04/25/TypeScript笔记9/</id>
    <published>2019-04-25T07:57:13.578Z</published>
    <updated>2019-04-25T07:58:09.950Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>断断续续还是不忘想把ts学习完</li><li>终于忙完可以继续学习了</li><li>今天学习高级类型</li></ul><h1 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h1><h3 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h3><ul><li>简单的说就是把多个类中的所以方法和变量都集中在一个类型里面</li><li>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。</li><li>我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子：</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交叉类型函数</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param</span></span><br><span class="line"><span class="comment"> * T、U 两个都是外传的方法（ts函数自检测类型）</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建这两个类型合集的对象</span></span><br><span class="line">  <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">  <span class="comment">// 遍历把数据存储到新的对象中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">      (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 输出查看</span></span><br><span class="line">  <span class="built_in">console</span>.log(result) <span class="comment">//1</span></span><br><span class="line">  <span class="comment">// 遍历第二个参赛</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">          (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(result)<span class="comment">//2</span></span><br><span class="line">  <span class="comment">// 返回</span></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类，实现构造函数和一个方法</span></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">  test() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hello, '</span>+<span class="keyword">this</span>.name) <span class="comment">//5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">  log(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现抽象类</span></span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">  log() &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">'你好'</span>)  <span class="comment">//4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里调用extend函数传入两个不同的类型，一个是类，一个是抽象类</span></span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">"Jim"</span>), <span class="keyword">new</span> ConsoleLogger());</span><br><span class="line"><span class="comment">// 接受name</span></span><br><span class="line"><span class="keyword">var</span> n = jim.name;</span><br><span class="line"><span class="built_in">console</span>.log(n) <span class="comment">//3</span></span><br><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">jim.log();</span><br><span class="line">jim.test();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后输出的值(后面的号码对应上面的log)</span></span><br><span class="line"><span class="comment">// &#123; name: 'Jim', test: [Function] &#125; //1</span></span><br><span class="line"><span class="comment">// &#123; name: 'Jim', test: [Function], log: [Function] &#125;//2</span></span><br><span class="line"><span class="comment">// Jim //3</span></span><br><span class="line"><span class="comment">// 你好 //4</span></span><br><span class="line"><span class="comment">// hello, Jim //5</span></span><br></pre></td></tr></table></figure><h3 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h3><ul><li>这个理解起来不难，其实就是说通过数字或字符串的判断来区分判断修改</li><li>联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 number或 string类型的参数。 例如下面的函数：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模仿联合类型</span></span><br><span class="line"><span class="comment"> * @param</span></span><br><span class="line"><span class="comment"> * value &#123;string&#125; 字符串</span></span><br><span class="line"><span class="comment"> * padding &#123;any&#125; 任意类型</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是数字类型在前面加数字多个空格</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"number"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果是字符串就直接加在前面</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"string"</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> padding + value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字</span></span><br><span class="line">padLeft(<span class="string">"Hello world"</span>, <span class="number">4</span>); <span class="comment">// returns "    Hello world"</span></span><br><span class="line"><span class="comment">// 字符串</span></span><br><span class="line">padLeft(<span class="string">"Hello world"</span>, <span class="string">"4"</span>); <span class="comment">// returns "4Hello world"</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>padLeft存在一个问题， padding参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number也不是 string类型的参数，但是TypeScript却不报错。</li><li>let indentedString = padLeft(“Hello world”, true); // 编译阶段通过，运行时报错</li><li>这时候联合类型就派上用场了,代替any从源头上解决问题 （并不是只有string和number，boolean等也是可以使用的）<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> indentedString = padLeft(<span class="string">"Hello world"</span>, <span class="literal">true</span>);<span class="comment">// errors during compilation</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。</li><li>这个在前面一章算数哪里已经验证过了</li><li>这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 这个例子里， Bird具有一个 fly成员。 我们不能确定一个 Bird | Fish类型的变量是否有 fly方法。 如果变量在运行时是 Fish类型，那么调用 pet.fly()就出错了。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">  fly();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">  swim();</span><br><span class="line">  layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Bird1 <span class="keyword">implements</span> Bird &#123;</span><br><span class="line">  fly() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'fly'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  layEggs() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'layEggs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Fish1 <span class="keyword">implements</span> Fish &#123;</span><br><span class="line">  swim() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'swim'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  layEggs() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'layEggs'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fish1()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bird1()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// layEggs</span></span><br><span class="line">pet.swim();   <span class="comment">// errors</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="类型保护与区分类型（Type-Guards-and-Differentiating-Types）"><a href="#类型保护与区分类型（Type-Guards-and-Differentiating-Types）" class="headerlink" title="类型保护与区分类型（Type Guards and Differentiating Types）"></a>类型保护与区分类型（Type Guards and Differentiating Types）</h3><ul><li>联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish时怎么办？ JavaScript里常用来区分2个可能值的方法是检查成员是否存在。 如之前提及的，我们只能访问联合类型中共同拥有的成员。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每一个成员访问都会报错</span></span><br><span class="line"><span class="keyword">if</span> (pet.swim) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (pet.fly) &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确解法</span></span><br><span class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">    (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 联合上面的代码一起执行，输出的结果会有两种情况（随机的）</span></span><br><span class="line"><span class="comment">//1 </span></span><br><span class="line">layEggs</span><br><span class="line">swim</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">layEggs</span><br><span class="line">fly</span><br></pre></td></tr></table></figure></li></ul><h4 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h4><ul><li>这里可以注意到我们不得不多次使用类型断言。 假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet的类型的话就好了。</li><li><p>TypeScript里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'swim' 和 'fly' 调用都没有问题了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型</p></li></ul><h4 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a>typeof类型保护</h4><ul><li>现在我们回过头来看看怎么使用联合类型书写 padLeft代码。 我们可以像下面这样利用类型断言来写：</li><li>然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。 幸运的是，现在我们不必将 typeof x === “number”抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"number"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isString</span>(<span class="params">x: <span class="built_in">any</span></span>): <span class="title">x</span> <span class="title">is</span> <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> x === <span class="string">"string"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isNumber(padding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isString(padding)) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这些<em> typeof类型保护</em>只有两种形式能被识别： typeof v === “typename”和 typeof v !== “typename”， “typename”必须是 “number”， “string”， “boolean”或 “symbol”。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="instanceof类型保护"><a href="#instanceof类型保护" class="headerlink" title="instanceof类型保护"></a>instanceof类型保护</h3><ul><li><p>如果你已经阅读了 typeof类型保护并且对JavaScript里的 instanceof操作符熟悉的话，你可能已经猜到了这节要讲的内容。</p></li><li><p>instanceof类型保护是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Padder &#123;</span><br><span class="line">    getPaddingString(): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> SpaceRepeatingPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> numSpaces: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(<span class="keyword">this</span>.numSpaces + <span class="number">1</span>).join(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> StringPadder <span class="keyword">implements</span> Padder &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">private</span> value: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">    getPaddingString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRandomPadder</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ?</span><br><span class="line">        <span class="keyword">new</span> SpaceRepeatingPadder(<span class="number">4</span>) :</span><br><span class="line">        <span class="keyword">new</span> StringPadder(<span class="string">"  "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型为SpaceRepeatingPadder | StringPadder</span></span><br><span class="line"><span class="keyword">let</span> padder: Padder = getRandomPadder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> SpaceRepeatingPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为'SpaceRepeatingPadder'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (padder <span class="keyword">instanceof</span> StringPadder) &#123;</span><br><span class="line">    padder; <span class="comment">// 类型细化为'StringPadder'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>instanceof的右侧要求是一个构造函数，TypeScript将细化为：</p><ol><li>此构造函数的 prototype属性的类型，如果它的类型不为 any的话</li><li>构造签名所返回的类型的联合</li></ol></li></ul><h3 id="可以为null的类型"><a href="#可以为null的类型" class="headerlink" title="可以为null的类型"></a>可以为null的类型</h3><ul><li><p>TypeScript具有两种特殊的类型， null和 undefined，它们分别具有值null和undefined. 我们在<a href="./Basic Types.md">基础类型</a>一节里已经做过简要说明。 默认情况下，类型检查器认为 null与 undefined可以赋值给任何类型。 null与 undefined是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。 null的发明者，Tony Hoare，称它为 价值亿万美金的错误。</p></li><li><p>–strictNullChecks标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null或 undefined。 你可以使用联合类型明确的包含它们：</p></li><li><p>当是我们自己去赋值的时候其实都是可以的并没有报错</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">"foo"</span>;</span><br><span class="line">s = <span class="literal">null</span>; <span class="comment">// 错误, 'null'不能赋值给'string'</span></span><br><span class="line"><span class="keyword">let</span> sn: <span class="built_in">string</span> | <span class="literal">null</span> = <span class="string">"bar"</span>;</span><br><span class="line">sn = <span class="literal">null</span>; <span class="comment">// 可以</span></span><br><span class="line"></span><br><span class="line">sn = <span class="literal">undefined</span>; <span class="comment">// error, 'undefined'不能赋值给'string | null'</span></span><br></pre></td></tr></table></figure></li><li><p>注意，按照JavaScript的语义，TypeScript会把 null和 undefined区别对待。 string | null， string | undefined和 string | undefined | null是不同的类型。</p></li></ul><h4 id="可选参数和可选属性"><a href="#可选参数和可选属性" class="headerlink" title="可选参数和可选属性"></a>可选参数和可选属性</h4><ul><li>使用了 –strictNullChecks，可选参数会被自动地加上 | undefined:</li><li>然而这个也是无报错的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + (y || <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">undefined</span>);</span><br><span class="line">f(<span class="number">1</span>, <span class="literal">null</span>); <span class="comment">// error, 'null' is not assignable to 'number | undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类的也是一样没有报错正常执行</span></span><br><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> C();</span><br><span class="line">c.a = <span class="number">12</span>;</span><br><span class="line">c.a = <span class="literal">undefined</span>; <span class="comment">// error, 'undefined' is not assignable to 'number'</span></span><br><span class="line">c.b = <span class="number">13</span>;</span><br><span class="line">c.b = <span class="literal">undefined</span>; <span class="comment">// ok</span></span><br><span class="line">c.b = <span class="literal">null</span>; <span class="comment">// error, 'null' is not assignable to 'number | undefined'</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="类型保护和类型断言"><a href="#类型保护和类型断言" class="headerlink" title="类型保护和类型断言"></a>类型保护和类型断言</h4><ul><li><p>由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 null。 幸运地是这与在JavaScript里写的代码一致：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">sn: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sn || <span class="string">"default"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="string">"default1"</span>)); <span class="comment">//default1</span></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="literal">null</span>))<span class="comment">// default</span></span><br></pre></td></tr></table></figure></li><li><p>如果编译器不能够去除 null或 undefined，你可以使用类型断言手动去除。 语法是添加 !后缀： identifier!从 identifier的类型里去除了 null和 undefined：(我的支持并没有报错)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broken</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet; <span class="comment">// error, 'name' is possibly null</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">"Bob"</span>;</span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">"great"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fixed</span>(<span class="params">name: <span class="built_in">string</span> | <span class="literal">null</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">postfix</span>(<span class="params">epithet: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name!.charAt(<span class="number">0</span>) + <span class="string">'.  the '</span> + epithet; <span class="comment">// ok</span></span><br><span class="line">  &#125;</span><br><span class="line">  name = name || <span class="string">"Bob"</span>;</span><br><span class="line">  <span class="keyword">return</span> postfix(<span class="string">"great"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><ul><li>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> n === <span class="string">'string'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。</li><li><p>同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123; value: T &#125;;</span><br></pre></td></tr></table></figure></li><li><p>我们也可以使用类型别名来在属性里引用自己：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</span><br><span class="line">    value: T;</span><br><span class="line">    left: Tree&lt;T&gt;;</span><br><span class="line">    right: Tree&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> people: LinkedList&lt;Person&gt;;</span><br><span class="line"><span class="keyword">var</span> s = people.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.name;</span><br><span class="line"><span class="keyword">var</span> s = people.next.next.next.name;</span><br></pre></td></tr></table></figure></li><li><p>然而，类型别名不能出现在声明右侧的任何地方。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Yikes = <span class="built_in">Array</span>&lt;Yikes&gt;; <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="接口-vs-类型别名"><a href="#接口-vs-类型别名" class="headerlink" title="接口 vs. 类型别名"></a>接口 vs. 类型别名</h4><ul><li><p>像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。</p></li><li><p>其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 interfaced上，显示它返回的是 Interface，但悬停在 aliased上时，显示的却是对象字面量类型。</p></li><li>另一个重要区别是类型别名不能被 extends和 implements（自己也不能 extends和 implements其它类型）。 因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。</li><li>另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Alias = &#123; num: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> Interface &#123;</span><br><span class="line">    num: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">aliased</span>(<span class="params">arg: Alias</span>): <span class="title">Alias</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">interfaced</span>(<span class="params">arg: Interface</span>): <span class="title">Interface</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><ul><li>字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。</li><li><p>这样就可以很明确的去限定输入的字符面量，只可以输入限定的那结果字符串否则就是错误的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Easing = <span class="string">"ease-in"</span> | <span class="string">"ease-out"</span> | <span class="string">"ease-in-out"</span>;</span><br><span class="line"><span class="keyword">class</span> UIElement &#123;</span><br><span class="line">    animate(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>, easing: Easing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (easing === <span class="string">"ease-in"</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-out"</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (easing === <span class="string">"ease-in-out"</span>) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// error! should not pass null or undefined.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> button = <span class="keyword">new</span> UIElement();</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"ease-in"</span>);</span><br><span class="line">button.animate(<span class="number">0</span>, <span class="number">0</span>, <span class="string">"uneasy"</span>); <span class="comment">// error: "uneasy" is not allowed here</span></span><br><span class="line">Argument of <span class="keyword">type</span> <span class="string">'"uneasy"'</span> is not assignable to parameter of <span class="keyword">type</span> <span class="string">'"ease-in" | "ease-out" | "ease-in-out"'</span></span><br></pre></td></tr></table></figure></li><li><p>字符串字面量类型还可以用于区分函数重载：</p></li><li>就是说会检测重载时的变量和返回类型<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function createElement(tagName: "img"): HTMLImageElement;</span><br><span class="line">function createElement(tagName: "input"): HTMLInputElement;</span><br><span class="line"><span class="comment">// ... more overloads ...</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName: <span class="built_in">string</span></span>): <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ... code goes here ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rollDie</span>(<span class="params"></span>): 1 | 2 | 3 | 4 | 5 | 6 </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x: <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="number">1</span> || x !== <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">//         ~~~~~~~</span></span><br><span class="line">        <span class="comment">// Operator '!==' cannot be applied to types '1' and '2'.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>换句话说，当 x与 2进行比较的时候，它的值必须为 1，这就意味着上面的比较检查是非法的。</li></ul><h3 id="可辨识联合（Discriminated-Unions）"><a href="#可辨识联合（Discriminated-Unions）" class="headerlink" title="可辨识联合（Discriminated Unions）"></a>可辨识联合（Discriminated Unions）</h3><ul><li><p>你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素：</p><ol><li>具有普通的单例类型属性— 可辨识的特征。</li><li>一个类型别名包含了那些类型的联合— 联合。</li><li>此属性上的类型保护。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">  kind: <span class="string">"square"</span>;</span><br><span class="line">  size: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Rectangle &#123;</span><br><span class="line">  kind: <span class="string">"rectangle"</span>;</span><br><span class="line">  width: <span class="built_in">number</span>;</span><br><span class="line">  height: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">  kind: <span class="string">"circle"</span>;</span><br><span class="line">  radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (s.kind) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">default</span>: <span class="keyword">return</span> assertNever(s); <span class="comment">// error here if there are missing cases</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li><li><p>这里， assertNever检查 s是否为 never类型—即为除去所有可能情况后剩下的类型。 如果你忘记了某个case，那么 s将具有一个真实的类型并且你会得到一个错误。 这种方式需要你定义一个额外的函数，但是在你忘记某个case的时候也更加明显。</p></li></ul><h3 id="多态的-this类型"><a href="#多态的-this类型" class="headerlink" title="多态的 this类型"></a>多态的 this类型</h3><ul><li>多态的 this类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回 this类型：</li><li><p>这里this指向的就是数据</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BasicCalculator &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> value: <span class="built_in">number</span> = 0</span>) &#123; &#125;</span><br><span class="line">    <span class="keyword">public</span> currentValue(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> add(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value += operand;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> multiply(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.value *= operand;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... other operations go here ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> BasicCalculator(<span class="number">2</span>)</span><br><span class="line">            .multiply(<span class="number">5</span>)</span><br><span class="line">            .add(<span class="number">1</span>)</span><br><span class="line">            .currentValue();</span><br><span class="line">            <span class="comment">// 11</span></span><br></pre></td></tr></table></figure></li><li><p>由于这个类使用了 this类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ScientificCalculator <span class="keyword">extends</span> BasicCalculator &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">value = 0</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> sin() &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="built_in">Math</span>.sin(<span class="keyword">this</span>.value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... other operations go here ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> ScientificCalculator(<span class="number">2</span>)</span><br><span class="line">        .multiply(<span class="number">5</span>)</span><br><span class="line">        .sin()</span><br><span class="line">        .add(<span class="number">1</span>)</span><br><span class="line">        .currentValue(); <span class="comment">// 0.4559788891106302</span></span><br></pre></td></tr></table></figure></li><li><p>如果没有 this类型， ScientificCalculator就不能够在继承 BasicCalculator的同时还保持接口的连贯性。 multiply将会返回 BasicCalculator，它并没有 sin方法。 然而，使用 this类型， multiply会返回 this，在这里就是 ScientificCalculator。</p></li></ul><h3 id="索引类型（Index-types）"><a href="#索引类型（Index-types）" class="headerlink" title="索引类型（Index types）"></a>索引类型（Index types）</h3><ul><li>使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的JavaScript模式是从对象中选取属性的子集。</li><li><p>下面是如何在TypeScript里使用此函数，通过 索引类型查询和 索引访问操作符：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluck</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, names: K[]</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> names.map(<span class="function"><span class="params">n</span> =&gt;</span> o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">    age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person: Person = &#123;</span><br><span class="line">    name: <span class="string">'Jarid'</span>,</span><br><span class="line">    age: <span class="number">35</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> strings: <span class="built_in">string</span>[] = pluck(person, [<span class="string">'name'</span>]); <span class="comment">// ok, string[]</span></span><br></pre></td></tr></table></figure></li><li><p>编译器会检查 name是否真的是 Person的一个属性。 本例还引入了几个新的类型操作符。 首先是 keyof T， 索引类型查询操作符。 对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合。 例如：</p></li><li><p>keyof 就是检测类型里面是否拥有</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> personProps: keyof Person; <span class="comment">// 'name' | 'age'</span></span><br></pre></td></tr></table></figure></li><li><p>keyof Person是完全可以与 ‘name’ | ‘age’互相替换的。 不同的是如果你添加了其它的属性到 Person，例如 address: string，那么 keyof Person会自动变为 ‘name’ | ‘age’ | ‘address’。 你可以在像 pluck函数这类上下文里使用 keyof，因为在使用之前你并不清楚可能出现的属性名。 但编译器会检查你是否传入了正确的属性名给 pluck：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pluck(person, [<span class="string">'age'</span>, <span class="string">'unknown'</span>]); <span class="comment">// error, 'unknown' is not in 'name' | 'age'</span></span><br></pre></td></tr></table></figure></li><li><p>第二个操作符是 T[K]， 索引访问操作符。 在这里，类型语法反映了表达式语法。 这意味着 person[‘name’]具有类型 Person[‘name’] — 在我们的例子里则为 string类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 T[K]，这正是它的强大所在。 你只要确保类型变量 K extends keyof T就可以了。 例如下面 getProperty函数的例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">o: T, name: K</span>): <span class="title">T</span>[<span class="title">K</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> o[name]; <span class="comment">// o[name] is of type T[K]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>getProperty里的 o: T和 name: K，意味着 o[name]: T[K]。 当你返回 T[K]的结果，编译器会实例化键的真实类型，因此 getProperty的返回值类型会随着你需要的属性改变。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = getProperty(person, <span class="string">'name'</span>);</span><br><span class="line"><span class="keyword">let</span> age: <span class="built_in">number</span> = getProperty(person, <span class="string">'age'</span>);</span><br><span class="line"><span class="keyword">let</span> unknown = getProperty(person, <span class="string">'unknown'</span>); <span class="comment">// error, 'unknown' is not in 'name' | 'age'</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="索引类型和字符串索引签名"><a href="#索引类型和字符串索引签名" class="headerlink" title="索引类型和字符串索引签名"></a>索引类型和字符串索引签名</h4><ul><li>keyof和 T[K]与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么 keyof T会是 string。 并且 T[string]为索引签名的类型：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Map&lt;T&gt; &#123;</span><br><span class="line">    [key: <span class="built_in">string</span>]: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> keys: keyof Map&lt;<span class="built_in">number</span>&gt;; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">let</span> value: Map&lt;<span class="built_in">number</span>&gt;[<span class="string">'foo'</span>]; <span class="comment">// number</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><ul><li><p>一个常见的任务是将一个已知的类型每个属性都变为可选的/或只读</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> PersonPartial &#123;</span><br><span class="line">    name?: <span class="built_in">string</span>;</span><br><span class="line">    age?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> PersonReadonly &#123;</span><br><span class="line">    readonly name: <span class="built_in">string</span>;</span><br><span class="line">    readonly age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这在JavaScript里经常出现，TypeScript提供了从旧类型中创建新类型的一种方式 — 映射类型。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为 readonly类型或可选的。 下面是一些例子：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</span><br><span class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Person&gt;;</span><br><span class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Person&gt;;</span><br></pre></td></tr></table></figure></li><li><p>下面来看看最简单的映射类型和它的组成部分：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Keys = <span class="string">'option1'</span> | <span class="string">'option2'</span>;</span><br><span class="line"><span class="keyword">type</span> Flags = &#123; [K <span class="keyword">in</span> Keys]: <span class="built_in">boolean</span> &#125;;</span><br></pre></td></tr></table></figure></li><li><p>它的语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分：</p><ol><li>类型变量 K，它会依次绑定到每个属性。</li><li>字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。</li><li>属性的结果类型。</li></ol></li><li><p>在个简单的例子里， Keys是硬编码的的属性名列表并且属性类型永远是 boolean，因此这个映射类型等同于：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Flags = &#123;</span><br><span class="line">    option1: <span class="built_in">boolean</span>;</span><br><span class="line">    option2: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在真正的应用里，可能不同于上面的 Readonly或 Partial。 它们会基于一些已存在的类型，且按照一定的方式转换字段。 这就是 keyof和索引访问类型要做的事情：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Nullable&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]: T[P] | <span class="literal">null</span> &#125;</span><br><span class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123; [P <span class="keyword">in</span> keyof T]?: T[P] &#125;</span><br></pre></td></tr></table></figure></li><li><p>在这些例子里，属性列表是 keyof T且结果类型是 T[P]的变体。 这是使用通用映射类型的一个好模版。 因为这类转换是 同态的，映射只作用于 T的属性而没有其它的。 编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设 Person.name是只读的，那么 Partial<person>.name也将是只读的且为可选的。</person></p></li></ul><p>下面是另一个例子， T[P]被包装在 Proxy<t>类里：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Proxy&lt;T&gt; = &#123;</span><br><span class="line">    <span class="keyword">get</span>(): T;</span><br><span class="line">    <span class="keyword">set</span>(value: T): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Proxify&lt;T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> keyof T]: Proxy&lt;T[P]&gt;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">proxify</span>&lt;<span class="title">T</span>&gt;(<span class="params">o: T</span>): <span class="title">Proxify</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// ... wrap proxies ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> proxyProps = proxify(props);</span><br></pre></td></tr></table></figure></t></p><ul><li><p>注意 Readonly<t>和 Partial<t>用处不小，因此它们与 Pick和 Record一同被包含进了TypeScript的标准库里：</t></t></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T[P];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, T&gt; = &#123;</span><br><span class="line">    [P <span class="keyword">in</span> K]: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Readonly， Partial和 Pick是同态的，但 Record不是。 因为 Record并不需要输入类型来拷贝属性，所以它不属于同态：</p></li><li>非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ThreeStringProps = Record&lt;<span class="string">'prop1'</span> | <span class="string">'prop2'</span> | <span class="string">'prop3'</span>, <span class="built_in">string</span>&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="由映射类型进行推断"><a href="#由映射类型进行推断" class="headerlink" title="由映射类型进行推断"></a>由映射类型进行推断</h4><ul><li><p>现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。 其实这也非常容易：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unproxify</span>&lt;<span class="title">T</span>&gt;(<span class="params">t: Proxify&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &#123;&#125; <span class="keyword">as</span> T;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> k <span class="keyword">in</span> t) &#123;</span><br><span class="line">        result[k] = t[k].get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> originalProps = unproxify(proxyProps);</span><br></pre></td></tr></table></figure></li><li><p>注意这个拆包推断只适用于同态的映射类型。 如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。</p></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>这个就是我学习Ts的第九天的笔记，欢迎更多的同行大哥指导交流</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript 笔记" scheme="http://yoursite.com/tags/TypeScript-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>2019年2-4月开发心得</title>
    <link href="http://yoursite.com/2019/04/23/2019-04-23%E5%BF%83%E5%BE%97/"/>
    <id>http://yoursite.com/2019/04/23/2019-04-23心得/</id>
    <published>2019-04-23T13:24:10.407Z</published>
    <updated>2019-04-23T23:36:54.988Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="开发心得"><a href="#开发心得" class="headerlink" title="开发心得"></a>开发心得</h3><p>这段时间，参与了一些实战项目的开发，个人开发、多人协同开发都有经历，个人开发主要是自己一个人去开发，有问题解决问题但是解决问题的方法比较局限与自己的解决方法，这里多人开发优势可能会比较好，多人都会有解决问题的方案这样就可以择选更优的解决方式更有利提高，<br>在实战开发的过程中，遇到很多自己没有尝试过的写法很多自己不懂得都得一点点的去查去理解，观看别人的源码时需要一点一点的去梳理阅读特别是那些没有注释的最为过分，与人开发比较重要的是相互的沟通，彼此包容这样才能更好的协同开发，现在终于把两个项目都写完了，确实<br>通过项目的洗礼成长了很多，再次使用php编写后台api就显得得心应手了、小程序也熟悉了很多，使用后端常用的断点调试在前后端都是查错的好帮手，终于可以再次继续TypeScript的学习了，并完成我的elm计划（仿完整的elm前后台+后端）</p><p>半个月前买了个阿里服务器，也花了点时间备案部署网站，安装环境熟悉了node上线部署，php上线部署，并记录方法</p><p>忙碌的时候，所有的时间都用来做事，一旦闲下来好想你</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="个人" scheme="http://yoursite.com/categories/%E4%B8%AA%E4%BA%BA/"/>
    
    
      <category term="个人" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 Centos 7 Apache 配置https</title>
    <link href="http://yoursite.com/2019/04/18/%E9%98%BF%E9%87%8C%E4%BA%91Apache%E9%85%8D%E7%BD%AEhttps/"/>
    <id>http://yoursite.com/2019/04/18/阿里云Apache配置https/</id>
    <published>2019-04-18T09:28:14.352Z</published>
    <updated>2019-04-26T07:40:08.752Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>当我们购买了服务器各种环境都搭建php都搭好项目都放上去了</li><li>为了在小程序中使用所以需要配置https，在这之前申请证书是需要域名的所以我购买了域名</li><li>经过一系列的备案，是真的麻烦，告诫各位备案信息一定要看清楚不然也会和我一样弄好久</li><li>虽然今天备案成功但是信息通信还是需要时间不能马上就配置进入小程序</li><li>弄了一下午终于弄好，后来想吧nginx也配置了但是遇到了麻烦也没有找到安装包在哪里暂时放弃</li><li>先把这个记录下来，后面有时间再去攻破nginx的配置</li></ul><h1 id="配置-工具"><a href="#配置-工具" class="headerlink" title="配置/工具"></a>配置/工具</h1><ul><li>阿里云服务器等</li><li>Apache环境安装</li><li>已购买域名，并且备案通过</li><li>熟悉vim为佳</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h3 id="申请证书"><a href="#申请证书" class="headerlink" title="申请证书"></a>申请证书</h3><ol><li><a href="https://common-buy.aliyun.com/?spm=5176.2020520163.cas.1.2af3uTHfuTHfVa&amp;commodityCode=cas#/buy" target="_blank" rel="noopener">购买免费ssl证书地址</a></li></ol><ul><li>没钱的直接买免费，有钱的可以自行选配<br><img src="/aly/ssl1.png" alt="ssl"></li></ul><ol start="2"><li>跟着指示到ssl证书申请验证<br><img src="/aly/ssl2.png" alt="ssl"></li></ol><h3 id="申请验证通过后下载证书"><a href="#申请验证通过后下载证书" class="headerlink" title="申请验证通过后下载证书"></a>申请验证通过后下载证书</h3><ul><li>下载apache证书<br><img src="/aly/ssl3.png" alt="ssl"><br><img src="/aly/ssl4.png" alt="ssl"></li></ul><h3 id="上传证书"><a href="#上传证书" class="headerlink" title="上传证书"></a>上传证书</h3><ol><li><p>创建存放证书目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir /etc/httpd/cert</span><br></pre></td></tr></table></figure></li><li><p>把所以证书放上去（先进入下载解压的路径）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r ./zerg.zip root@yhf7.top:/etc/httpd/cert</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/ssl5.png" alt="ssl"></p><h3 id="安装-配置mod-ssl"><a href="#安装-配置mod-ssl" class="headerlink" title="安装/配置mod_ssl"></a>安装/配置mod_ssl</h3><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mod_ssl openssl</span><br></pre></td></tr></table></figure></li><li><p>配置(更加图片改)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/httpd/conf.d/ssl.conf</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/ssl7.png" alt="ssl"><br><img src="/aly/ssl6.png" alt="ssl"></p><h3 id="端口重定向-设置好就重启服务器"><a href="#端口重定向-设置好就重启服务器" class="headerlink" title="端口重定向(设置好就重启服务器)"></a>端口重定向(设置好就重启服务器)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/httpd/conf/httpd.conf</span><br><span class="line"></span><br><span class="line">&lt;VirtualHost *:80&gt; </span><br><span class="line">ServerName yhf7.top  //自己的域名：</span><br><span class="line">RewriteEngine on </span><br><span class="line">RewriteCond %&#123;SERVER_PORT&#125; !^443$ </span><br><span class="line">RewriteRule ^/?(.*)$ https://%&#123;SERVER_NAME&#125;/<span class="variable">$1</span> [L,R] </span><br><span class="line">&lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure><p><img src="/aly/ssl8.png" alt="ssl"></p><h3 id="查看效果"><a href="#查看效果" class="headerlink" title="查看效果"></a>查看效果</h3><p><img src="/aly/ssl9.png" alt="ssl"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>配置apache服务器https就说到这里了，下一次部署nginx，有问题欢迎私聊我</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 自学笔记8 类型兼容性</title>
    <link href="http://yoursite.com/2019/04/16/TypeScript%E7%AC%94%E8%AE%B08/"/>
    <id>http://yoursite.com/2019/04/16/TypeScript笔记8/</id>
    <published>2019-04-16T09:39:50.365Z</published>
    <updated>2019-04-16T09:42:32.342Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li><p>TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。）</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Named;</span><br><span class="line"><span class="comment">// OK, because of structural typing</span></span><br><span class="line">p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></li><li><p>TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。</p></li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h3 id="属性赋值"><a href="#属性赋值" class="headerlink" title="属性赋值"></a>属性赋值</h3><ul><li>TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性</li><li>这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Named;</span><br><span class="line"><span class="comment">// y's inferred type is &#123; name: string; location: string; &#125;</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; name: <span class="string">'Alice'</span>, location: <span class="string">'Seattle'</span> &#125;;</span><br><span class="line">x = y;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br><span class="line"><span class="comment">// &#123; name: 'Alice', location: 'Seattle' &#125;</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>检查函数参数</li><li>y有个额外的location属性，但这不会引发错误。 只有目标类型（这里是Named）的成员会被一一检查是否兼容</li><li>只有相同给规则才会被提取出来</li><li>这个比较过程是递归进行的，检查每个成员及子成员<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">n: Named</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + n.name);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'test'</span>, + n.location)<span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line">greet(y);</span><br></pre></td></tr></table></figure></li></ul><h3 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h3><ul><li>相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手</li><li><p>要赋值首先要判断参数个数和参数类型，查看赋值中的参数是否被赋值中都有对于都参数存在</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line">x = y; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure></li><li><p>要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。</p></li><li>第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。</li><li>你可能会疑惑为什么允许忽略参数，像例子y = x中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如，Array#forEach给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Don't force these extra arguments</span></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item, index, array</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Should be OK!</span></span><br><span class="line">items.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="built_in">console</span>.log(item));</span><br><span class="line"><span class="comment">// 123123</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数</li><li><p>依然结果还是一样的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">'Alice'</span>&#125;);</span><br><span class="line"><span class="keyword">let</span> y = <span class="function"><span class="params">()</span> =&gt;</span> (&#123;name: <span class="string">'Alice'</span>, location: <span class="string">'Seattle'</span>&#125;);</span><br><span class="line">x = y; <span class="comment">// OK</span></span><br><span class="line">y = x; <span class="comment">// Error, because x() lacks a location property</span></span><br></pre></td></tr></table></figure></li><li><p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型</p></li></ul><h4 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="函数参数双向协变"></a>函数参数双向协变</h4><ul><li>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式</li><li>下面的例子都是指定着一些不安全的写法不允许的写法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EventType &#123; Mouse, Keyboard &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Event &#123; timestamp: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> MouseEvent <span class="keyword">extends</span> Event &#123; x: <span class="built_in">number</span>; y: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> KeyEvent <span class="keyword">extends</span> Event &#123; keyCode: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line">function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsound, but useful and common</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(e.x + <span class="string">','</span> + e.y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Undesirable alternatives in presence of soundness</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">console</span>.log((&lt;MouseEvent&gt;e).x + <span class="string">','</span> + (&lt;MouseEvent&gt;e).y));</span><br><span class="line">listenEvent(EventType.Mouse, &lt;<span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">void</span>&gt;<span class="function">(<span class="params">(<span class="params">e: MouseEvent</span>) =&gt; <span class="built_in">console</span>.log(<span class="params">e.x + ',' + e.y</span>)</span>));</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="params">Still</span> <span class="params">disallowed</span> (<span class="params">clear error</span>). <span class="params">Type</span> <span class="params">safety</span> <span class="params">enforced</span> <span class="params">for</span> <span class="params">wholly</span> <span class="params">incompatible</span> <span class="params">types</span></span></span><br><span class="line"><span class="function"><span class="params">listenEvent</span>(<span class="params">EventType.Mouse, (<span class="params">e: <span class="built_in">number</span></span>) =&gt; <span class="built_in">console</span>.log(<span class="params">e</span>)</span>);</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="可选参数及剩余参数"><a href="#可选参数及剩余参数" class="headerlink" title="可选参数及剩余参数"></a>可选参数及剩余参数</h4><ul><li>比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误</li><li>当一个函数有剩余参数时，它被当做无限个可选参数</li><li>这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded</li><li>其实用可选和不用是一样的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123;</span><br><span class="line">    <span class="comment">/* ... Invoke callback with 'args' ... */</span></span><br><span class="line">    <span class="comment">// 调用1</span></span><br><span class="line">    callback(args)</span><br><span class="line">    <span class="comment">// 1,2, undefined</span></span><br><span class="line">    <span class="comment">// 1,2, undefined</span></span><br><span class="line">    <span class="comment">// 调用2</span></span><br><span class="line">    callback(...args)</span><br><span class="line">    <span class="comment">// 1,2</span></span><br><span class="line">    <span class="comment">// 1,2</span></span><br><span class="line">    <span class="comment">// 调用3</span></span><br><span class="line">    callback()</span><br><span class="line">    <span class="comment">// undefined,undefined</span></span><br><span class="line">    <span class="comment">// undefined,undefined</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsound - invokeLater "might" provide any number of arguments</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">', '</span> + y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Confusing (x and y are actually required) and undiscoverable</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x?, y?</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">', '</span> + y));</span><br></pre></td></tr></table></figure></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123; Ready, Waiting &#125;;</span><br><span class="line"><span class="keyword">enum</span> Color &#123; Red, Blue, Green &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里如果使用status的命名接收也是会报错的</span></span><br><span class="line"><span class="keyword">let</span> test = Status.Ready; <span class="comment">//0</span></span><br><span class="line">test = Color.Green;  <span class="comment">// Error ，虽然报错但是执行js文件是可以输出2的</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test)</span><br></pre></td></tr></table></figure></li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><ul><li>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    feet: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line">    feet: <span class="built_in">number</span>;</span><br><span class="line">    <span class="comment">// 1.如果加入一个string在这里</span></span><br><span class="line">    test: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">numFeet: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> s: Size;</span><br><span class="line"></span><br><span class="line">a = s;  <span class="comment">// OK</span></span><br><span class="line">s = a;  <span class="comment">// OK , 2.这里就无法赋值了</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="类的私有成员和受保护成员"><a href="#类的私有成员和受保护成员" class="headerlink" title="类的私有成员和受保护成员"></a>类的私有成员和受保护成员</h4><ul><li>的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">  feet: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line"> <span class="keyword">private</span> feet: <span class="built_in">number</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">numFeet: <span class="built_in">number</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> s: Size;</span><br><span class="line"></span><br><span class="line">a = s;  <span class="comment">// error</span></span><br><span class="line">s = a;  <span class="comment">// error</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li><p>因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">//0k</span></span><br></pre></td></tr></table></figure></li><li><p>上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;</span><br><span class="line">  data: T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y; <span class="comment">//error</span></span><br><span class="line"><span class="comment">// 因为用到了具体实例上，就不再是范型就存在差异了</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较，就像上面第一个例子<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> identity = <span class="function"><span class="keyword">function</span>&lt;<span class="title">T</span>&gt;(<span class="params">x: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> reverse = <span class="function"><span class="keyword">function</span>&lt;<span class="title">U</span>&gt;(<span class="params">y: U</span>): <span class="title">U</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">identity = reverse;</span><br></pre></td></tr></table></figure></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>这个就是我学习Ts的第八天的笔记，后面学习ts的高级类型，欢迎更多的同行大哥指导交流</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript 笔记" scheme="http://yoursite.com/tags/TypeScript-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 自学笔记7 枚举</title>
    <link href="http://yoursite.com/2019/04/15/TypeScript%E7%AC%94%E8%AE%B07/"/>
    <id>http://yoursite.com/2019/04/15/TypeScript笔记7/</id>
    <published>2019-04-15T12:59:53.501Z</published>
    <updated>2019-04-15T13:00:54.083Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>近来花了大量时间在做项目重构忽略了ts的学习，今天已经完成了工作</li><li>接着之前的学习，继续学习我们的ts，今天学枚举</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。</li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><ul><li>我们定义了一个数字枚举， Up使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Direction.Up的值为 1， Down为 2， Left为 3， Right为 4。</li><li>如果不定义1 那就从0开始递增<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="number">1</span>,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up,<span class="comment">//0</span></span><br><span class="line">    Down,<span class="comment">//1</span></span><br><span class="line">    Left,<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>简单的通过枚举的属性来访问枚举成员</li><li>可能会有一些报错提醒，直接运行node跑js就好了<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Response &#123;</span><br><span class="line">  No = <span class="number">0</span>,</span><br><span class="line">  Yes = <span class="number">1</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">recipient: <span class="built_in">string</span>, message: Response</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Yes'</span>, message) <span class="comment">// 输出 Yes 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">respond(<span class="string">"Princess Caroline"</span>, Response.Yes)</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>数字枚举可以被混入到 计算过的和常量成员（如下所示）。 简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。 换句话说，下面的情况是不被允许的：</li><li>就是说可以用但是不能放在前面<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">    A = getSomeValue(),</span><br><span class="line">    B, <span class="comment">// error! 'A' is not constant-initialized, so 'B' needs an initializer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><ul><li>字符串枚举的概念很简单，但是有细微的 运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。</li><li>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管 反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="string">"UP"</span>,</span><br><span class="line">    Down = <span class="string">"DOWN"</span>,</span><br><span class="line">    Left = <span class="string">"LEFT"</span>,</span><br><span class="line">    Right = <span class="string">"RIGHT"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><ul><li>从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做：</li><li>除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BooleanLikeHeterogeneousEnum &#123;</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes = <span class="string">"YES"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h3><ul><li>每个枚举成员都带有一个值，它可以是 常量或 计算出来的。 当满足如下条件时，枚举成员被当作是常量：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为数字常量 0</span></span><br><span class="line"><span class="keyword">enum</span> E &#123; X &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认为数字常量 当前是上一位的+1 , 0,1,2</span></span><br><span class="line"><span class="keyword">enum</span> E1 &#123; X, Y, Z &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> E2 &#123; <span class="comment">// 1,2,3</span></span><br><span class="line">    A = <span class="number">1</span>, B, C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>枚举成员使用 常量枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：</p><ul><li>一个枚举表达式字面量（主要是字符串字面量或数字字面量）</li><li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li><li>带括号的常量枚举表达式</li><li>一元运算符 +, -, ~其中之一应用在了常量枚举表达式<br>常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。</li></ul></li></ul><h4 id="运算符-（字符串无法使用）"><a href="#运算符-（字符串无法使用）" class="headerlink" title="运算符 （字符串无法使用）"></a>运算符 （字符串无法使用）</h4><ul><li>| 表示两边求并集（元素相加，相同元素只出现一次）<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字例子</span></span><br><span class="line"><span class="keyword">enum</span> Test &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B = <span class="number">1</span>,</span><br><span class="line">    C = A | B</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 由于两个相等所以只会保留两个</span></span><br><span class="line"><span class="comment">// C = 1 = A = B</span></span><br><span class="line"><span class="keyword">enum</span> Test &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B = <span class="number">2</span>,</span><br><span class="line">    C = A | B</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// C = 3 = A+B</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串例子 x</span></span><br><span class="line"><span class="keyword">enum</span> Test &#123;</span><br><span class="line">    A = <span class="string">"abc"</span>,</span><br><span class="line">    B = <span class="string">"bcd"</span>,</span><br><span class="line">    C = A | B</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这样是错误的 字符串是不允许用计算属性的</span></span><br></pre></td></tr></table></figure></li></ul><hr><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AnimalFlags &#123;</span><br><span class="line">  None        = <span class="number">0</span>,</span><br><span class="line">  HasClaws    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// 1 x 2的0次方</span></span><br><span class="line">  CanFly      = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">// 1 x 2的1次方</span></span><br><span class="line">  EatsFish    = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 1 x 2的2次方</span></span><br><span class="line">  Endangered  = <span class="number">1</span> &lt;&lt; <span class="number">3</span> <span class="comment">// 1 x 2的3次方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>其实可以理解为前面的数乘以后面的数的2次方倍</li><li>我们使用了左移的位运算符，将数字 1 的二进制向左移动位置得到数字 0001、0010、0100 和 1000（换成十进制结果是：1, 2, 4, 8）。当你在使用这种标记的时候，这些位运算符 | (或)、&amp; （和）、~ （非）将会是你最好的朋友</li><li>其余的用个例子来说</li><li>&amp;:表示两边是否其中一个是另外一个的子集，如果是返回子集，否则返回0（如果其中一个包含另外一个，返回被包含的，否则返回0）</li><li>^：表示从两者的并集中去除两者的交集（把两个的元素合并到一起，如果两个中有公共元素，要将这个公共元素从合并的结果中去除）</li><li>～：表示取反，返回的结果我还不知道应该是什么，以后再查一下。用法主要和“&amp;”一起使用，例如：去除其中的某个元素<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举</span></span><br><span class="line"><span class="keyword">enum</span> AnimalFlags &#123;</span><br><span class="line">  None        = <span class="number">0</span>,</span><br><span class="line">  HasClaws    = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,<span class="comment">// 1</span></span><br><span class="line">  CanFly      = <span class="number">1</span> &lt;&lt; <span class="number">1</span> <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">interface</span> Animal &#123;</span><br><span class="line">  flags: AnimalFlags; <span class="comment">// &#123;None:0,HasClaws:1,CanFly:2&#125;</span></span><br><span class="line">  [key: <span class="built_in">string</span>]: <span class="built_in">any</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printAnimalAbilities</span>(<span class="params">animal: Animal</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'+'</span>,animal)</span><br><span class="line">  <span class="keyword">var</span> animalFlags = animal.flags;</span><br><span class="line">  <span class="keyword">if</span> (animalFlags &amp; AnimalFlags.HasClaws) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'animal has claws'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (animalFlags &amp; AnimalFlags.CanFly) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'animal can fly'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (animalFlags == AnimalFlags.None) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'nothing'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line"><span class="keyword">var</span> animal = &#123; flags: AnimalFlags.None &#125;;<span class="comment">// 0</span></span><br><span class="line">printAnimalAbilities(animal); <span class="comment">// nothing</span></span><br><span class="line"><span class="comment">// 两个相加，相同的不加</span></span><br><span class="line">animal.flags |= AnimalFlags.HasClaws; <span class="comment">// 1</span></span><br><span class="line">printAnimalAbilities(animal); <span class="comment">// animal has claws</span></span><br><span class="line"><span class="comment">// 清除</span></span><br><span class="line">animal.flags &amp;= ~AnimalFlags.HasClaws; <span class="comment">//0</span></span><br><span class="line">printAnimalAbilities(animal); <span class="comment">// nothing</span></span><br><span class="line"><span class="comment">// 和 = 两个的和</span></span><br><span class="line">animal.flags |= AnimalFlags.HasClaws | AnimalFlags.CanFly; <span class="comment">// 3</span></span><br><span class="line">printAnimalAbilities(animal); <span class="comment">// animal has claws, animal can fly</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">+ &#123; flags: <span class="number">0</span> &#125;</span><br><span class="line">nothing1</span><br><span class="line">+ &#123; flags: <span class="number">1</span> &#125;</span><br><span class="line">animal has claws</span><br><span class="line">+ &#123; flags: <span class="number">0</span> &#125;</span><br><span class="line">nothing1</span><br><span class="line">+ &#123; flags: <span class="number">3</span> &#125;</span><br><span class="line">animal has claws</span><br><span class="line">animal can fly</span><br></pre></td></tr></table></figure></li></ul><h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><ul><li>存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为<ul><li>任何字符串字面量（例如： “foo”， “bar”， “baz”）</li><li>任何数字字面量（例如： 1, 100）</li><li>应用了一元 -符号的数字字面量（例如： -1, -100）</li></ul></li><li><p>首先，枚举成员成为了类型！ 例如，我们可以说某些成员 只能是枚举成员的值</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ShapeKind &#123;</span><br><span class="line">    Circle,</span><br><span class="line">    Square,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: ShapeKind.Circle;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: ShapeKind.Square;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: Circle = &#123;</span><br><span class="line">    kind: ShapeKind.Square,</span><br><span class="line">    <span class="comment">//    ~~~~~~~~~~~~~~~~ Error!</span></span><br><span class="line">    radius: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line"><span class="keyword">let</span> c: Circle = &#123;</span><br><span class="line">  kind: <span class="number">100</span>, <span class="comment">// 默认数字类型写个数字</span></span><br><span class="line">  <span class="comment">//    ~~~~~~~~~~~~~~~~ Error!</span></span><br><span class="line">  radius: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line"><span class="comment">// &#123; kind: 100, radius: 100 &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>另一个变化是枚举类型本身变成了每个枚举成员的 联合。 虽然我们还没有讨论<a href="./Advanced Types.md#union-types">联合类型</a>，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: E</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x !== E.Foo || x !== E.Bar) &#123; <span class="comment">// 其实就是说第一个都没有了还判断第二个干嘛是不是傻</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//             ~~~~~~~~~~~</span></span><br><span class="line">        <span class="comment">// Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个例子里，我们先检查 x是否不是 E.Foo。 如果通过了这个检查，然后 ||会发生短路效果， if语句体里的内容会被执行。 然而，这个检查没有通过，那么 x则 只能为 E.Foo，因此没理由再去检查它是否为 E.Bar。</p></li></ul><h3 id="运行时的枚举"><a href="#运行时的枚举" class="headerlink" title="运行时的枚举"></a>运行时的枚举</h3><ul><li>枚举是在运行时真正存在的对象。 例如下面的枚举：<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">    X, Y, Z</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">obj: &#123; X: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.X;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">obj: &#123; Y: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.Y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Works, since 'E' has a property named 'X' which is a number.</span></span><br><span class="line"><span class="built_in">console</span>.log(f(E));</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1 改后</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h3><ul><li><p>除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字。 例如，在下面的例子中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Enum.A;</span><br><span class="line"><span class="keyword">let</span> nameOfA = Enum[a]; <span class="comment">// "A"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">var</span> Enum;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">Enum</span>) </span>&#123;</span><br><span class="line">    Enum[Enum[<span class="string">"A"</span>] = <span class="number">0</span>] = <span class="string">"A"</span>;</span><br><span class="line">&#125;)(Enum || (Enum = &#123;&#125;));</span><br><span class="line"><span class="keyword">var</span> a = Enum.A;</span><br><span class="line"><span class="keyword">var</span> nameOfA = Enum[a]; <span class="comment">// "A"</span></span><br></pre></td></tr></table></figure></li><li><p>生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</p></li></ul><h3 id="const枚举"><a href="#const枚举" class="headerlink" title="const枚举"></a>const枚举</h3><ul><li>大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 常量枚举通过在枚举上使用 const修饰符来定义。</li><li>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h3><ul><li><p>外部枚举用来描述已经存在的枚举类型的形状。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B,</span><br><span class="line">    C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>时隔多日我又回来了，这个就是我学习Ts的第七天的笔记，欢迎更多的同行大哥指导交流</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript 笔记" scheme="http://yoursite.com/tags/TypeScript-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 Linux 与本地之间如何用命令传输文件和文件夹</title>
    <link href="http://yoursite.com/2019/04/09/%E9%98%BF%E9%87%8C%E4%BA%91%20Linux%20%E4%B8%8E%E6%9C%AC%E5%9C%B0%20%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/"/>
    <id>http://yoursite.com/2019/04/09/阿里云 Linux 与本地 文件传输/</id>
    <published>2019-04-09T05:04:01.155Z</published>
    <updated>2019-04-09T05:04:01.155Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>记录一下线上和线下是如何传输的</li><li>买了服务器以来一直都是使用命令链接服务器</li><li>如果想使用界面化工具的话宝塔那些也是不错的，很多人推荐不过没用过</li><li>之前我说传文件夹不好传，应该是我那时候路径写的有问题导致的其实是可以传的</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h3 id="在本地向服务器传文件"><a href="#在本地向服务器传文件" class="headerlink" title="在本地向服务器传文件"></a>在本地向服务器传文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># scp【本地文件的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】</span><br><span class="line"></span><br><span class="line">$ scp ./scp1.png root@119.23.75.150:/home/admin/</span><br></pre></td></tr></table></figure><p><img src="/aly/scp1.png" alt="tcp"><br><img src="/aly/scp2.png" alt="tcp"></p><h3 id="在本地向服务器传文件夹"><a href="#在本地向服务器传文件夹" class="headerlink" title="在本地向服务器传文件夹"></a>在本地向服务器传文件夹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># scp -r【本地文件夹的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件夹的路径】</span><br><span class="line"></span><br><span class="line">$ scp -r ./html root@119.23.75.150:/home/admin/</span><br></pre></td></tr></table></figure><p><img src="/aly/scp3.png" alt="tcp"></p><h3 id="本地下载服务器文件"><a href="#本地下载服务器文件" class="headerlink" title="本地下载服务器文件"></a>本地下载服务器文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># scp【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】 【本地文件的路径】</span><br><span class="line"></span><br><span class="line">$ scp root@119.23.75.150:/home/admin/scp1.png ./</span><br></pre></td></tr></table></figure><p><img src="/aly/scp4.png" alt="tcp"></p><h3 id="本地下载服务器文件夹-不加-r会报错"><a href="#本地下载服务器文件夹-不加-r会报错" class="headerlink" title="本地下载服务器文件夹(不加-r会报错)"></a>本地下载服务器文件夹(不加-r会报错)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># scp -r【服务器用户名】@【服务器地址】：【服务器上存放文件夹的路径】 【本地文件夹的路径】</span><br><span class="line"></span><br><span class="line">$ scp -r root@119.23.75.150:/home/admin/html ./</span><br></pre></td></tr></table></figure><p><img src="/aly/scp5.png" alt="tcp"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>linux的文件和文件夹下载与上传</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 Centos7 Node + Vue + Mysql + 自定义webapck打包 线上部署七步走</title>
    <link href="http://yoursite.com/2019/04/08/%E9%98%BF%E9%87%8C%E4%BA%91node+vue%E6%88%98%E5%B8%83/"/>
    <id>http://yoursite.com/2019/04/08/阿里云node+vue战布/</id>
    <published>2019-04-08T08:59:24.924Z</published>
    <updated>2019-04-11T15:16:40.924Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>买服务器就是为了尝试线上战布项目</li><li>前期我们已经把所有的环境都已经准备好了</li><li>买的是轻量级服务器自带配有node环境（node自带4.6我升到了8.0）和mongodb，不过我这个案例用的是mysql</li><li>所以我昨天安装了一下mysql，都准备好了今天就来把我之前的小案例放上来实现实战</li><li>我的整个案例原来完全是线下的，所以要把数据库迁移后台迁移再上前端</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>线上 Centose7 服务器（这个系统无差的都可以）</li><li>Node + Mysql 环境 （不懂的看我前面文章）</li><li>Node + Vue + Mysql 小案例一个(我用vue-cli打包比较方便你们随意着么高兴着么来) </li><li>Navicat for MySQL 数据库迁移</li><li>全局安装 node 8.0 以上版本</li><li>vs code 修改代码（软件一个自己喜欢）</li><li>熟悉vim</li><li>熟悉控制台操作为佳</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="第一步把本地数据库表迁移到线上数据库"><a href="#第一步把本地数据库表迁移到线上数据库" class="headerlink" title="第一步把本地数据库表迁移到线上数据库"></a>第一步把本地数据库表迁移到线上数据库</h2><ol><li><p>使用navicat 导出数据库数据表</p><p><img src="/aly/nv1.png" alt="npm"></p></li><li><p>在阿里云的服务器mysql导入数据库</p><p><img src="/aly/nv2.png" alt="npm"></p><p><img src="/aly/nv3.png" alt="npm"></p></li></ol><h2 id="第二步更改后端数据库连接方式与端口号"><a href="#第二步更改后端数据库连接方式与端口号" class="headerlink" title="第二步更改后端数据库连接方式与端口号"></a>第二步更改后端数据库连接方式与端口号</h2><ul><li><p>进入node后端案例mysql连接配置文件</p><p><img src="/aly/nv4.png" alt="npm"></p></li><li><p>检查端口是否占用了（如果修改了端口请记得到后台防火墙开启权限）</p><p><img src="/aly/nv5.png" alt="npm"></p></li></ul><h2 id="第三步传输到服务器"><a href="#第三步传输到服务器" class="headerlink" title="第三步传输到服务器"></a>第三步传输到服务器</h2><ul><li><p>我说过传文件夹不好传所以我们要打包传</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp 上传文件的地址 root@ip地址:上传到服务器什么位置</span><br></pre></td></tr></table></figure><p><img src="/aly/nv6.png" alt="npm"></p></li><li><p>进入到文件夹解压包文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ unzip 文件夹名.zip</span><br><span class="line">$ rm -rf 文件夹名.zip 清除压缩包</span><br></pre></td></tr></table></figure></li></ul><h2 id="第四步开启服务"><a href="#第四步开启服务" class="headerlink" title="第四步开启服务"></a>第四步开启服务</h2><ul><li><p>开启后端服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入文件夹</span></span><br><span class="line">$ <span class="built_in">cd</span> node_server</span><br><span class="line"><span class="comment"># 查看文件</span></span><br><span class="line">$ ls</span><br><span class="line"><span class="comment"># 安装依赖包(我安装了cnpm，如果没有的用npm安装包)</span></span><br><span class="line">$ cnpm i</span><br><span class="line"><span class="comment"># 跑项目</span></span><br><span class="line">$ node app.js</span><br></pre></td></tr></table></figure><p><img src="/aly/nv7.png" alt="npm"></p><p><img src="/aly/nv8.png" alt="npm"></p></li></ul><h2 id="第五步变更vue信息-打包-上传"><a href="#第五步变更vue信息-打包-上传" class="headerlink" title="第五步变更vue信息/打包/上传"></a>第五步变更vue信息/打包/上传</h2><h3 id="1-信息变更"><a href="#1-信息变更" class="headerlink" title="1. 信息变更"></a>1. 信息变更</h3><ul><li><p>变更请求地址，因为本来我是前后分离开发使用的是axios的请求所以默认用了vuecli的代理跨域</p></li><li><p>在线上放在服务区里面应该是不存在跨域的但是本来就是这样写了我改一下地址和端口算了其他就不做修改</p><p><img src="/aly/nv9.png" alt="npm"></p><h3 id="2-打包方法（vue-cli-webpack自定义）"><a href="#2-打包方法（vue-cli-webpack自定义）" class="headerlink" title="2.打包方法（vue-cli/webpack自定义）"></a>2.打包方法（vue-cli/webpack自定义）</h3><h4 id="打包方法一-vue-cli打包方法打包文件-得到dist文件夹"><a href="#打包方法一-vue-cli打包方法打包文件-得到dist文件夹" class="headerlink" title="打包方法一 vue-cli打包方法打包文件(得到dist文件夹)"></a>打包方法一 vue-cli打包方法打包文件(得到dist文件夹)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure></li></ul><h5 id="打包方法二-自定义配置webpack（非vue-cli构建的项目才使用）"><a href="#打包方法二-自定义配置webpack（非vue-cli构建的项目才使用）" class="headerlink" title="打包方法二 自定义配置webpack（非vue-cli构建的项目才使用）"></a>打包方法二 自定义配置webpack（非vue-cli构建的项目才使用）</h5><ol><li>安装依赖（全局安装是我的个人习惯）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由于现在安装的都是4.29.0以上的版本了所以要一并安装webpack-cli</span></span><br><span class="line">$ cnpm i webpack webpack-cli -g</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/w1.png" alt="webpack"></p><ol start="2"><li>配置打包文件（在项目的根目录建立webpack.config.js文件）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const path = require(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/main.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/w2.png" alt="webpack"></p><ol start="3"><li>打包<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npx webpack --config webpack.config.js</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/w3.png" alt="webpack"><br><img src="/aly/w4.png" alt="webpack"></p><ol start="4"><li>如果你不希望在控制它输入着么多想npm run dev这样多方式打开也是可以的<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm run build</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/w5.png" alt="webpack"></p><h3 id="3-上传打包文件（我们只是需要里面的文件其他都不需要）"><a href="#3-上传打包文件（我们只是需要里面的文件其他都不需要）" class="headerlink" title="3. 上传打包文件（我们只是需要里面的文件其他都不需要）"></a>3. 上传打包文件（我们只是需要里面的文件其他都不需要）</h3><ul><li>这里按照相同的方法传到线上的public文件夹里面</li></ul><p><img src="/aly/nv10.png" alt="npm"></p><h2 id="第六步变更后端路由"><a href="#第六步变更后端路由" class="headerlink" title="第六步变更后端路由"></a>第六步变更后端路由</h2><ul><li><p>配置静态资源库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim app.js</span><br></pre></td></tr></table></figure><p><img src="/aly/nv11.png" alt="npm"></p></li></ul><h2 id="第七步开启服务查看线上网页-持久化开启"><a href="#第七步开启服务查看线上网页-持久化开启" class="headerlink" title="第七步开启服务查看线上网页/持久化开启"></a>第七步开启服务查看线上网页/持久化开启</h2><ul><li>开启服务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node app.js</span><br></pre></td></tr></table></figure><p><img src="/aly/nv12.png" alt="npm"></p><ul><li>持久化管理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pm2 start app.js</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>阿里云node+vue+mysql战部记录，不知道对不对但是我觉得是成功的</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 Centos 7 安装 PHP开发环境 Apache/PHP</title>
    <link href="http://yoursite.com/2019/04/08/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85PHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/04/08/阿里云安装PHP开发环境/</id>
    <published>2019-04-08T02:50:27.726Z</published>
    <updated>2019-04-12T01:41:23.636Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>既然搭了mysql，为什么不把php也布置上来呢</li><li>这就安装Apache，弄了一晚上也是出现了一些错误弄了几次最后战胜了它</li></ul><h1 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h1><h2 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h2><ol><li>查看系统是否已经安装,我已经安装了所以会已经存在 （如果没有的直接看后面安装就好）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -qa | grep httpd</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/p1.png" alt="php"></p><ol start="2"><li><p>停止服务器运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/sbin/httpd -k stop</span><br></pre></td></tr></table></figure></li><li><p>清空原有点安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y erase httpd.x86_64</span><br></pre></td></tr></table></figure></li><li><p>再次查看是否已经清空(如果没有请继续清除)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list | grep httpd</span><br></pre></td></tr></table></figure></li></ol><h2 id="yum命令安装http"><a href="#yum命令安装http" class="headerlink" title="yum命令安装http"></a>yum命令安装http</h2><ol><li>安装httpd<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$  yum -y install httpd</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/p2.png" alt="php"></p><ol start="2"><li><p>删除默认的欢迎页面(这个没有截图)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -f /etc/httpd/conf.d/welcome.conf</span><br></pre></td></tr></table></figure></li><li><p>配置httpd，将服务器名称替换为您自己的环境 （默认的80端口最好别动）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/httpd/conf/httpd.conf</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line"><span class="comment"># line 86: 改变管理员的邮箱地址</span></span><br><span class="line">ServerAdmin root@905477376@qq.com</span><br><span class="line"><span class="comment"># line 95: 改变域名信息 (域名还没批先用公网ip代替着)</span></span><br><span class="line">ServerName 119.23.75.150:80</span><br><span class="line"><span class="comment"># line 151: none变成All</span></span><br><span class="line">AllowOverride All</span><br><span class="line"><span class="comment"># line 164: 添加只能使用目录名称访问的文件名</span></span><br><span class="line">DirectoryIndex index.html index.cgi index.php</span><br></pre></td></tr></table></figure></li></ol><hr><p><img src="/aly/p3.png" alt="php"><br><img src="/aly/p6.png" alt="php"><br><img src="/aly/p7.png" alt="php"><br><img src="/aly/p8.png" alt="php"></p><ol start="4"><li>开启服务器 (如果用的是阿里轻量级安装有nginx的这里要注意了)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl start httpd(这个开启也可以)</span><br><span class="line">$ httpd（我个人喜欢直接用这个开启服务）</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/p4.png" alt="php"></p><ol start="5"><li>假如出现上图那个98的那个错误其实就是端口被占用（nginx引起的错误）</li></ol><ul><li>解决方法1按照上面图片说的改一个端口就好了</li><li>解决方法2：屏蔽反向代理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.修改配置</span></span><br><span class="line">$ vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br><span class="line"><span class="comment"># 2.检查修改是否合法</span></span><br><span class="line">$ /usr/<span class="built_in">local</span>/nginx/sbin/nginx -t</span><br><span class="line"><span class="comment"># 出现下面这两句表示正确</span></span><br><span class="line"><span class="comment"># the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok</span></span><br><span class="line"><span class="comment"># configuration file /usr/local/nginx/conf/nginx.conf test is successful</span></span><br><span class="line"><span class="comment"># 3.重启nginx</span></span><br><span class="line">$ /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/p5.png" alt="php"></p><ol start="6"><li><p>设置默认启动httpd</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl <span class="built_in">enable</span> httpd</span><br></pre></td></tr></table></figure></li><li><p>如果开启了防火墙的指向下面的命令开启（阿里轻量级不需要，在后台设置就好不过默认就是80）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ firewall-cmd --add-service=http --permanent</span><br><span class="line"><span class="comment"># 出现 success 成功</span></span><br><span class="line">$ firewall-cmd --reload</span><br><span class="line"><span class="comment"># 出现 success 成功</span></span><br></pre></td></tr></table></figure></li><li><p>第一个服务器页面（刚才一开始被我们删了）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /var/www/html/index.html</span><br></pre></td></tr></table></figure></li></ol><ul><li>写入这一段进去保存<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%; font-size: 40px; font-weight: bold; text-align: center;"</span>&gt;</span></span><br><span class="line">Welcome access LinuxProbe.org,This is Test Page!</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="9"><li>查看第一个服务器页面</li></ol><ul><li>网页打开输入自己的域名或者ip，能出现图片中的样子就是配置成功了<br><img src="/aly/p9.png" alt="php"></li></ul><h2 id="Apache-常用命令"><a href="#Apache-常用命令" class="headerlink" title="Apache 常用命令"></a>Apache 常用命令</h2><ul><li>开机和关闭命令中有多个，选其一使用就好<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 开启</span></span><br><span class="line">$ httpd</span><br><span class="line">$ /usr/sbin/httpd -k start</span><br><span class="line">$ systemctl start httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">$ /usr/sbin/httpd -k stop</span><br><span class="line">$ systemctl stop httpd.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">$ /usr/sbin/httpd -k restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开机启动/关闭</span></span><br><span class="line">systemctl <span class="built_in">enable</span> httpd.service <span class="comment">#开机启动</span></span><br><span class="line">systemctl <span class="built_in">disable</span> httpd.service <span class="comment">#开机不启动</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 状态检查</span></span><br><span class="line">$ systemctl status httpd.service</span><br></pre></td></tr></table></figure></li></ul><h1 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h1><ol><li>安装<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install php php-mbstring php-pear</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/php1.png" alt="php"></p><ol start="2"><li>设置时区<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vim /etc/php.ini</span><br><span class="line"><span class="comment"># line 878: 取消注释，设置时区</span></span><br><span class="line">date.timezone = <span class="string">"Asia/Shanghai"</span></span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/php2.png" alt="php"></p><ol start="3"><li>创建一个PHP测试页面，并使用Web浏览器从客户端PC访问它。如果显示以下页面，它是确定。(ip+index.php)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /var/www/html/index.php</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%; font-size: 40px; font-weight: bold; text-align: center;"</span>&gt;</span></span><br><span class="line">&lt;?php</span><br><span class="line">   print Date("Y/m/d");</span><br><span class="line">?&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="/aly/php3.png" alt="php"></p><ol start="4"><li>创建phpinfo测试页，确认是都开启php支持<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"&lt;?php phpinfo(); ?&gt;"</span> &gt; /var/www/html/phpinfo.php</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/php4.png" alt="php"></p><ol start="5"><li>安装常用拓展依赖(由于linux中php的源包把安装依赖去除了为了后续开发方便要把常用依赖安装了)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y install php-mysql php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-soap curl curl-devel</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/php5.png" alt="php"></p><ol start="6"><li>链接数据库测试(创建test.php,也可以下载阿里云的测试mysql)</li></ol><ul><li><a href="https://help.aliyun.com/knowledge_detail/36302.html" target="_blank" rel="noopener">阿里云mysql测试代码地址</a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$conn = @mysqli_connect(&quot;端口号&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;数据库名&quot;);</span><br><span class="line">if (!$conn) &#123;</span><br><span class="line">        die(&quot;连接失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> echo &quot;连接成功&quot;;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/php6.png" alt="php"><br><img src="/aly/php7.png" alt="php"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>安装了mysql当然也要试试PHP啦，这就是我安装apache和php的方法和解决错误方法，下一个说node+vue战布</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 Centos 7 安装5.6mysql</title>
    <link href="http://yoursite.com/2019/04/07/%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%855.6mysql/"/>
    <id>http://yoursite.com/2019/04/07/阿里云安装5.6mysql/</id>
    <published>2019-04-07T07:44:47.407Z</published>
    <updated>2019-04-07T10:52:50.622Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>买了服务器当然要尽情的糟蹋它，给了钱的不能浪费啊</li><li>昨天开启了默认的mongodb然后把之前弄的mongodb的项目放了上去</li><li>我就想mysql的能不能放上去呢，虽然是轻量级应用但是他也是服务器啊只是默认会安装一种语言而已</li><li>那我就想把mysql装上去，为了避免新版与旧版起冲突我就安装了5.6版的我本地好像是5.6还是5.5忘记了</li><li>自己安装是个巨坑希望能帮到你</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>Centos 7 服务器</li><li>熟悉vim</li><li>本地 Navicat of Mysql 测试连接</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><ol><li><p>检查服务器是否自带有mysql(用别人镜像的需要注意)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum list installed | grep mysql</span><br></pre></td></tr></table></figure></li><li><p>如果发现有系统自带mysql，果断这么干</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum -y remove mysql-libs.x86_64</span><br></pre></td></tr></table></figure></li><li><p>随便在你存放文件的目录下执行，mysql的yum源服务器在国外的，会比较慢不过我有梯子我不怕哈哈哈</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>这个rpm还不是mysql的安装文件，只是两个yum源文件，执行后，在/etc/yum.repos.d/ 这个目录下多出mysql-community-source.repo和mysql-community.repo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rpm -ivh mysql-community-release-el6-5.noarch.rpm</span><br></pre></td></tr></table></figure></li><li><p>这个时候，可以用yum repolist mysql这个命令查看一下是否已经有mysql可安装文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum repolist all | grep mysql</span><br></pre></td></tr></table></figure></li><li><p>安装mysql 服务器命令（一路yes）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install mysql-community-server</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/sql9.png" alt="sql"><br><img src="/aly/sql1.png" alt="sql"><br><img src="/aly/sql1=2.png" alt="sql"></p><ol start="7"><li>安装成功后开启sql（默认没有密码）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ service mysqld start</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/sql3.png" alt="sql"></p><ol start="8"><li>由于mysql刚刚安装完的时候，mysql的root用户的密码默认是空的，所以我们需要及时用mysql的root用户登录（第一次回车键，不用输入密码），并修改密码(注意看我上面的图我是用mysql进来了的)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ update user <span class="built_in">set</span> password=PASSWORD(<span class="string">"这里输入root用户密码"</span>) <span class="built_in">where</span> User=<span class="string">'root'</span>;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/sql4.png" alt="sql"></p><ol start="9"><li><p>查看mysql是否自启动,并且设置开启自启动命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ chkconfig --list | grep mysqld</span><br><span class="line">$ chkconfig mysqld on</span><br></pre></td></tr></table></figure></li><li><p>清除安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rm -rf mysql-community-release-el6-5.noarch.rpm</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/sql12.png" alt="sql"></p><h2 id="案例测试连接数据库"><a href="#案例测试连接数据库" class="headerlink" title="案例测试连接数据库"></a>案例测试连接数据库</h2><ol><li>生产开发环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个mysql的文件夹</span></span><br><span class="line">$ mkdir mysql</span><br><span class="line"><span class="comment"># 进入文件假</span></span><br><span class="line">$ <span class="built_in">cd</span> mysql</span><br><span class="line"><span class="comment">#  初始化项目</span></span><br><span class="line">$ npm init -y</span><br><span class="line"><span class="comment"># 安装mysql依赖包</span></span><br><span class="line">$ npm i mysql</span><br><span class="line"><span class="comment"># 建立一个文件写代码</span></span><br><span class="line">$ touch app.js</span><br><span class="line"><span class="comment"># vim编写app.js</span></span><br><span class="line">$ vim app.js</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/sql6.png" alt="sql"></p><ol start="2"><li>编写app.js<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mysql = <span class="built_in">require</span>(<span class="string">"mysql"</span>);</span><br><span class="line"><span class="keyword">var</span> conn = mysql.createConnection(&#123;</span><br><span class="line">    host:<span class="string">'127.0.0.1'</span>, <span class="comment">// ip</span></span><br><span class="line">    user:<span class="string">'root'</span>, <span class="comment">// 用户名</span></span><br><span class="line">    password:<span class="string">'xxxxx'</span>, <span class="comment">// 密码</span></span><br><span class="line">    database:<span class="string">'test'</span>  <span class="comment">// 数据库名</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">conn.connect(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"连接失败"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"连接成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/sql5.png" alt="sql"></p><ul><li>用node app.js 跑起来<br>看到如图就是正确连接到数据库了<br><img src="/aly/sql7.png" alt="sql"></li></ul><h2 id="设置权限外网连接数据库"><a href="#设置权限外网连接数据库" class="headerlink" title="设置权限外网连接数据库"></a>设置权限外网连接数据库</h2><ol><li>设置权限<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br><span class="line">$ use mysql;</span><br><span class="line">$ Grant all privileges on *.* to <span class="string">'root'</span>@<span class="string">'%'</span> identified by <span class="string">'密码'</span> with grant option;  </span><br><span class="line">$ flush privileges;</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/sql8.png" alt="sql"></p><ol start="2"><li>本地连接测试</li></ol><ul><li>使用navicat mysql<br><img src="/aly/sql10.png" alt="sql"></li><li>点击测试<br><img src="/aly/sql11.png" alt="sql"></li></ul><h2 id="安装后使用命令出现1044报错-处理"><a href="#安装后使用命令出现1044报错-处理" class="headerlink" title="安装后使用命令出现1044报错 处理"></a>安装后使用命令出现1044报错 处理</h2><ol><li><p>停掉数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/mysqld stop</span><br></pre></td></tr></table></figure></li><li><p>进入数据库安全模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mysqld_safe --skip-grant-tables &amp;</span><br></pre></td></tr></table></figure></li><li><p>切入到mysql然后操作修改密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要看见mysql&gt; 才去执行后面的代表已经进入了数据库 (test123哪里是写密码自己喜欢什么写什么)</span></span><br><span class="line">$ use mysql;</span><br><span class="line">$ UPDATE user SET password=password(<span class="string">"test123"</span>) WHERE user=<span class="string">'root'</span>;   </span><br><span class="line">$ flush privileges;</span><br><span class="line">$ <span class="built_in">exit</span>;</span><br></pre></td></tr></table></figure></li><li><p>再次进入测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mysql -uroot -p</span><br><span class="line">$ 输入刚才设置的密码</span><br></pre></td></tr></table></figure></li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>阿里云安装mysql以及连接测试，花了几个小时时间，一开始报错1044弄了好久后来弄好了，测外连接也报错后面也弄好了</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>本地向阿里云服务器传文件/简单的nginx端口代理</title>
    <link href="http://yoursite.com/2019/04/05/%E9%98%BF%E9%87%8C%E4%BA%91zip/"/>
    <id>http://yoursite.com/2019/04/05/阿里云zip/</id>
    <published>2019-04-05T07:32:44.758Z</published>
    <updated>2019-04-05T08:17:07.324Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>既然线上已经可以跑了，那就看看着么把本地的项目放上去跑</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>mac</li><li>已经写好的一个例子</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="使用scp传文件到服务器"><a href="#使用scp传文件到服务器" class="headerlink" title="使用scp传文件到服务器"></a>使用scp传文件到服务器</h2><ul><li>本地做好的一个小案例，linux不支持传文件夹我们只好打包成zip传上去<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp 要传的文件路径 用户@端口号:传到系统的那个位置</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/z1.png" alt="选配"></p><h2 id="安装插件解压zip"><a href="#安装插件解压zip" class="headerlink" title="安装插件解压zip"></a>安装插件解压zip</h2><ul><li>直接这样我们是无法查看zip的</li><li>所以我们只好借助里面的插件来帮助我们<br>Linux(CentOS7)安装zip、unzip命令<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yum install -y unzip zip</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/z2.png" alt="选配"></p><h2 id="解压运行项目"><a href="#解压运行项目" class="headerlink" title="解压运行项目"></a>解压运行项目</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ unzip 要解压的文件</span><br></pre></td></tr></table></figure><p><img src="/aly/z3.png" alt="选配"><br><img src="/aly/z4.png" alt="选配"><br><img src="/aly/z5.png" alt="选配"></p><h2 id="nginx端口代理"><a href="#nginx端口代理" class="headerlink" title="nginx端口代理"></a>nginx端口代理</h2><ul><li>配置文件,添加代理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/n1.png" alt="选配"><br><img src="/aly/n2.png" alt="选配"></p><ul><li>重启nginx服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ /usr/<span class="built_in">local</span>/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/n3.png" alt="选配"><br><img src="/aly/n4.png" alt="选配"></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>阿里云上传文件已经nginx端口代理</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>阿里云 Centos7 node第一个项目</title>
    <link href="http://yoursite.com/2019/04/05/%E9%98%BF%E9%87%8C%E4%BA%91hello/"/>
    <id>http://yoursite.com/2019/04/05/阿里云hello/</id>
    <published>2019-04-05T04:55:22.821Z</published>
    <updated>2019-04-08T08:47:45.519Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>试过很多地方的战部，没有买过阿里腾讯的服务器，今天就想自己买个服务器玩一下</li><li>趁着还是学生可以以学生价格买个便宜一点服务器自己玩一下</li><li>买了下来当然是第一个Hello world那是必须的啦！</li></ul><h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><ul><li>Mac os 系统</li><li>控制台</li><li>阿里云Centos7服务器</li><li>由于我直接买的是应用程序不需要我自己去安装node那我说了</li><li>懂得vim使用，Linux命令</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="购买服务器-（是学生就去把学生认证做了）"><a href="#购买服务器-（是学生就去把学生认证做了）" class="headerlink" title="购买服务器 （是学生就去把学生认证做了）"></a>购买服务器 （是学生就去把学生认证做了）</h2><ul><li><a href="https://promotion.aliyun.com/ntms/act/campus2018.html" target="_blank" rel="noopener">云计划</a><br><img src="/aly/x1.png" alt="选配"></li><li>控制台查看<br><img src="/aly/x2.png" alt="控制台"></li></ul><h2 id="本地连接服务器-激活nvm"><a href="#本地连接服务器-激活nvm" class="headerlink" title="本地连接服务器/激活nvm"></a>本地连接服务器/激活nvm</h2><ol><li>连接服务器</li></ol><ul><li>这个ip号就是公网的ip地址在控制台哪里可以看到的</li><li>ssh 登录用户@ip号<br><img src="/aly/x3.png" alt="连接服务器"></li></ul><ol start="2"><li>激活nvm</li></ol><ul><li>虽然内置已经安装了node等但是一开始是无法使用的<br><img src="/aly/x4.png" alt="vnm未激活"></li><li><p>使用命令激活nvm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">". ~/.nvm/nvm.sh"</span> &gt;&gt; /etc/profile</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure></li><li><p>成功激活<br><img src="/aly/x5.png" alt="激活成功"></p></li></ul><ol start="3"><li>安装全局生成器<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install –g express-generator</span><br></pre></td></tr></table></figure></li></ol><h2 id="vim编写第一个Hello-wrold"><a href="#vim编写第一个Hello-wrold" class="headerlink" title="vim编写第一个Hello wrold"></a>vim编写第一个Hello wrold</h2><ol><li>项目初始化</li></ol><ul><li>本来就是在～了，直接创建一个text文件夹初始化项目<br><img src="/aly/x6.png" alt="文件夹"></li></ul><ol start="2"><li>安装web插件（express）</li></ol><ul><li>为了写起来更加的方便安装的一个web插件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i express</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/x9.png" alt="文件夹"></p><ol start="3"><li>创建文件并编写文件<br><img src="/aly/x7.png" alt="文件夹"></li></ol><ul><li>vim编辑文件<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vim语法</span></span><br><span class="line">i: 写入</span><br><span class="line">esc: 退出编辑</span><br><span class="line">:wq 保存并登录</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">req,res</span>) </span>&#123;</span><br><span class="line"> res.send(<span class="string">'Hello World'</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">'test'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'test2'</span>);</span><br><span class="line">app.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></li></ul><p><img src="/aly/x8.png" alt="文件夹"></p><ol start="4"><li>项目跑起来<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node app.js</span><br></pre></td></tr></table></figure></li></ol><p><img src="/aly/x10.png" alt="文件夹"><br><img src="/aly/x11.png" alt="文件夹"></p><ol start="5"><li>解决无法显示页面</li></ol><ul><li>其实不是页面无法显示是防火墙挡住了</li><li>回到阿里云控制台把端口添加进入，再回来看页面<br><img src="/aly/x12.png" alt="文件夹"><br><img src="/aly/x13.png" alt="文件夹"></li></ul><h2 id="持久化运行项目"><a href="#持久化运行项目" class="headerlink" title="持久化运行项目"></a>持久化运行项目</h2><ul><li>我们虽然是把项目跑起来了但是我们断开连接就无法访问了</li><li>默认我们系统给我们安装了pm2 那就好好的利用<br><img src="/aly/x14.png" alt="文件夹"></li></ul><h2 id="一次可以允许多少个项目？"><a href="#一次可以允许多少个项目？" class="headerlink" title="一次可以允许多少个项目？"></a>一次可以允许多少个项目？</h2><ul><li>其实只要你服务器承受的住开多少个都可以<br><img src="/aly/x15.png" alt="文件夹"></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>阿里云第一个hello项目记录</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="服务器" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
      <category term="服务器" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>Flex 编写100度网页</title>
    <link href="http://yoursite.com/2019/04/03/flex%E5%86%99100%E5%BA%A6/"/>
    <id>http://yoursite.com/2019/04/03/flex写100度/</id>
    <published>2019-04-03T14:22:04.789Z</published>
    <updated>2019-04-03T14:35:31.339Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>最近都没什么时间更新博客</li><li>flex不是很会，特意花了两天时间用flex重写之前写过的一个网页界面</li><li>有利有弊，整体来说还是挺方便的</li></ul><h1 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h1><ul><li><a href="https://gitee.com/yhf7/100duhtml" target="_blank" rel="noopener">码云</a></li></ul><h1 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h1><p><img src="/flex/l1.png" alt="img"><br><img src="/flex/l2.png" alt="img"><br><img src="/flex/l3.png" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Css" scheme="http://yoursite.com/categories/Css/"/>
    
    
      <category term="Css案例" scheme="http://yoursite.com/tags/Css%E6%A1%88%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>mpvue 开发插件</title>
    <link href="http://yoursite.com/2019/03/27/mpvue%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/03/27/mpvue开发插件/</id>
    <published>2019-03-27T11:35:10.359Z</published>
    <updated>2019-03-27T11:48:08.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>刚踏入mpvue这个坑</li><li>有些属性还是和vue不一样的，使用一些插件来方便开发</li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="wxapp-api-interceptors-微信api拦截器-（请求拦截axios）"><a href="#wxapp-api-interceptors-微信api拦截器-（请求拦截axios）" class="headerlink" title="wxapp-api-interceptors 微信api拦截器 （请求拦截axios）"></a>wxapp-api-interceptors 微信api拦截器 （请求拦截axios）</h2><ul><li>这个插件是用来拦截微信的api的使得运用可以像axios一样使用</li><li><a href="https://www.npmjs.com/package/wxapp-api-interceptors" target="_blank" rel="noopener">https://www.npmjs.com/package/wxapp-api-interceptors</a></li></ul><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install wxapp-api-interceptors --save</span><br></pre></td></tr></table></figure></li><li><p>mpvue引用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wxApiInterceptors <span class="keyword">from</span> <span class="string">'wxapp-api-interceptors'</span>;</span><br><span class="line"> </span><br><span class="line">wxApiInterceptors(); <span class="comment">// 必须在调用小程序api之前调用</span></span><br></pre></td></tr></table></figure></li><li><p>设置请求拦截处理(返回拦截也是可以的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wxApiInterceptors(&#123;</span><br><span class="line">    request: &#123;</span><br><span class="line">        request(params) &#123;</span><br><span class="line">            <span class="keyword">const</span> host = <span class="string">'https://test.com'</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="regexp">/^(http|\/\/)/</span>.test(params.url)) &#123;</span><br><span class="line">                params.url = host + params.url;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> params;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="vuex持久化存储"><a href="#vuex持久化存储" class="headerlink" title="vuex持久化存储"></a>vuex持久化存储</h2><ul><li>在项目开发时使用vuex在刷新后是不会存储的</li><li><a href="https://github.com/robinvdvleuten/vuex-persistedstate" target="_blank" rel="noopener">https://github.com/robinvdvleuten/vuex-persistedstate</a></li></ul><ol><li><p>安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save vuex-persistedstate</span><br></pre></td></tr></table></figure></li><li><p>配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Store &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="keyword">import</span> createPersistedState <span class="keyword">from</span> <span class="string">'vuex-persistedstate'</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Cookies <span class="keyword">from</span> <span class="string">'js-cookie'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Store(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  plugins: [</span><br><span class="line">    createPersistedState(&#123;</span><br><span class="line">      storage: &#123;</span><br><span class="line">        getItem: <span class="function"><span class="params">key</span> =&gt;</span> Cookies.get(key),</span><br><span class="line">        <span class="comment">// Please see https://github.com/js-cookie/js-cookie#json, on how to handle JSON.</span></span><br><span class="line">        setItem: <span class="function">(<span class="params">key, value</span>) =&gt;</span></span><br><span class="line">          Cookies.set(key, value, &#123; <span class="attr">expires</span>: <span class="number">3</span>, <span class="attr">secure</span>: <span class="literal">true</span> &#125;),</span><br><span class="line">        removeItem: <span class="function"><span class="params">key</span> =&gt;</span> Cookies.remove(key),</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>mpvue 实现获取用户信息</title>
    <link href="http://yoursite.com/2019/03/21/myvue-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF/"/>
    <id>http://yoursite.com/2019/03/21/myvue-获取用户信息/</id>
    <published>2019-03-21T14:02:08.938Z</published>
    <updated>2019-03-21T14:55:51.804Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>因开发需求，先来躺mpvue这个坑</li><li>首先先从获取用户信息开始吧</li><li>一开始就已经被Eslint掠得体无完肤</li></ul><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>mac os 10.13.3</li><li>vue-cli </li><li>mpvue项目初始化 <a href="https://yhf7.github.io/2018/11/24/%E6%90%AD%E5%BB%BA%E5%B0%8F%E7%A8%8B%E5%BA%8F/" target="_blank" rel="noopener">mpvue搭建</a></li><li>vs code （工具个人喜欢就好）</li><li>熟悉编写vue <a href="https://yhf7.github.io/categories/Vue/" target="_blank" rel="noopener">不懂得可以看看我的这些笔记</a></li><li>熟悉小程序编写</li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/wx.getUserInfo.html?search-key=getUserInfo" target="_blank" rel="noopener">获取用户信息微信官网</a></li></ul><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><ul><li>其实也是很简单的操作，熟悉vue和熟悉小程序的写起来就会比较方便</li><li>绑定按钮使用open-type属性</li><li>我是在src/pages 里面建立了my来编写你们随意</li><li>mpvue和写vue没什么区别,mpvue支持小程序写法</li></ul><hr><ol><li>模版编写</li></ol><ul><li>定义按钮<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个按钮点击拉起授权 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用vue的绑定语法绑定getuserinfo用来接收用户的操作返回值 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义点击用来判断用户版本是否适用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">open-type</span>=<span class="string">"getUserInfo"</span> @<span class="attr">getuserinfo</span>=<span class="string">"bindGetUserInfo"</span> @<span class="attr">click</span>=<span class="string">"getUserInfo1"</span>&gt;</span>获取权限<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 获取用户信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">"getSetting"</span>&gt;</span>获取用户信息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li>编写srcipt</li></ol><ul><li>基本和官网写法可以一直，只是要注意的是绑定方法要使用vue的语法</li><li>注意操作细节<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    <span class="comment">// 编写方法</span></span><br><span class="line">  methods: &#123;</span><br><span class="line">    <span class="comment">/* 判断微信版本是否适用 */</span></span><br><span class="line">    getUserInfo1 () &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'click事件首先触发'</span>)</span><br><span class="line">      <span class="comment">// 判断小程序的API，回调，参数，组件等是否在当前版本可用。  为false 提醒用户升级微信版本</span></span><br><span class="line">      <span class="comment">// console.log(wx.canIUse('button.open-type.getUserInfo'))</span></span><br><span class="line">      <span class="keyword">if</span> (wx.canIUse(<span class="string">'button.open-type.getUserInfo'</span>)) &#123;</span><br><span class="line">        <span class="comment">// 用户版本可用</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'请升级微信版本'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 监听用户点击触发</span></span><br><span class="line">    bindGetUserInfo (e) &#123;</span><br><span class="line">      <span class="comment">// console.log(e.mp.detail.rawData)</span></span><br><span class="line">      <span class="keyword">if</span> (e.mp.detail.rawData) &#123;</span><br><span class="line">        <span class="comment">// 用户按了允许授权按钮</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用户按了允许授权按钮'</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 用户按了拒绝按钮</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'用户按了拒绝按钮'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 获取用户信息</span></span><br><span class="line">    getSetting () &#123;</span><br><span class="line">        <span class="comment">// 拉取信息</span></span><br><span class="line">      wx.getSetting(&#123;</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 判断是否拥有权限</span></span><br><span class="line">          <span class="keyword">if</span> (res.authSetting[<span class="string">'scope.userInfo'</span>]) &#123;</span><br><span class="line">            wx.getUserInfo(&#123;</span><br><span class="line">              success: <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.log(res.userInfo)</span><br><span class="line">                <span class="built_in">console</span>.log(res)</span><br><span class="line">                <span class="comment">// 用户已经授权过</span></span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">'用户已经授权过'</span>)</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'用户还未授权过'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><ul><li>写完代码当然要看看效果的啦</li></ul><ol><li>按钮<br><img src="/xcx/mv1.png" alt="mpvue"></li><li>初次测试小程序默认已经拥有了权限，这时点击是已经授权的<br><img src="/xcx/mv2.png" alt="mpvue"></li><li>点击授权<br><img src="/xcx/mv3.png" alt="mpvue"></li><li>拒绝授权<br><img src="/xcx/mv4.png" alt="mpvue"></li><li>未授权获取用户信息<br><img src="/xcx/mv5.png" alt="mpvue"></li><li>再次触发点击授权，允许后再次获取用户数据<br><img src="/xcx/mv6.png" alt="mpvue"></li></ol><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>从搭建好mpvue到踏入它其实是第二次，但是真正开始写业务还是第一次，这就是我的第一次使用mpvue获取用户信息，写的不好仅供参考，欢迎添加微信qq交流学习</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="小程序" scheme="http://yoursite.com/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="小程序" scheme="http://yoursite.com/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android button点击事件/附加题</title>
    <link href="http://yoursite.com/2019/03/20/%E5%A4%A7%E4%BA%8C%E4%B8%8BAndroid%20%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A/"/>
    <id>http://yoursite.com/2019/03/20/大二下Android 点击事件绑定/</id>
    <published>2019-03-20T12:33:15.822Z</published>
    <updated>2019-03-21T13:31:42.480Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>每一门语音开发的时候都会有点击的业务</li><li>点击按钮弹出什么，点击按钮输出什么</li><li>今天的课程就学了按钮点击绑定</li><li>记录起来</li></ul><h1 id="实现button点击事件的方法"><a href="#实现button点击事件的方法" class="headerlink" title="实现button点击事件的方法"></a>实现button点击事件的方法</h1><ul><li>Button类主要的事件为android：onclick。但也可以通使用了OnclickListener监听器来监听事件，并在onClick()方法中响应。</li><li>实现button点击事件的监听方法有很多种，这里总结了常用的四种方法：<br>　　1、匿名内部类<br>　　2、外部类（独立类）<br>　　3、实现OnClickListener接口<br>　　4、添加XML属性</li></ul><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><ol><li>匿名内部类：<br>　　在Android开发中我们会经常看到各种匿名内部类的使用，那么在实现button点击事件的时候也可以用匿名内部类。<br>　　这样使用的好处是：1）不需要重新写一个类，直接在new的时候去实现想实现的方法，很方便。<br>　　　　　　　　　　　2）当别的地方都用不到这个方法的时候使用匿名内部类<br>　　　　　　　　　　　3）高内聚，高内聚是设计原则之一，匿名内部类的特性之一就是拥有高内聚。<br>　　但是也有不足的地方：1）当别的地方也需要同样的一个方法时还要重新再在那个地方写一次匿名内部类，这样使得代码的冗余性很高。<br>　　　　　　　　　　　　2）不方便后期的维护</li><li><p>独立类（外部类）：<br>　　重新写一个独立的类来实现业务逻辑或是想要的效<br>　　这样写的好处是：1）一定情况下可以方便维护<br>　　　　　　　　　　2）可以降低代码的冗余性，可以同时使用到多个地方<br>　　不足的地方是：1）当只使用一次时浪费资源，程序的性能不高<br>　　　　　　　　　2）当有很多个方法时代码的可读性不高，此时不方便维护</p></li><li><p>实现OnClickListener接口：<br>　　与独立类实现的原理是一样的，优点和缺陷也是大径相同的，实现OnClickListener接口的时候实现它其中的onClick方法</p></li><li><p>添加XML属性：<br>　　我们可以给XML添加一个onClick属性来实现点击事件的监控<br>　　这样的好处是：更加便捷，代码量能够减少<br>　　但是不足的地方是：每一次维护的时候都要去XML里面改源码，很不好维护很麻烦</p></li></ol><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><ol><li>在实现监听的时候都是需要两步走：<br>　　　　1）绑定button按钮 setOnClickListener<br>　　　　2）监听button事件 onclick() </li><li><p>具体使用什么方法去实现button按钮点击事件的监听要看具体的需求，都各有各的好处和不足。<br> 如果只使用一次则推荐使用内部类的方法；<br> 如果多次使用则使用外部类的方法；<br> 实现接口的方法可以在原本的类中实现；<br> 但是在XML里面添加属性的方法时不推荐的，毕竟很不好去维护。</p></li><li><p>内部类的使用在Android开发中是经常用到的，所以非常的重要，</p></li><li><p>Android开发中有很多按钮，但是监听的方法常用的都是这几种</p></li></ol><h1 id="开始写代码"><a href="#开始写代码" class="headerlink" title="开始写代码"></a>开始写代码</h1><ul><li>前面看完长长的笔记现在来敲代码了</li></ul><h3 id="XML属性（监听button事件-onclick（））"><a href="#XML属性（监听button事件-onclick（））" class="headerlink" title="XML属性（监听button事件 onclick（））"></a>XML属性（监听button事件 onclick（））</h3><ul><li>要求：点击按钮控制台输出文字</li><li>页面：线性布局</li><li>一个按钮，一个文本框</li><li>其实很简单就只是两步，定义了然后实例化点击函数就可以了<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">"http://schemas.android.com/apk/res-auto"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">"http://schemas.android.com/tools"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">".Buttom_Demo"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    // 1. 绑定id,指定点击函数名</span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/button01"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">"sss"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"切换"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/text1"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">"adggegege"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.yhf.button_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buttom_Demo</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.buttom__demo);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  2. 实例化点击函数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sss</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"--------------------该按钮是对的控制------------"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnClickListener接口方法"><a href="#OnClickListener接口方法" class="headerlink" title="OnClickListener接口方法"></a>OnClickListener接口方法</h3><ul><li>我们这次就不输出控制台了，我改变文本内容</li><li>这个就比较复杂一点</li><li>纯属定义一个按钮和文本就可以，定义id<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 1. 绑定id,指定点击函数名</span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/button01"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"切换"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/text1"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">"adggegege"</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>接下来就是重点了认真看<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.yhf.button_demo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引包输入组件的时候软件自动导入如果没有自己手打</span></span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4  抽象方法 OnClickListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buttom_Demo</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 声明变量</span></span><br><span class="line">    Button bt1;</span><br><span class="line">    TextView t1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.buttom__demo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 这里是给变量绑定组件</span></span><br><span class="line">        <span class="comment">// 通过id来绑定</span></span><br><span class="line">        bt1 = (Button)findViewById(R.id.button01);</span><br><span class="line">        t1 = (TextView)findViewById(R.id.text1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 设定点击绑定到bt1也就是按钮</span></span><br><span class="line">        <span class="comment">// 使用setOnClickListener绑定</span></span><br><span class="line">        bt1.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 实例化抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        t1.setText(<span class="string">"嘿，你好"</span>);</span><br><span class="line">        t1.setTextColor(Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="拓展题"><a href="#拓展题" class="headerlink" title="拓展题"></a>拓展题</h1><ul><li>按照上面的改成，可以多次点击切换不同的值，不是点了后写死了</li><li>分析一下如何做：我的第一想法是给他一个数组写好很多个文字，每一次切换就获取数组中不同的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.yhf.button_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buttom_Demo</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Button bt1;</span><br><span class="line">    TextView t1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 定义一个i用了判断是数据的第几个</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 2. 数据数组</span></span><br><span class="line">    String[] str = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.buttom__demo);</span><br><span class="line"></span><br><span class="line">        bt1 = (Button)findViewById(R.id.button01);</span><br><span class="line">        t1 = (TextView)findViewById(R.id.text1);</span><br><span class="line"></span><br><span class="line">        bt1.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 3. 判断大于后又回到0继续从0输出，不然超出会报错的</span></span><br><span class="line">        <span class="keyword">if</span> (i&gt;str.length-<span class="number">1</span>) &#123;i=<span class="number">0</span>;&#125;</span><br><span class="line">        <span class="comment">// 4. 输出的时候拿数组的值</span></span><br><span class="line">        t1.setText(str[i]);</span><br><span class="line">        t1.setTextColor(Color.BLUE);</span><br><span class="line">        <span class="comment">// 每点击一次一个数</span></span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="补充其余用法"><a href="#补充其余用法" class="headerlink" title="补充其余用法"></a>补充其余用法</h1><ul><li>还有两种用法就是绑定外部类和内部类</li><li>和拓展题同样的业务，不同的实现方法</li><li>要注意引包</li><li>其实也是挺简单的用法都差不多只是地方不同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.yhf.button_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buttom_Demo</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    Button bt1,bt2;</span></span><br><span class="line"></span><br><span class="line">    Button bt1;</span><br><span class="line">    TextView t1;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    String[] str = &#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.buttom__demo);</span><br><span class="line"></span><br><span class="line">        bt1 = (Button)findViewById(R.id.button01);</span><br><span class="line">        t1 = (TextView)findViewById(R.id.text1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2。 外部类onclik，new 外面的类</span></span><br><span class="line">       bt1.setOnClickListener(<span class="keyword">new</span> listener());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 内部类onclick</span></span><br><span class="line">       bt1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">               System.out.println(<span class="string">"test"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">listener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (i&gt;str.length-<span class="number">1</span>) &#123;i=<span class="number">0</span>;&#125;</span><br><span class="line">            t1.setText(str[i]);</span><br><span class="line">            t1.setTextColor(Color.BLUE);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">### 外部类小案例</span><br><span class="line">- 多按钮绑定同一点击事件，控制id改变文本</span><br><span class="line">- 定义了三个按钮，一个文本框</span><br><span class="line">``` Java</span><br><span class="line"><span class="keyword">package</span> com.example.yhf.button_demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.graphics.Color;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buttom_Demo</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Button bt1,bt2,bt3;</span><br><span class="line">    TextView t1;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.demo);</span><br><span class="line"></span><br><span class="line">        bt1 = (Button)findViewById(R.id.bt1);</span><br><span class="line">        bt2 = (Button)findViewById(R.id.bt2);</span><br><span class="line">        bt3 = (Button)findViewById(R.id.bt3);</span><br><span class="line">        t1 = (TextView)findViewById(R.id.text1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2。 外部类onclik</span></span><br><span class="line">        bt1.setOnClickListener(<span class="keyword">new</span> listener());</span><br><span class="line">        bt2.setOnClickListener(<span class="keyword">new</span> listener());</span><br><span class="line">        bt3.setOnClickListener(<span class="keyword">new</span> listener());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 外部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">listener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 通过判断 引子是getId,点击后会返回一个view的参数</span></span><br><span class="line">            <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">                <span class="keyword">case</span> R.id.bt1: t1.setText(<span class="string">"你爸1"</span>); t1.setTextColor(Color.BLUE); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> R.id.bt2: t1.setText(<span class="string">"你爸2"</span>); t1.setTextColor(Color.RED); <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> R.id.bt3: t1.setText(<span class="string">"你爸3"</span>); t1.setTextColor(Color.YELLOW); <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>今日上课的练习和笔记都记录在这里了，欢迎更多的同行大哥指导交流</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Android 笔记" scheme="http://yoursite.com/tags/Android-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 自学笔记6 范型</title>
    <link href="http://yoursite.com/2019/03/19/TypeScript%E7%AC%94%E8%AE%B06/"/>
    <id>http://yoursite.com/2019/03/19/TypeScript笔记6/</id>
    <published>2019-03-19T15:26:21.365Z</published>
    <updated>2019-03-20T01:07:43.365Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>今日继续学习ts</li><li>等待大哥确认的时间我们继续看看ts范型</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><ul><li>软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。</li><li>在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。</li><li>其实很简单，这就是为了方便复用而设立的，以前在看java的时候对范型就不是学的很好，现在看文档感觉清晰很多了</li><li>那我们继续走入ts，范型</li></ul><h1 id="范型-Hello-World"><a href="#范型-Hello-World" class="headerlink" title="范型-Hello World"></a>范型-Hello World</h1><ul><li><p>下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 echo命令。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个例子建立的是一个参数和返回值为数字类型的</p></li><li>但是我们后续想切换类型着么办？很多人说使用any任意类型啊<br>来看看any</li></ul><hr><ol><li>建立范型<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">arg: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ul><li>确实达到了预期的效果</li><li>但是发现了没有，无论什么类型都可以输入，什么类型的值都可以返回</li><li>这个和之前的js有什么区别，何必还要写呢所以我们需要一个方法去控制住参数和返回值类型相同</li></ul><hr><ul><li>我们给函数添加了一个类型变量T，当我们给这个t赋值了number，他就会自动捕获到，然后赋值到参数和返回值类型当中</li><li>这样到函数叫做范型（官网这么说的）不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="2"><li>使用范型</li></ol><ul><li>第一种是，传入所有的参数，包含类型参数</li><li>第二种方法更普遍。利用了类型推论 – 即编译器会根据传入的参数自动地帮助我们确定T的类型</li><li>这里我们明确的指定了T是string类型，并做为一个参数传给函数，使用了&lt;&gt;括起来而不是()。（重点）<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传入参数</span></span><br><span class="line"><span class="keyword">let</span> output = identity&lt;<span class="built_in">string</span>&gt;(<span class="string">"myString"</span>);  <span class="comment">// type of output will be 'string'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动推断</span></span><br><span class="line"><span class="keyword">let</span> output = identity(<span class="string">"myString"</span>);  <span class="comment">// type of output will be 'string'</span></span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="注意我们没必要使用尖括号（-lt-gt-）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。-类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。（这个要注意）"><a href="#注意我们没必要使用尖括号（-lt-gt-）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。-类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。（这个要注意）" class="headerlink" title="注意我们没必要使用尖括号（&lt;&gt;）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。（这个要注意）"></a>注意我们没必要使用尖括号（&lt;&gt;）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。（这个要注意）</h4><h1 id="使用范型变量"><a href="#使用范型变量" class="headerlink" title="使用范型变量"></a>使用范型变量</h1><ul><li>使用泛型创建像identity这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。</li><li>如果这么做，编译器会报错说我们使用了arg的.length属性，但是没有地方指明arg具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 .length属性的。</li><li><p>所以是错误的不能输出</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Error: T doesn't have .length</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以.length属性是应该存在的。 我们可以像创建其它数组一样创建这个数组</p></li><li>他把参数设立成是一个类型的数组了</li><li>相当于我吧t定义为number</li><li>arg是number类型的数组</li><li>返回值也是一个number的数组</li><li><p>数组是拥有.length的属性的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// number</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = loggingIdentity&lt;<span class="built_in">number</span>&gt;([<span class="number">1</span>,<span class="number">2</span>]);  <span class="comment">// type of output will be 'string'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// String</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T[]</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> output = loggingIdentity&lt;<span class="built_in">String</span>&gt;([<span class="string">"a"</span>]);  <span class="comment">// type of output will be 'string'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(output);</span><br></pre></td></tr></table></figure></li><li><p>你可以这样理解loggingIdentity的类型：泛型函数loggingIdentity，接收类型参数T和参数arg，它是个元素类型是T的数组，并返回元素类型是T的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 T的的类型为number。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。</p></li></ul><p>—————————-</p><ul><li>还有一种写法可以更加规范上面的写法</li><li>在里面在写一次范型，直接定义数组类型<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: <span class="built_in">Array</span>&lt;T&gt;</span>): <span class="title">Array</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Array has a .length, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[ <span class="string">'a'</span> ]</span><br></pre></td></tr></table></figure></li></ul><h1 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h1><ul><li>我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。</li><li>我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &lt;U&gt;<span class="function">(<span class="params">arg: U</span>) =&gt;</span> U = identity;</span><br></pre></td></tr></table></figure></li></ul><h4 id="我们还可以使用带有调用签名的对象字面量来定义泛型函数：（对签名还是带有疑惑）"><a href="#我们还可以使用带有调用签名的对象字面量来定义泛型函数：（对签名还是带有疑惑）" class="headerlink" title="我们还可以使用带有调用签名的对象字面量来定义泛型函数：（对签名还是带有疑惑）"></a>我们还可以使用带有调用签名的对象字面量来定义泛型函数：（对签名还是带有疑惑）</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity;</span><br></pre></td></tr></table></figure><h3 id="第一个范型接口"><a href="#第一个范型接口" class="headerlink" title="第一个范型接口"></a>第一个范型接口</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn &#123;</span><br><span class="line">    &lt;T&gt;(arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn = identity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myIdentity&lt;<span class="built_in">String</span>&gt;(<span class="string">"abc"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(myIdentitys(<span class="string">"cba"</span>));<span class="comment">// 如果写了接口后我们还用这样的类型推断法是不可以的 error</span></span><br></pre></td></tr></table></figure><hr><ul><li>接口变形</li><li>我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 GenericIdentityFn的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。</li><li>很直接的改变就是给接口做了范型，在初始化的时候就要传入类型了</li><li>在使用的时候不再需要去指定范型<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity: GenericIdentityFn&lt;<span class="built_in">number</span>&gt; = identity;</span><br><span class="line"><span class="built_in">console</span>.log(myIdentity(<span class="number">1</span>)); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myIdentity2: GenericIdentityFn&lt;<span class="built_in">string</span>&gt; = identity;</span><br><span class="line"><span class="built_in">console</span>.log(myIdentity2(<span class="string">"abc"</span>); <span class="comment">//abc</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="范型类"><a href="#范型类" class="headerlink" title="范型类"></a>范型类</h1><ul><li>泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。</li><li><p>这个理解起来还是挺好理解的</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myGenericNumber = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">number</span>&gt;();</span><br><span class="line">myGenericNumber.zeroValue = <span class="number">0</span>;</span><br><span class="line">myGenericNumber.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myGenericNumber.add(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure></li><li><p>GenericNumber类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用number类型。 也可以使用字符串或其它更复杂的类型</p></li></ul><hr><ul><li>与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。</li><li>我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stringNumeric = <span class="keyword">new</span> GenericNumber&lt;<span class="built_in">string</span>&gt;();</span><br><span class="line">stringNumeric.zeroValue = <span class="string">""</span>;</span><br><span class="line">stringNumeric.add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(stringNumeric.add(stringNumeric.zeroValue, <span class="string">"test"</span>));</span><br></pre></td></tr></table></figure></li></ul><h1 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h1><p><img src="/TypeScript/T1.png" alt="t1"></p><ul><li>意思就是说使用extends 这个关键字来约束必须每一次都要输入一个带有length的属性，不然就是错的</li><li><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Lengthwise &#123;</span><br><span class="line">    length: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingIdentity</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Lengthwise</span>&gt;(<span class="params">arg: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(arg.length);  <span class="comment">// Now we know it has a .length property, so no more error</span></span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loggingIdentity(<span class="number">3</span>);  <span class="comment">// Error</span></span><br><span class="line">loggingIdentity(&#123;length: <span class="number">10</span>, value: <span class="number">3</span>&#125;); <span class="comment">// 这样才是对的</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="在泛型约束中使用类型参数"><a href="#在泛型约束中使用类型参数" class="headerlink" title="在泛型约束中使用类型参数"></a>在泛型约束中使用类型参数</h3><ul><li>你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。</li><li>编译器运行的时候会报错但是js文件可以运行的，估计是我没有指定类型不过官网也是这样用的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>(<span class="params">obj: T, key: K</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span></span><br><span class="line"><span class="built_in">console</span>.log(getProperty(x, <span class="string">"a"</span>););</span><br></pre></td></tr></table></figure></li></ul><h3 id="在泛型里使用类类型-不是很懂-懂了"><a href="#在泛型里使用类类型-不是很懂-懂了" class="headerlink" title="在泛型里使用类类型 (不是很懂,懂了)"></a>在泛型里使用类类型 (不是很懂,懂了)</h3><ul><li>当我再回头盯上你，你必是我囊中之物</li><li>其实呢我是在实例它的时候不太懂</li><li>经过查阅资料慢慢的弄懂了，要定义一个类把类放进入</li><li><p>在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如，</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里是需要构建一个类 ，函数范型了类， 传入值是类，返回值也是类</span></span><br><span class="line"><span class="comment">// 参数是一个可以new的参数那就是类啦</span></span><br><span class="line">function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个类</span></span><br><span class="line"><span class="keyword">class</span> Student &#123;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写一个方法</span></span><br><span class="line">    say () &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"student say"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化create</span></span><br><span class="line"><span class="comment">// 传入范型值和参数</span></span><br><span class="line"><span class="keyword">let</span> stu = create&lt;Student&gt;(Student)</span><br><span class="line">stu.say()</span><br></pre></td></tr></table></figure></li><li><p>一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。</p></li><li>再去看这个升级例子，需要一定的编程基础</li><li>官网上面的还是自己去构建完整的体系<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> BeeKeeper &#123;</span><br><span class="line">    hasMask: <span class="built_in">boolean</span>;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">hasMask:<span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hasMask = hasMask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> ZooKeeper &#123;</span><br><span class="line">    nametag: <span class="built_in">string</span>;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">nametag: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nametag = nametag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主类</span></span><br><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    numLegs: <span class="built_in">number</span>;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">numLegs: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.numLegs = numLegs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义继承类</span></span><br><span class="line"><span class="keyword">class</span> Bee <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    <span class="comment">// 内部元素声明的是其他的类</span></span><br><span class="line">    keeper: BeeKeeper;</span><br><span class="line">    <span class="comment">// 需要构造函数去实例化</span></span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">this</span>.keeper = <span class="keyword">new</span> BeeKeeper(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Lion <span class="keyword">extends</span> Animal &#123;</span><br><span class="line">    keeper: ZooKeeper;</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">4</span>)</span><br><span class="line">        <span class="keyword">this</span>.keeper = <span class="keyword">new</span> ZooKeeper(<span class="string">"YHF"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A的约束类型是Animal，这里不是继承是约束,需要拥有约束类型的元素，要不自己写要不继承它，这里的操作只是约束不是继承</span></span><br><span class="line">function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(createInstance(Lion).keeper.nametag);  <span class="comment">// YHF</span></span><br><span class="line"><span class="built_in">console</span>.log(createInstance(Bee).keeper.hasMask);   <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(createInstance(Lion).numLegs); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="在泛型里使用类类型-（理解后自定义练习）"><a href="#在泛型里使用类类型-（理解后自定义练习）" class="headerlink" title="在泛型里使用类类型 （理解后自定义练习）"></a>在泛型里使用类类型 （理解后自定义练习）</h1><ul><li>使用类不同的声明类型</li><li>添加判断，深刻理解<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student &#123;</span><br><span class="line">    aa: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">aa: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.aa = aa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Test &#123;</span><br><span class="line">    bb: <span class="built_in">number</span></span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">bb: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.bb = bb</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> cat &#123;</span><br><span class="line">    cc: <span class="built_in">boolean</span></span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">cc: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cc = cc</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A1 <span class="keyword">extends</span> cat &#123;</span><br><span class="line">    dd: Student</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">g : <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g) &#123;</span><br><span class="line">            <span class="keyword">super</span>(g)</span><br><span class="line">            <span class="keyword">this</span>.dd = <span class="keyword">new</span> Student(<span class="string">"YHF"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>(g)</span><br><span class="line">            <span class="keyword">this</span>.dd = <span class="keyword">new</span> Student(<span class="string">"err"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    test (aa: <span class="built_in">string</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="keyword">new</span> Student(aa)</span><br><span class="line">        <span class="keyword">return</span> sum.aa</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> A2 <span class="keyword">extends</span> cat &#123;</span><br><span class="line">    ee: Test</span><br><span class="line">    <span class="keyword">constructor</span> (<span class="params">g : <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (g) &#123;</span><br><span class="line">            <span class="keyword">super</span>(g)</span><br><span class="line">            <span class="keyword">this</span>.ee = <span class="keyword">new</span> Test(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>(g)</span><br><span class="line">            <span class="keyword">this</span>.ee = <span class="keyword">new</span> Test(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function abc&lt;T extends cat&gt;(c: new (g) =&gt; T,g: boolean): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> c(g);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test1 = abc(A1,<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test1.dd.aa) <span class="comment">// YHF</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.cc) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(test1.test(<span class="string">"改变YHF,我叫你爸爸"</span>)); <span class="comment">// 改变YHF,我叫你爸爸</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(abc(A2,<span class="literal">false</span>).ee.bb); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>这个就是我学习Ts的第六天的笔记，欢迎更多的同行大哥指导交流</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript 笔记" scheme="http://yoursite.com/tags/TypeScript-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 自学笔记5 函数</title>
    <link href="http://yoursite.com/2019/03/18/TypeScript%E7%AC%94%E8%AE%B05/"/>
    <id>http://yoursite.com/2019/03/18/TypeScript笔记5/</id>
    <published>2019-03-18T14:12:43.890Z</published>
    <updated>2019-03-18T14:54:15.870Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul><li>时隔多天，今天的需求配色出了点问题等处理，我就又来继续我的Ts之旅</li><li>继续看文档学习Ts直到学完为止</li><li>今天是记录ts的第五天</li><li>今天学习ts的函数，上一次学的是类这一次到函数了</li><li>等到全部过一遍再重新回头看看</li></ul><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>其实简单的来说和js没有什么区别</li><li>没错使用js的这两种监理方式在ts上是可以跑的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myAdd(<span class="number">5</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure></li></ul><h1 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h1><h3 id="为函数定义类型"><a href="#为函数定义类型" class="headerlink" title="为函数定义类型"></a>为函数定义类型</h3><ul><li>这个其实在前面的例子里面已经遇到过了。不过还是要练一下</li><li>升级上一个例子</li><li>写入参数类型和返回类型后还是运行没问题的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>,y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>,<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span> (<span class="params">x: <span class="built_in">number</span>,y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(myAdd(<span class="number">5</span>,<span class="number">6</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="书写完整函数类型"><a href="#书写完整函数类型" class="headerlink" title="书写完整函数类型"></a>书写完整函数类型</h3><ul><li>简单来说就是吧整个函数的参数和返回类型在声明时就指定声明好</li><li>函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型</li><li>参数名称只是为了易读性，名字可以不用一样</li></ul><hr><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数名不同版本</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure><ul><li>当我第一次看到这样写的时候我也是比较疑惑，前面的参数声明我是知道的</li><li>但是那个箭头指向我就不是很懂，大概猜是返回值类型的指定</li><li>不太确定着么办呢？想知道是不是那我改变一下它的属性不就知道了</li><li><p>我就改变了声明为字符串，我们来看看升级版</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">String</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">String</span> </span>&#123; <span class="keyword">return</span> (x + y) &gt; <span class="number">10</span> ? <span class="string">"true"</span> : <span class="string">"false"</span>; &#125;;</span><br><span class="line"><span class="built_in">console</span>.log(myAdd(<span class="number">5</span>,<span class="number">6</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>这样来看我的理解是对的，确实是用了指定返回值类型的</p></li><li>后面看到官网也有写解释</li><li>第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用( =&gt;)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void而不能留空。</li><li>如果使用外部的变量是不用在构建函数的时候声明的</li></ul><h3 id="推断类型"><a href="#推断类型" class="headerlink" title="推断类型"></a>推断类型</h3><ul><li>其实是ts自身的识别</li><li>当你前面声明并赋值的时候，编译器会自动识别出类型意思就是说不写类型也可以</li><li>官网说这叫</li><li>直接上例子一看就懂<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// myAdd has the full function type</span></span><br><span class="line"><span class="keyword">let</span> myAdd = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The parameters `x` and `y` have the type number</span></span><br><span class="line"><span class="keyword">let</span> myAdd: <span class="function">(<span class="params">baseValue: <span class="built_in">number</span>, increment: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> =</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123; <span class="keyword">return</span> x + y; &#125;;</span><br></pre></td></tr></table></figure></li></ul><h1 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h1><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>这个可选类型我们前面也是学过的那看看例子</li><li>其实就是说设定的参数和传入的参数必须一致，对一个不可以少一个不可以</li><li>这个和js不一样，这个写了多少就是多少<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);                  <span class="comment">// error, too few parameters</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h3><ul><li>可选参数呢就是可以输入也可以不输入的</li><li>定义了的可以少写，不传入默认值就是undefined</li><li>当是还是不可以多输入多输入还是会报错的</li><li>假如想前面的这个数为可选参数呢，那就把它放在第二位</li><li>因为可选参数必须跟在必须输入参数的后面，之前我就遇到过这样的错误</li><li>当时还不知道是为什么现在终于明白了<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, lastName?: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lastName)</span><br><span class="line">        <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> firstName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);  <span class="comment">// works correctly now</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);  <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><ul><li>当我们可选参数不输入是默认是undefined</li><li>那我们可以去改变它的默认值，很简单就是在参数后面加入</li><li>传入的是undefined的时候也是会启动这个默认值的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName: string, lastName = "Smith") &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>);                  <span class="comment">// works correctly now, returns "Bob Smith"</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="literal">undefined</span>);       <span class="comment">// still works, also returns "Bob Smith"</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// ah, just right</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>这样看起来 默认参数和可选参数其实是共享的</li><li>默认的参数其实就是可选的参数啊，可选的参数也带有默认参数啊</li><li>这样就可以解决我们想把可选参数放在前面的问题</li><li>我在前面放入默认参数不就是相当于变成了可选参数</li><li>启动的时候输入undefined就可以了</li><li>果然是个很不错的方法，不过既然这样为啥我不直接放在后面呢哈哈哈<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function buildName(firstName = "Will", lastName: string) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">" "</span> + lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = buildName(<span class="string">"Bob"</span>); <span class="comment">// 默认参数位于默认参数前面这样是调用不到默认参数的</span></span><br><span class="line"><span class="keyword">let</span> result2 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>, <span class="string">"Sr."</span>);  <span class="comment">// error, too many parameters</span></span><br><span class="line"><span class="keyword">let</span> result3 = buildName(<span class="string">"Bob"</span>, <span class="string">"Adams"</span>);         <span class="comment">// okay and returns "Bob Adams"</span></span><br><span class="line"><span class="keyword">let</span> result4 = buildName(<span class="literal">undefined</span>, <span class="string">"Adams"</span>);     <span class="comment">// okay and returns "Will Adams"</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h1><ul><li>必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 arguments来访问所有传入的参数。</li><li>在TypeScript里，你可以把所有参数收集到一个变量里</li><li>这个…其实就是es6的语法学过的都应该懂得</li><li><p>然后使用数组方法合并返回，不错的方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> employeeName = buildName(<span class="string">"Joseph"</span>, <span class="string">"Samuel"</span>, <span class="string">"Lucas"</span>, <span class="string">"MacKinzie"</span>);</span><br></pre></td></tr></table></figure></li><li><p>剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ …）后面给定的名字，你可以在函数体内使用这个数组。</p></li></ul><hr><ul><li>官网还给出了函数类型定义时的用法<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildName</span>(<span class="params">firstName: <span class="built_in">string</span>, ...restOfName: <span class="built_in">string</span>[]</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> firstName + <span class="string">" "</span> + restOfName.join(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buildNameFun: <span class="function">(<span class="params">fname: <span class="built_in">string</span>, ...rest: <span class="built_in">string</span>[]</span>) =&gt;</span> <span class="built_in">string</span> = buildName;</span><br></pre></td></tr></table></figure></li></ul><h1 id="This-（重点）"><a href="#This-（重点）" class="headerlink" title="This （重点）"></a>This （重点）</h1><ul><li>学习如何在JavaScript里正确使用this就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清 this工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了 this的地方。（挺认可的）</li></ul><h1 id="this-和尖头函数"><a href="#this-和尖头函数" class="headerlink" title="this 和尖头函数"></a>this 和尖头函数</h1><h3 id="js-this"><a href="#js-this" class="headerlink" title="js this"></a>js this</h3><ul><li>JavaScript里，this的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。</li><li><p>在js里面 this 是一个很麻烦的家伙，没有理解好会引起很多bug</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure></li><li><p>可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有输出结果而是报错了。 因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this视为window。 （注意：在严格模式下， this为undefined而不是window）。</p></li></ul><h3 id="解决上面的问题"><a href="#解决上面的问题" class="headerlink" title="解决上面的问题"></a>解决上面的问题</h3><ul><li>熟悉Es6语法的应该会想到箭头函数，因为箭头函数可以绑定this，而不是使用时的this</li><li>为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的 this值，而不是调用时的值：</li><li>这个真的完美的解决了问题</li><li>其实箭头函数是绑定当时自身最高级的父类为this（个人理解）<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture 'this' right here</span></span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);<span class="comment">// card: 11 of hearts</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>除了es6的箭头函数我们也可以使用bind来绑定this的指向</li><li>现在我们就绑定为deck也就是我们的对象<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> picker =  <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> picker.bind(deck)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure></li></ul><h1 id="this-参数"><a href="#this-参数" class="headerlink" title="this 参数"></a>this 参数</h1><ul><li>不幸的是，this.suits[pickedSuit]的类型依旧为any。 这是因为 this来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 this参数。 this参数是个假的参数，（这个我没有所以看不出是不是）<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// make sure `this` is unusable in this standalone function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些：</li><li>这个例子对于我这个初学者来说有点绕要花点时间理解</li><li>为什么在里面的this指定Deck呢，其实就是这一步指定的声明</li><li>把这个声明放入到函数里面 使得this执行的参数类型被指定<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Card &#123;</span><br><span class="line">    suit: <span class="built_in">string</span>;</span><br><span class="line">    card: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Deck &#123;</span><br><span class="line">    suits: <span class="built_in">string</span>[];</span><br><span class="line">    cards: <span class="built_in">number</span>[];</span><br><span class="line">    createCardPicker(<span class="keyword">this</span>: Deck): <span class="function"><span class="params">()</span> =&gt;</span> Card;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> deck: Deck = &#123;</span><br><span class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</span><br><span class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The function now explicitly specifies that its callee must be of type Deck</span></span><br><span class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">this</span>: Deck</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</span><br><span class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</span><br><span class="line"><span class="keyword">let</span> pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此–noImplicitThis不会报错了。（官网说的我不知道着么去证实）</li></ul><h1 id="this参数在回调函数里-这个有点不太好理解，死磕了好久"><a href="#this参数在回调函数里-这个有点不太好理解，死磕了好久" class="headerlink" title="this参数在回调函数里 (这个有点不太好理解，死磕了好久)"></a>this参数在回调函数里 (这个有点不太好理解，死磕了好久)</h1><ul><li>你可以也看到过在回调函数里的this报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， this将为undefined。 稍做改动，你就可以通过 this参数来避免错误。 首先，库函数的作者要指定 this的类型</li><li><ul><li>这个暂时无法实现的，只是学习原理<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">  addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><ul><li>指定了this类型后，你显式声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到 addClickListener要求函数带有this: void<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> UIElement &#123;</span><br><span class="line">  addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UIElementd的类</span></span><br><span class="line"><span class="keyword">class</span> UIButton <span class="keyword">implements</span> UIElement &#123;</span><br><span class="line">    addClickListener(onclick: <span class="function">(<span class="params"><span class="keyword">this</span>: <span class="built_in">void</span>, e: Event</span>) =&gt;</span> <span class="built_in">void</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> event = <span class="keyword">new</span> Event(<span class="string">"click"</span>, &#123;<span class="string">"bubbles"</span>:<span class="literal">true</span>, <span class="string">"cancelable"</span>:<span class="literal">false</span>&#125;)</span><br><span class="line">        onclick(event)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">    info: <span class="built_in">string</span>;</span><br><span class="line">    onClickBad(<span class="keyword">this</span>: Handler, e: Event) &#123;</span><br><span class="line">        <span class="comment">// oops, used this here. using this callback would crash at runtime</span></span><br><span class="line">        <span class="keyword">this</span>.info = <span class="string">"Bad Clicked"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    onClickGood(<span class="keyword">this</span>:<span class="built_in">void</span>,e:Event) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"Good Clicked"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line"><span class="keyword">let</span> uiElement: UIElement = <span class="keyword">new</span> UIButton();</span><br><span class="line">uiElement.addClickListener(h.onClickGood);</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li>修复错误<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">    info: <span class="built_in">string</span>;</span><br><span class="line">    onClickGood(<span class="keyword">this</span>: <span class="built_in">void</span>, e: Event) &#123;</span><br><span class="line">        <span class="comment">// can't use this here because it's of type void!</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'clicked!'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> h = <span class="keyword">new</span> Handler();</span><br><span class="line">uiElement.addClickListener(h.onClickGood);</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p>因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用 this.info. 如果你两者都想要，你不得不使用箭头函数了：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Handler &#123;</span><br><span class="line">    info: <span class="built_in">string</span>;</span><br><span class="line">    onClickGood = <span class="function">(<span class="params">e: Event</span>) =&gt;</span> &#123; <span class="keyword">this</span>.info = e.message &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这是可行的因为箭头函数不会捕获this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个 Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 Handler的原型链上。 它们在不同 Handler对象间是共享的。</p></li></ul><h1 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h1><ul><li>JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。</li><li>这样的写法在我们平时也是会经常遇到的<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">    <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;, &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;, &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure></li></ul><p>pickCard方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。</p><hr><ul><li>方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 pickCard函数。</li><li>学习多版本的控制<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> suits = [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: &#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;[]</span>): <span class="title">number</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x: <span class="built_in">number</span></span>): </span>&#123;suit: <span class="built_in">string</span>; card: <span class="built_in">number</span>; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickCard</span>(<span class="params">x</span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Check to see if we're working with an object/array</span></span><br><span class="line">    <span class="comment">// if so, they gave us the deck and we'll pick the card</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"object"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * x.length);</span><br><span class="line">        <span class="keyword">return</span> pickedCard;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Otherwise just let them pick the card</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> x == <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(x / <span class="number">13</span>);</span><br><span class="line">        <span class="keyword">return</span> &#123; suit: suits[pickedSuit], card: x % <span class="number">13</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myDeck = [&#123; suit: <span class="string">"diamonds"</span>, card: <span class="number">2</span> &#125;, &#123; suit: <span class="string">"spades"</span>, card: <span class="number">10</span> &#125;, &#123; suit: <span class="string">"hearts"</span>, card: <span class="number">4</span> &#125;];</span><br><span class="line"><span class="keyword">let</span> pickedCard1 = myDeck[pickCard(myDeck)];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard1.card + <span class="string">" of "</span> + pickedCard1.suit);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pickedCard2 = pickCard(<span class="number">15</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"card: "</span> + pickedCard2.card + <span class="string">" of "</span> + pickedCard2.suit);</span><br></pre></td></tr></table></figure></li></ul><p>这样改变后，重载的pickCard函数在调用的时候会进行正确的类型检查。</p><p>为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。</p><p>注意，function pickCard(x): any并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>这个就是我学习Ts的第五天的笔记，欢迎更多的同行大哥指导交流</li><li><a href="https://yhf7.github.io/" target="_blank" rel="noopener">欢迎进入我的博客</a>：<a href="https://yhf7.github.io/" target="_blank" rel="noopener">https://yhf7.github.io/</a></li><li>如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="TypeScript" scheme="http://yoursite.com/categories/TypeScript/"/>
    
    
      <category term="TypeScript 笔记" scheme="http://yoursite.com/tags/TypeScript-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>色表/色彩搭配网址大全</title>
    <link href="http://yoursite.com/2019/03/18/%E9%A2%9C%E8%89%B2%E6%90%9C%E9%9B%86/"/>
    <id>http://yoursite.com/2019/03/18/颜色搜集/</id>
    <published>2019-03-18T03:36:44.470Z</published>
    <updated>2019-03-18T03:39:18.328Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="十六进制色表1-https-blog-csdn-net-jockerscolor-article-details-69255346"><a href="#十六进制色表1-https-blog-csdn-net-jockerscolor-article-details-69255346" class="headerlink" title="十六进制色表1:https://blog.csdn.net/jockerscolor/article/details/69255346"></a><a href="https://blog.csdn.net/jockerscolor/article/details/69255346" target="_blank" rel="noopener">十六进制色表1</a>:<a href="https://blog.csdn.net/jockerscolor/article/details/69255346" target="_blank" rel="noopener">https://blog.csdn.net/jockerscolor/article/details/69255346</a></h2><h2 id="十六进制色表2-https-blog-csdn-net-binglan520-article-details-56288524"><a href="#十六进制色表2-https-blog-csdn-net-binglan520-article-details-56288524" class="headerlink" title="十六进制色表2:https://blog.csdn.net/binglan520/article/details/56288524"></a><a href="https://blog.csdn.net/binglan520/article/details/56288524" target="_blank" rel="noopener">十六进制色表2</a>:<a href="https://blog.csdn.net/binglan520/article/details/56288524" target="_blank" rel="noopener">https://blog.csdn.net/binglan520/article/details/56288524</a></h2><h2 id="十六进制颜色码表图-https-encycolorpedia-cn"><a href="#十六进制颜色码表图-https-encycolorpedia-cn" class="headerlink" title="十六进制颜色码表图:https://encycolorpedia.cn/"></a><a href="https://encycolorpedia.cn/" target="_blank" rel="noopener">十六进制颜色码表图</a>:<a href="https://encycolorpedia.cn/" target="_blank" rel="noopener">https://encycolorpedia.cn/</a></h2><h2 id="颜色渐变-https-uigradients-com-Snapchat"><a href="#颜色渐变-https-uigradients-com-Snapchat" class="headerlink" title="颜色渐变:https://uigradients.com/#Snapchat"></a><a href="https://uigradients.com/#Snapchat" target="_blank" rel="noopener">颜色渐变</a>:<a href="https://uigradients.com/#Snapchat" target="_blank" rel="noopener">https://uigradients.com/#Snapchat</a></h2><h2 id="色彩搭配-https-www-webdesignrankings-com-resources-lolcolors"><a href="#色彩搭配-https-www-webdesignrankings-com-resources-lolcolors" class="headerlink" title="色彩搭配:https://www.webdesignrankings.com/resources/lolcolors/"></a><a href="https://www.webdesignrankings.com/resources/lolcolors/" target="_blank" rel="noopener">色彩搭配</a>:<a href="https://www.webdesignrankings.com/resources/lolcolors/" target="_blank" rel="noopener">https://www.webdesignrankings.com/resources/lolcolors/</a></h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
      <category term="Css" scheme="http://yoursite.com/categories/Css/"/>
    
    
      <category term="色彩搭配" scheme="http://yoursite.com/tags/%E8%89%B2%E5%BD%A9%E6%90%AD%E9%85%8D/"/>
    
  </entry>
  
</feed>
