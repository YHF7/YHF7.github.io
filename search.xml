<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue-cli3 使用svg 方法]]></title>
    <url>%2F2019%2F06%2F09%2Fvue-cli3%E4%BD%BF%E7%94%A8svg%2F</url>
    <content type="text"><![CDATA[前言 写项目遇到使用 svg 很久之前在 html 上用过 在 vue 上使用还是第一次弄了好久，最后找到了两种方法 第一种是官网上的还有一直是基于 webpack 的 svg 好处还是很多的,可随意变更图片颜色 第二种方法封装了使得用起来更加的方便,不过配置的时候稍微有一点点麻烦 工具/资料 系统 macOs 10.13.3 开发工具 vs code 文档 npmjs.com svg: https://www.iconfont.cn/ vue-cli3 项目 webpack 4.0 以上 npm cnpm yarn 其中一种 第一方法插件 vue-svg-loader vue-template-compiler 第二方法插件 svg-sprite-loader 开始1. 第一种方法官网默认（vue-svg-loader） 安装插件（sudo 非苹果系统不需要加） 1$ sudo cnpm i -D vue-svg-loader vue-template-compiler 配置 webpack（vue.config.js） 1234567891011module.exports = &#123; chainWebpack: (config) =&gt; &#123; const svgRule = config.module.rule('svg'); svgRule.uses.clear(); svgRule .use('vue-svg-loader') .loader('vue-svg-loader'); &#125;&#125; 引入 svg 使用(和用组件一样) 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;test /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import test from '../../assets/icons/rightArrow.svg'components: &#123; test &#125;&lt;/script&gt;&lt;style lang="scss" scoped&gt;.arrow_right &#123; @include wh(0.6rem, 0.6rem); path &#123; // 在path改变颜色，通过fill属性 fill: red; &#125;&#125;&lt;/style&gt; 查看效果（这里我写了 css 的） 2. 第二种方法在网上找到的别人封装了的（svg-sprite-loader） 安装插件 1$ sudo cnpm i svg-sprite-loader -S 配置 vue.config.js 123456789101112131415161718192021222324const path = require("path");function resolve(dir) &#123; return path.join(__dirname, dir);&#125;module.exports = &#123; chainWebpack(config) &#123; config.module .rule("svg") .exclude.add(resolve("src/assets/icons")) // icons存放地（svg放的地方） .end(); config.module .rule("icons") .test(/\.svg$/) .include.add(resolve("src/assets/icons")) // icons存放地（svg放的地方） .end() .use("svg-sprite-loader") .loader("svg-sprite-loader") .options(&#123; symbolId: "icon-[name]" &#125;) .end(); &#125;&#125;; 配置封装 svg 组件 在 components 创建组件 （/SvgIcon/index.vue） 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;svg v-else :class="svgClass" aria-hidden="true" v-on="$listeners"&gt; &lt;use :xlink:href="iconName" /&gt; &lt;/svg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'SvgIcon', props: &#123; iconClass: &#123; type: String, required: true &#125;, className: &#123; type: String, default: '' &#125; &#125;, computed: &#123; iconName() &#123; return `#icon-$&#123;this.iconClass&#125;` &#125;, svgClass() &#123; if (this.className) &#123; return 'svg-icon ' + this.className &#125; else &#123; return 'svg-icon' &#125; &#125;, styleExternalIcon() &#123; return &#123; mask: `url($&#123;this.iconClass&#125;) no-repeat 50% 50%`, '-webkit-mask': `url($&#123;this.iconClass&#125;) no-repeat 50% 50%` &#125; &#125; &#125;&#125;&lt;/script&gt; 配置引入组件（icons 目录下建立 index.js 文件） 123456789import Vue from "vue";import SvgIcon from "@/components/SvgIcon"; // svg component// register globallyVue.component("svg-icon", SvgIcon);const req = require.context("./svg", false, /\.svg$/);const requireAll = requireContext =&gt; requireContext.keys().map(requireContext);requireAll(req); 引入 svg 配置文件（main 引入） 1import "@/assets/icons"; 使用 svg (无需引入只需要用 svg-icon 标签即可) 12345678910&lt;template&gt; &lt;svg-icon class="arrow_right" icon-class="rightArrow" /&gt;// 这里icon-class写的就是svg文件的名字&lt;/template&gt;&lt;style lang="scss" scoped&gt;.arrow_right &#123; @include wh(0.6rem, 0.6rem); // 控制大小 fill: red; // 控制颜色 &#125;&lt;/style&gt; 后记 这就是我所使用的两种 svg 的方法，个人感觉第二种用起来更加便捷 欢迎进入我的博客：https://yhf7.github.io/ 或 https://yhf7.top 如果有什么侵权的话，请及时添加小编微信以及 qq 也可以来告诉小编（905477376 微信 qq 通用），谢谢！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录几种js 去重案例]]></title>
    <url>%2F2019%2F05%2F31%2F%E8%AE%B0%E5%BD%95js%E5%A4%9A%E7%A7%8D%E5%8E%BB%E9%87%8D%E5%A4%8D%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言 在编程中去重还是很常见的 最近被一个朋友发来的需求蒙住了，花了很多时间查阅思考解决 可能是我本来实力不强吧 js去重有好几个方法我之前记录过了，这篇只是记录这两个新的案例 如果要看的可以去点击 标签-&gt;Js笔记-&gt;Js回顾 温故知新 可以为师矣 工具/资料 系统 Mac Os 10.13.3 工具 vs code 资料借阅网上的一篇去重案例改成需求 开始1. 数组对象中判断出现重复的子项都清空（重复的子项也清除不保留） 案例 1234567891011121314151617var arr = [&#123; "name": "ZYTX", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "AAAAAA.doc"&#125;, &#123; "name": "ZYTA", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "BBBBBB.doc"&#125;, &#123; "name": "ZDTX", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "CCCCCC.doc"&#125;, &#123; "name": "ZYTX", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "AAAAAA.doc"&#125;]; 需求效果 (重复的都清空) 123456789var arr = [&#123; "name": "ZYTA", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "BBBBBB.doc"&#125;, &#123; "name": "ZDTX", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "CCCCCC.doc"&#125;; 解决思路 先去重复，记录重复子项 提取非重复项输出 编码 1234567891011121314151617181920212223242526272829303132333435363738var arr = [&#123; "name": "ZYTX", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "AAAAAA.doc"&#125;, &#123; "name": "ZYTA", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "BBBBBB.doc"&#125;, &#123; "name": "ZDTX", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "CCCCCC.doc"&#125;, &#123; "name": "ZYTX", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "AAAAAA.doc" &#125;, &#123; "name": "ZYTX", "age": "Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix", "gender": "AAAAAA.doc" &#125;];var hash = &#123;&#125;; // 记载以出现项var min = &#123;&#125;; // 记载重复项// 1. 去重记载（如果单一的去重第二步就不用做了）arr = arr.reduce(function (item, next) &#123; hash[next.name] ? min[next.name] = true : hash[next.name] = true &amp;&amp; item.push(next); return item&#125;, [])// 2. 再次去重（清除之前去重留下的重复项）arr = arr.reduce(function (item, next) &#123; min[next.name] ? '' : min[next.name] = true &amp;&amp; item.push(next); return item&#125;, [])console.log(arr); 运行查看效果 12345678[ &#123; name: 'ZYTA', age: 'Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix', gender: 'BBBBBB.doc' &#125;, &#123; name: 'ZDTX', age: 'Y13xG_4wQnOWK1QwJLgg11d0pS4hewePU95UHtpMl3eE81uS74NC-6zu-Rtnw4Ix', gender: 'CCCCCC.doc' &#125; ] 2. 数组对象中判断相同id中的某一项去重 案例 1var arr = [&#123; id: 1, type: '倒2', name: '广东' &#125;, &#123; id: 1, type: '倒1', name: '广东' &#125;, &#123; id: 1, type: '倒2', name: '广东' &#125;, &#123; id: 1, type: '倒1', name: '广东' &#125;, &#123; id: 2, type: '倒1', name: '广东' &#125;, &#123; id: 2, type: '倒2', name: '广东' &#125;, &#123; id: 2, type: '倒2', name: '广东' &#125;, &#123; id: 2, type: '倒5', name: '广东' &#125;]; 需求效果 (保留单一重复项) 12345[ &#123; id: 1, type: '倒2', name: '广东' &#125;, &#123; id: 1, type: '倒1', name: '广东' &#125;, &#123; id: 2, type: '倒1', name: '广东' &#125;, &#123; id: 2, type: '倒2', name: '广东' &#125;, &#123; id: 2, type: '倒5', name: '广东' &#125; ] 解决思路 提取id，与type子项 这里用了一个小技巧在重复子项上面加上id这样就好判断很多了 编码 12345678910var hash = &#123;&#125;;var min = &#123;&#125;;arr = arr.reduce(function (item, next) &#123; // 记录当id为true 和 子项+id相同才为真 // 这里+id主要是为了好判断 hash[next.id] &amp;&amp; hash[next.type + next.id] == next.type ? "" : (hash[next.id] = true) &amp;&amp; (hash[next.type+next.id] = next.type) &amp;&amp; item.push(next); return item&#125;, [])console.log(arr); 运行查看效果 12345[ &#123; id: 1, type: '倒2', name: '广东' &#125;, &#123; id: 1, type: '倒1', name: '广东' &#125;, &#123; id: 2, type: '倒1', name: '广东' &#125;, &#123; id: 2, type: '倒2', name: '广东' &#125;, &#123; id: 2, type: '倒5', name: '广东' &#125; ] 后记 记录两个去重小案例，吐槽一下这个老哥1w工资真的不知道着么骗回来的，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa 开发插件记录]]></title>
    <url>%2F2019%2F05%2F27%2Fkoa%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 这几天着手使用koa搭建后端服务器 使用的一些插件记录下来以后方便使用 使用 koa的框架所以路由等插件我也不写了 有一些之前express用过的就不写了 工具/资料 开发环境 mac os 10.13.3 node 10 npm 6.4 部署环境 阿里云 Centos 7 64位 参考网址NPM: https://www.npmjs.com/ node 8.0.0 / npm 6.9.0 / cnpm 6.0.0 开始解决跨域问题（koa2-cors） 插件轻松解决跨域问题 1$ cnpm i koa2-cors -S 配置（括号里面的对象可写可不写） 123456789const cors = require('koa2-cors')// 处理跨域问题app.use(cors(&#123; exposeHeaders: ['WWW-Authenticate', 'Server-Authorization', 'Date'], maxAge: 100, credentials: true, allowMethods: ['GET', 'POST', 'OPTIONS'], allowHeaders: ['Content-Type', 'Authorization', 'Accept', 'X-Custom-Header', 'anonymous'],&#125;)); es6转es5 插件加配置解决es6烦恼（node9以上的就没有这个烦恼） 1$ cnpm i babel-plugin-transform-es2015-modules-commonjs babel-register -S 配置(引入插件输出入口文件,新建start.js文件) 12345678require('babel-register') ( &#123; plugins: ['babel-plugin-transform-es2015-modules-commonjs'], &#125; )module.exports = require('./www.js') 改变启动package.json文件 处理原生node还是koa都无法解析request的body（post传值解析） 安装插件 1$ cnpm i koa-body koa-bodyparser -S 配置 123456const koaBody = require('koa-body')const bodyparser = require('koa-bodyparser')app.use(koaBody()).use(bodyparser(&#123; enableTypes:['json', 'form', 'text']&#125;)) 使用 (直接请求request里面的body就可以了，会以json格式输出) 12345router.get('/', async (ctx, next) =&gt; &#123; ctx.body = &#123; "body": ctx.request.body &#125; &#125;) session 数据缓存(mongodb) 安装插件 1$ sudo cnpm i koa-session-minimal koa-mongo-session -S 配置 config/default.js 12345678910111213141516'use strict';module.exports = &#123; // port: normalizePort(process.env.PORT || '3000'), port: parseInt(process.env.PORT, 10) || 3000, url: 'mongodb://localhost:27017/koa-elm', session: &#123; name: 'SID', secret: 'SID', cookie: &#123; httpOnly: true, secure: false, maxAge: 365 * 24 * 60 * 60 * 1000, &#125; &#125;&#125; app.js 12345678910111213141516// 配置文件import config from './config/default'var session = require('koa-session-minimal');var mongoStore = require('koa-mongo-session');app.use(session(&#123; name: config.session.name, secret: config.session.secret, resave: true, saveUninitialized: false, cookie: config.session.cookie, store: mongoStore(&#123; mongo: config.url, expiration: 1000 * 60 * 60 * 24 * 14 &#125;) &#125;)) 使用1234router.get('/', async (ctx, next) =&gt; &#123; console.log(ctx.session.admin_id) // 取 ctx.session.admin_id = '2' // 存 &#125;)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[koa 快速形成开发环境(koa-generator)]]></title>
    <url>%2F2019%2F05%2F24%2Fkoa%E5%BF%AB%E9%80%9F%E5%BD%A2%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言 写过node的人都知道，express这个轻量级web框架 但是koa是express原班人马打造，更轻量更容易拓展的流行框架 集成了一些 express 风格的中间件，不需要手动去写，省时省力 支持es6，7语法等 如何快速搭建开发环境呢？ vue有vue-cli ，koa也有koa-generator脚手架 我是mac 所以每次都加sudo 这个权限问题 win不用加 工具/资料 系统 Mac Os 10.13.3 npm 6.4.1 node 10.13.0 开始1. 全局安装脚手架 npm cnpm yarn都可以1$ sudo cnpm i -g koa-generator 2. 搭建项目 由于koa有两个版本所以生成的用法也不一样的,同样我们生成个项目明叫koaPro的看看(这里我直接连写了)koa v1 开启命令：1$ sudo koa koaPro &amp;&amp; cd koaPro &amp;&amp; sudo cnpm i koa v2 开启命令：1$ sudo koa2 koaPro &amp;&amp; cd koaPro &amp;&amp; sudo cnpm i 3. 启动koa 默认3000端口1$ sudo npm run start 后记 koa 快速开启项目就说到这了，这几天会使用koa搭后端服务，欢迎业界大佬交流学习 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 阻止浏览器点击回退]]></title>
    <url>%2F2019%2F05%2F19%2Fvue%E9%98%BB%E6%AD%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%9B%9E%E9%80%80%2F</url>
    <content type="text"><![CDATA[前言 在我们的开发过程中有时候一些页面并不喜欢被回退 也不希望被退出去其他页面，比如登录了等就不给回退到登录页面等 这时候我们应该着么做呢？第一时间我想起了路由守护 每一次的切换都会进入到路由，但是具体着么做呢？我也借鉴了网上别人的方法 现在实现了我把它记录下来 工具/资料 系统 Mac os 10.13.3 开发工具 vs code 开发项目 vue 开始第一步、锁定需要禁止回退的路由页面 给需要守护的路由在 meta 添加 allowBack 只要你那个页面不想让他回退了那你就添加就可以了 12345678910const Login = ()=&gt; import( /* webpackChunkName: "login-page" */ '@/pages/Login')//登录export default [ &#123; path: '/', name: 'Login', component: Login, meta: &#123; allowBack: false &#125; &#125;] 第二步、配置全局路由守护123456789101112131415161718192021// 全局路由守护router.beforeEach((to,from,next) =&gt; &#123; let allowBack = true // 给个默认值true // 有定义的就走路由定义了的数据 if (to.meta.allowBack !== undefined) &#123; allowBack = to.meta.allowBack &#125; if (!allowBack) &#123; history.pushState(null, null, location.href) &#125; // vuex存储数据 store.dispatch('updateAppSetting', &#123; // updateAppSetting 只是store里面的一个action， 用来改变store里的allowBack的值的，具体怎么改这个值 要根据各位的实际情况而定 allowBack: allowBack &#125;) // 登录守护 if (to.name != 'Login' &amp;&amp; (vuex.getters.getLoginKey()) != 'yhfkey') &#123; next(&#123;name: 'Login'&#125;) &#125; next()&#125;) 第三步、编写 vuex1234567891011121314151617181920212223242526import Vue from 'vue'import Vuex from 'vuex'Vue.use(Vuex)const state = &#123;&#125;// mutationsconst mutations = &#123; updateAppSetting(state,status) &#123; state.allowBack = status.allowBack &#125;&#125;// actionsconst actions = &#123; updateAppSetting(&#123;commit&#125;, status)&#123; commit('updateAppSetting', status) &#125;&#125;export default new Vuex.Store(&#123; state, mutations, actions&#125;) 第四步、在 App.vue 编写最后的守护 在 app 的 mouted 编写 onpopstate 12345678mounted() &#123; window.onpopstate = () =&gt; &#123; if (!this.allowBack) &#123; // 这个allowBack 是存在vuex里面的变量 history.go(1); &#125; &#125;;&#125; 后记 全局路由守护拒绝浏览器回退就说到这里了，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年5月开发心得]]></title>
    <url>%2F2019%2F05%2F14%2F2019-05-14%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[近期开发汇总最近都是在写程序测试程序修复bug，在不断的写代码的过程中确实慢慢的成长起来了，遇到了很多让我很苦恼的问题随着时间的流逝搜索引擎的强大朋友的经验，都能把问题迎刃而解，项目重构结束测试也接近尾声了，项目交付当被用户发现bug发来一声声质疑时，我真的无地自容作为一个第一次跟着团队做项目，真正的让用户使用自己的产品，当我看到别人对我的质疑时我是非常的愤怒，不是愤怒别人是愤怒自己为什么那么疏忽，为什么没有认真的检查好为什么为出现这样的错误，一声声的为什么映入我的心中，当我收到这一份质疑时我感到非常的耻辱并不是实力不过关完全就是态度的问题，没有很细心很认真的去测试遗留残缺bug流入客户手中，感动非常的抱歉！自我检讨自我反省以后不再出现这样的事情，这种感觉真的非常不爽！还好有那么包容的团队，出现问题都没有责怪我也只是说大家都疏忽了尽快解决就好，团队大哥也安慰我习惯就会这样的事常有发生的，不辜负大家的期望得继续努力！ 今日总结今天很开心也很伤心，在编写投票系统时，我的服务器和数据库出问题了，迫不得已重置数据库最后数据库的数据都没了得重新搭起来，服务器也受到了代理地址影响起了一些错误，通过2小时的奋斗终于解决了这个问题，另外很开心的是仿写elm后台系统，投票系统，签到系统今天都完成了，当我正开心的时候又发现了bug，一天天的就不让我好过啊，这不是我应该承受的一天哎，作为一个开发人员只能默默的接受这一切那就去修复bug以免又被一声声的质疑，当我觉得我的服务器可能不行时今晚给了我很大的惊喜，同时间几百人使用我的小程序测试我的投票系统，服务器显示还是可以的，虽然高峰期还是有点压力起码没有崩溃还是很棒棒的，这是我第一次向那么多人展示我的作品，虽然很简易，但是我很开心大家都愿意点开为我投一票测试一下，最后是有接近1000人访问了我的程序，我已经很满足了 后续计划 优化签到程序 完成elm 后端编写 重构签到程序后台 坚持阅读JavaScript高级程序设计3 注意身体健康，不熬夜，中午午休（尽力完成这个比看书还难的任务）]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现简易 投票系统 （小程序+Tp5+vue）]]></title>
    <url>%2F2019%2F05%2F14%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2Btp5%2Bvue%2F</url>
    <content type="text"><![CDATA[前言 好久没有更新博客 一直忙于项目测试修复bug 今日收到我哥的需求，想做一个现场投票系统 我就想着做个简单的小程序再用vue配合插件做个实时图标就可以了 在这期间真的是一波三折啊，数据库报错被迫重置，服务器出问题，还好都解决了 废话不多说进入今天的简易投票系统 工具/材料 开发系统 Mac OS 10.13.3 开发工具 Vs code 、phpStorm、MySQL、Postman、微信开发者工具 线上系统 阿里云 Centos 7 64位 线上 apache环境 php 、mysql环境搭建 nginx反向代理 https 域名以及备案 Vue-cli 、 Tp5 图标插件 echarts https://echarts.baidu.com/examples/ 源码 https://gitee.com/yhf7 开始TP5编写后端api （没啥说的直接下源码看源码：）业务 编写token、验证token 验证是否投票，投票 使用tp5做了什么 验证数据层 模型操作数据库 业务逻辑层 全局异常处理机制 挂载后台页面 数据存储 小程序 简单的单选以及api请求 页面 api请求封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 请求封装 * 当 noRefech 为 true， 不做未授权重做机制 */ request (params,noRefetch) &#123; var that = this; // url内外拼接 var url = this.baseRequestUrl + params.url; if (!params.type) &#123; params.type = 'GET' &#125; wx.request(&#123; url: url, data: params.data, method: params.type, header: &#123; 'content-type':'application/json', 'token': wx.getStorageSync('token') &#125;, success: res =&gt; &#123; var code = res.statusCode.toString(); var startChar = code.charAt(0); if (startChar == '2') &#123; // 判断函数，存在才调用 params.sCallback &amp;&amp; params.sCallback(res.data); &#125; else &#123; // AOP // 401 无token，重新调用 if (code == '401') &#123; // 避免无限循环，默认false进入，第二次调用时返回ture就不会再次去调用死循环 if (!noRefetch) &#123; that._refetch(params); &#125; &#125; if (noRefetch) &#123; params.eCallback &amp;&amp; params.eCallback(res.data); &#125; &#125; &#125;, fail: err =&gt; &#123; console.log(err); &#125; &#125;) &#125; api调用以及单选业务处理 vue后台 就是简单的图标实时获取投票数据 安装插件 1$ sudo cnpm i echarts -S 页面源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;template&gt; &lt;div class="visitorpie"&gt; &lt;div id="visitorpie" class style="width: 90%;height:450px;"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var echarts = require('echarts');import API from '@/api'export default &#123; mounted() &#123; this.myChart = echarts.init(document.getElementById("visitorpie")); this.initData(); setInterval(() =&gt; &#123; API.geDate().then(res =&gt; &#123; let arr = [] for (const key in res) &#123; arr.push(res[key]); &#125; this.initData(arr) &#125;) &#125;, 3000); &#125;, methods: &#123; initData(arr) &#123; var option = &#123; title: &#123; text: '第八届广东文艺职业学院美术系班服大赛最佳人气榜' &#125;, tooltip: &#123;&#125;, legend: &#123; data:['票数'] &#125;, xAxis: &#123; data: ["18会展班","18工艺班","18计美1班","18计美2班","18配饰班","18陶艺班"] &#125;, yAxis: &#123;&#125;, series: [&#123; name: '票数', type: 'bar', data: arr &#125;] &#125;; this.myChart.setOption(option); &#125; &#125;&#125;;&lt;/script&gt;&lt;style lang="less"&gt;@import "../assets/styles/mixin.less";.visitorpie &#123; .fj("centeer"); margin-top: 20px;&#125;&lt;/style&gt; 效果图 打包放在tp5的public里面即可服务器/小程序后台数据效果图 后记 这就是我帮我哥做的简易实时投票系统，望大家多多指教 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>全栈案例</category>
      </categories>
      <tags>
        <tag>全栈案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code 远程管理Linux文件（Remote Development）]]></title>
    <url>%2F2019%2F05%2F04%2FVS%20Code%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E8%BF%9C%E7%AB%AF%E6%96%87%E4%BB%B6%E5%A4%B9%2F</url>
    <content type="text"><![CDATA[前言 老实说我个人比较喜欢命令行多过界面化，所以我购买的服务器是CentOS7真的纯命令行 我也只是用了部署项目也没有说在上面开发，有时候使用vim小改一下 但是频繁大量的改就觉得第一个麻烦切来切去，第二个就是用起来真的没有那么方便 刚好看见vscode出了这么个插件 这个插件分为两个的 Remote Development 和 Remote VS Code （两个我都下了第二个没有第一个那么方便） 那我们就来走入远端控制的配置与享受中 工具 系统 Mac Os 10.13.3 服务器 CentOS 7 （阿里云学生机买的） 软件 VS Code insiders 这个正式版有没有具体我不清楚，Remote vs code这个是肯定都有的 开始第一步、安装插件1$ Remote Development # (插件名称) 第二步、配置插件1234567# Read more about SSH config files: https://linux.die.net/man/5/ssh_configHost Cenos7 HostName 119.23.75.150 # 要连接服务器的地址 User root # 连接服务器的名称 ForwardAgent yes RemoteForward 52698 127.0.0.1:52698 # 前面的是远端的端口 后面的是本地的，设置防火墙的要给端口权限 IdentityFile /Users/yhf/yhf.pem # 密钥没有可以不写 第三步、配置服务器(Linux)重点：安装配置好重启一下vs code 12345$ wget https://raw.githubusercontent.com/sclukey/rmate-python/master/bin/rmate$ chmod +x ./rmate$ mv ./rmate /usr/local/bin/rmate 第四步、启动连接 这个过程中会需要多次输入密码的 后面选择自己需要编辑的文件夹或文件 第五步、编辑查看效果 后记 vs code 管理远端文件就说到这了,整体来说还是不错的，就是密码输的有点多，希望能帮到有缘人 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>插件</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云 Centos 7 安装/配置 Nginx https]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEnginx%2F</url>
    <content type="text"><![CDATA[前言 前段时间配置了php环境的https，但是我的服务器不只是有php还有其他的后端 所以只好用nginx做一个全局的配置，而且配置的时候一直出问题 一开始我也是被多个代理卡了好久，事实证明nginx配置比单个配置方便很多的，因为Apache只可以给php等使用，但是如果我要给个node那就不行了 今天花了点时间把之前的删除了重新安装配置 不看我的看官网也是可以的：点击前往 注意 如果你安装了的，可以选择清空再安装配置 如果配置了其他的https请关闭，我就是配置了apache的https所以关闭了 我这里是做了端口重定向，100端口是我Apache php的应用你们按需配置就好 关闭Apache 的方法是找到配置https 和ssl文件把443端口关闭，和80端口重定向关闭了 密钥放在nginx文件夹下的cert文件下自己创建的，这个如果不会看我之前php配置的那个php配置https 开始查看并清除nginx （未安装的不需要看） 查看安装1$ rpm -ql nginx 清除nginx1$ yum remove nginx 安装1$ yum -y install nginx 配置 https (证书自己下不会的找我之前的php配置的去看,如果像我一样配置了apache的https的请自行关闭)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768$ vim /etc/nginx/nginx.conf------------http &#123; log_format main '$remote_addr - $remote_user [$time_local] "$request" ' '$status $body_bytes_sent "$http_referer" ' '"$http_user_agent" "$http_x_forwarded_for"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; include /etc/nginx/conf.d/*.conf;# 多端口使用https 代理8888 挂载nodeserver &#123; listen 8888 ssl; server_name yhf7.top; # 域名 ssl on; root html; index index.html index.htm; ssl_certificate "cert/yhf7.top.pem"; # 密钥 ssl_certificate_key "cert/yhf7.top.key";# 密钥 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;# 加密 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; proxy_pass http://yhf7.top:3000; # 端口默认指向地 &#125;&#125;# https 配置 80 443 server &#123; listen 80; listen 443 ssl; server_name yhf7.top; # 域名 ssl on; root html; index index.html index.htm; ssl_certificate "cert/yhf7.top.pem"; # 密钥 ssl_certificate_key "cert/yhf7.top.key";# 密钥 ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;# 加密 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; ssl_prefer_server_ciphers on; location / &#123; root html; index index.html index.htm; proxy_pass http://yhf7.top:100; # 端口默认指向地 &#125; &#125;&#125; nginx重定向apache的应用 （Apache的默认80端口必须改变不然就和nginx冲突了） 由于前面配置了默认进入，所以改变端口 就可以了1$ vim /etc/httpd/conf/httpd.conf 查看效果123$ nginx 开启$ nginx -s reload 重启$ nginx -s stop 关闭 预防不会关闭Apache https 关闭httpd重定向1$ vim /etc/httpd/conf/httpd.conf 关闭httpd ssl 端口 1$ vim /etc/httpd/conf.d/ssl.conf 重启httpd 后记 这就是我踩很多坑最后配置出来的笔记，希望能帮到有缘人，欢迎同行加微信交流学习！ 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>反向代理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli3 部局多页面开发/模块化]]></title>
    <url>%2F2019%2F04%2F26%2Fvue-cli3-%E5%A4%9A%E9%A1%B5%E9%9D%A2%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前言 vue我们众所周知的是单页面开发，那么我们想把它多页面化模块化呢 那该如何来个改才能达到多页面多模块的效果呢 如何可以模块之间无关联无污染呢 为什么要这样去写呢？有什么好处呢？ 第一、一个项目中有两端同的业务可以很好的区分两个项目之间无污染无关联 第二、公共资源共享公共组件视图多项目共用 第三、打包方便一次打包就可以了不需要分开多次去打包配置也只是需要配置一次 那我们就来走入vue多页面开发系列吧跟着我一步一步的配置多页面 开始 先看一下目录图 配置 文件的创建那些就不多说了不懂你私我好吧 直接配置一目了然12345678910111213141516171819202122module.exports = &#123; pages: &#123; main: &#123; entry: 'src/module/index/main.js', // 模块加载文件 // 模板来源 template: 'public/index.html',// 模块入口文件, 默认进入文件（因为是放在根目录所以就会默认进入，如果不想可以改其他） filename: 'index.html', // 当使用 title 选项时， // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; title: '' &#125;, login: &#123; entry: 'src/module/login/main.js', // 第二个页面的模版加载文件地址 // 模板来源 template: 'public/login/index.html', // 入口文件 filename: 'login/index.html', // 当使用 title 选项时， // template 中的 title 标签需要是 &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; title: '' &#125; &#125;&#125; 查看结果 注意： 不是默认进入必须和我那样写，你也可以不需要默认进入，可以改成和login那样也是可以的只是改一下入口文件，吧index.html和login一样放到文件夹里面就可以了后记 这就是vue多页面开发，是不是觉得很简单啊 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记9 高级类型]]></title>
    <url>%2F2019%2F04%2F25%2FTypeScript%E7%AC%94%E8%AE%B09%2F</url>
    <content type="text"><![CDATA[前言 断断续续还是不忘想把ts学习完 终于忙完可以继续学习了 今天学习高级类型 高级类型交叉类型（Intersection Types） 简单的说就是把多个类中的所以方法和变量都集中在一个类型里面 交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 例如， Person &amp; Serializable &amp; Loggable同时是 Person 和 Serializable 和 Loggable。 就是说这个类型的对象同时拥有了这三种类型的成员。 我们大多是在混入（mixins）或其它不适合典型面向对象模型的地方看到交叉类型的使用。 （在JavaScript里发生这种情况的场合很多！） 下面是如何创建混入的一个简单例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 交叉类型函数/** * @param * T、U 两个都是外传的方法（ts函数自检测类型） * */function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123; // 创建这两个类型合集的对象 let result = &lt;T &amp; U&gt;&#123;&#125;; // 遍历把数据存储到新的对象中 for (let id in first) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; &#125; // 输出查看 console.log(result) //1 // 遍历第二个参赛 for (let id in second) &#123; if (!result.hasOwnProperty(id)) &#123; (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; &#125; &#125; console.log(result)//2 // 返回 return result;&#125;// 定义一个类，实现构造函数和一个方法class Person &#123; constructor(public name: string) &#123; &#125; test() &#123; // ... console.log('hello, '+this.name) //5 &#125;&#125;// 抽象类interface Loggable &#123; log(): void;&#125;// 实现抽象类class ConsoleLogger implements Loggable &#123; log() &#123; // ... console.log('你好') //4 &#125;&#125;// 这里调用extend函数传入两个不同的类型，一个是类，一个是抽象类var jim = extend(new Person("Jim"), new ConsoleLogger());// 接受namevar n = jim.name;console.log(n) //3// 调用方法jim.log();jim.test();// 最后输出的值(后面的号码对应上面的log)// &#123; name: 'Jim', test: [Function] &#125; //1// &#123; name: 'Jim', test: [Function], log: [Function] &#125;//2// Jim //3// 你好 //4// hello, Jim //5 联合类型（Union Types） 这个理解起来不难，其实就是说通过数字或字符串的判断来区分判断修改 联合类型与交叉类型很有关联，但是使用上却完全不同。 偶尔你会遇到这种情况，一个代码库希望传入 number或 string类型的参数。 例如下面的函数：12345678910111213141516171819202122/** * 模仿联合类型 * @param * value &#123;string&#125; 字符串 * padding &#123;any&#125; 任意类型 * */function padLeft(value: string, padding: any) &#123; // 判断是数字类型在前面加数字多个空格 if (typeof padding === "number") &#123; return Array(padding + 1).join(" ") + value; &#125; // 如果是字符串就直接加在前面 if (typeof padding === "string") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125;// 数字padLeft("Hello world", 4); // returns " Hello world"// 字符串padLeft("Hello world", "4"); // returns "4Hello world" padLeft存在一个问题， padding参数的类型指定成了 any。 这就是说我们可以传入一个既不是 number也不是 string类型的参数，但是TypeScript却不报错。 let indentedString = padLeft(“Hello world”, true); // 编译阶段通过，运行时报错 这时候联合类型就派上用场了,代替any从源头上解决问题 （并不是只有string和number，boolean等也是可以使用的）12345function padLeft(value: string, padding: string | number) &#123; // ...&#125;let indentedString = padLeft("Hello world", true);// errors during compilation 如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员。 这个在前面一章算数哪里已经验证过了 这里的联合类型可能有点复杂，但是你很容易就习惯了。 如果一个值的类型是 A | B，我们能够 确定的是它包含了 A 和 B中共有的成员。 这个例子里， Bird具有一个 fly成员。 我们不能确定一个 Bird | Fish类型的变量是否有 fly方法。 如果变量在运行时是 Fish类型，那么调用 pet.fly()就出错了。12345678910111213141516171819202122232425262728293031323334353637383940interface Bird &#123; fly(); layEggs();&#125;interface Fish &#123; swim(); layEggs();&#125;class Bird1 implements Bird &#123; fly() &#123; console.log('fly') &#125; layEggs() &#123; console.log('layEggs') &#125;&#125;class Fish1 implements Fish &#123; swim() &#123; console.log('swim') &#125; layEggs() &#123; console.log('layEggs') &#125;&#125;function getSmallPet(): Fish | Bird &#123; if (Math.random() &gt; 0.5) &#123; return new Fish1() &#125; else &#123; return new Bird1() &#125;&#125;let pet = getSmallPet();pet.layEggs(); // layEggspet.swim(); // errors 类型保护与区分类型（Type Guards and Differentiating Types） 联合类型适合于那些值可以为不同类型的情况。 但当我们想确切地了解是否为 Fish时怎么办？ JavaScript里常用来区分2个可能值的方法是检查成员是否存在。 如之前提及的，我们只能访问联合类型中共同拥有的成员。12345678910111213141516171819202122232425let pet = getSmallPet();// 每一个成员访问都会报错if (pet.swim) &#123; pet.swim();&#125;else if (pet.fly) &#123; pet.fly();&#125;// 正确解法if ((&lt;Fish&gt;pet).swim) &#123; (&lt;Fish&gt;pet).swim();&#125;else &#123; (&lt;Bird&gt;pet).fly();&#125;// 联合上面的代码一起执行，输出的结果会有两种情况（随机的）//1 layEggsswim//2layEggsfly 用户自定义的类型保护 这里可以注意到我们不得不多次使用类型断言。 假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet的类型的话就好了。 TypeScript里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词： 123function isFish(pet: Fish | Bird): pet is Fish &#123; return (&lt;Fish&gt;pet).swim !== undefined;&#125; 每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。 12345678// 'swim' 和 'fly' 调用都没有问题了if (isFish(pet)) &#123; pet.swim();&#125;else &#123; pet.fly();&#125; 注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型 typeof类型保护 现在我们回过头来看看怎么使用联合类型书写 padLeft代码。 我们可以像下面这样利用类型断言来写： 然而，必须要定义一个函数来判断类型是否是原始类型，这太痛苦了。 幸运的是，现在我们不必将 typeof x === “number”抽象成一个函数，因为TypeScript可以将它识别为一个类型保护。 也就是说我们可以直接在代码里检查类型了。 1234567891011121314151617function isNumber(x: any): x is number &#123; return typeof x === "number";&#125;function isString(x: any): x is string &#123; return typeof x === "string";&#125;function padLeft(value: string, padding: string | number) &#123; if (isNumber(padding)) &#123; return Array(padding + 1).join(" ") + value; &#125; if (isString(padding)) &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; 这些 typeof类型保护只有两种形式能被识别： typeof v === “typename”和 typeof v !== “typename”， “typename”必须是 “number”， “string”， “boolean”或 “symbol”。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。123456789function padLeft(value: string, padding: string | number) &#123; if (typeof padding === "number") &#123; return Array(padding + 1).join(" ") + value; &#125; if (typeof padding === "string") &#123; return padding + value; &#125; throw new Error(`Expected string or number, got '$&#123;padding&#125;'.`);&#125; instanceof类型保护 如果你已经阅读了 typeof类型保护并且对JavaScript里的 instanceof操作符熟悉的话，你可能已经猜到了这节要讲的内容。 instanceof类型保护是通过构造函数来细化类型的一种方式。 比如，我们借鉴一下之前字符串填充的例子： 123456789101112131415161718192021222324252627282930313233interface Padder &#123; getPaddingString(): string&#125;class SpaceRepeatingPadder implements Padder &#123; constructor(private numSpaces: number) &#123; &#125; getPaddingString() &#123; return Array(this.numSpaces + 1).join(" "); &#125;&#125;class StringPadder implements Padder &#123; constructor(private value: string) &#123; &#125; getPaddingString() &#123; return this.value; &#125;&#125;function getRandomPadder() &#123; return Math.random() &lt; 0.5 ? new SpaceRepeatingPadder(4) : new StringPadder(" ");&#125;// 类型为SpaceRepeatingPadder | StringPadderlet padder: Padder = getRandomPadder();if (padder instanceof SpaceRepeatingPadder) &#123; padder; // 类型细化为'SpaceRepeatingPadder'&#125;if (padder instanceof StringPadder) &#123; padder; // 类型细化为'StringPadder'&#125; instanceof的右侧要求是一个构造函数，TypeScript将细化为： 此构造函数的 prototype属性的类型，如果它的类型不为 any的话 构造签名所返回的类型的联合 可以为null的类型 TypeScript具有两种特殊的类型， null和 undefined，它们分别具有值null和undefined. 我们在基础类型一节里已经做过简要说明。 默认情况下，类型检查器认为 null与 undefined可以赋值给任何类型。 null与 undefined是所有其它类型的一个有效值。 这也意味着，你阻止不了将它们赋值给其它类型，就算是你想要阻止这种情况也不行。 null的发明者，Tony Hoare，称它为 价值亿万美金的错误。 –strictNullChecks标记可以解决此错误：当你声明一个变量时，它不会自动地包含 null或 undefined。 你可以使用联合类型明确的包含它们： 当是我们自己去赋值的时候其实都是可以的并没有报错 123456let s = "foo";s = null; // 错误, 'null'不能赋值给'string'let sn: string | null = "bar";sn = null; // 可以sn = undefined; // error, 'undefined'不能赋值给'string | null' 注意，按照JavaScript的语义，TypeScript会把 null和 undefined区别对待。 string | null， string | undefined和 string | undefined | null是不同的类型。 可选参数和可选属性 使用了 –strictNullChecks，可选参数会被自动地加上 | undefined: 然而这个也是无报错的12345678910111213141516171819function f(x: number, y?: number) &#123; return x + (y || 0);&#125;f(1, 2);f(1);f(1, undefined);f(1, null); // error, 'null' is not assignable to 'number | undefined'// 类的也是一样没有报错正常执行class C &#123; a: number; b?: number;&#125;let c = new C();c.a = 12;c.a = undefined; // error, 'undefined' is not assignable to 'number'c.b = 13;c.b = undefined; // okc.b = null; // error, 'null' is not assignable to 'number | undefined' 类型保护和类型断言 由于可以为null的类型是通过联合类型实现，那么你需要使用类型保护来去除 null。 幸运地是这与在JavaScript里写的代码一致： 123456function f(sn: string | null): string &#123; return sn || "default";&#125;console.log(f("default1")); //default1console.log(f(null))// default 如果编译器不能够去除 null或 undefined，你可以使用类型断言手动去除。 语法是添加 !后缀： identifier!从 identifier的类型里去除了 null和 undefined：(我的支持并没有报错) 123456789101112131415function broken(name: string | null): string &#123; function postfix(epithet: string) &#123; return name.charAt(0) + '. the ' + epithet; // error, 'name' is possibly null &#125; name = name || "Bob"; return postfix("great");&#125;function fixed(name: string | null): string &#123; function postfix(epithet: string) &#123; return name!.charAt(0) + '. the ' + epithet; // ok &#125; name = name || "Bob"; return postfix("great");&#125; 类型别名 类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 起别名不会新建一个类型 - 它创建了一个新 名字来引用那个类型。 给原始类型起别名通常没什么用，尽管可以做为文档的一种形式使用。 同接口一样，类型别名也可以是泛型 - 我们可以添加类型参数并且在别名声明的右侧传入： 1type Container&lt;T&gt; = &#123; value: T &#125;; 我们也可以使用类型别名来在属性里引用自己： 12345type Tree&lt;T&gt; = &#123; value: T; left: Tree&lt;T&gt;; right: Tree&lt;T&gt;;&#125; 与交叉类型一起使用，我们可以创建出一些十分稀奇古怪的类型 1234567891011type LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;interface Person &#123; name: string;&#125;var people: LinkedList&lt;Person&gt;;var s = people.name;var s = people.next.name;var s = people.next.next.name;var s = people.next.next.next.name; 然而，类型别名不能出现在声明右侧的任何地方。 1type Yikes = Array&lt;Yikes&gt;; // error 接口 vs. 类型别名 像我们提到的，类型别名可以像接口一样；然而，仍有一些细微差别。 其一，接口创建了一个新的名字，可以在其它任何地方使用。 类型别名并不创建新名字—比如，错误信息就不会使用别名。 在下面的示例代码里，在编译器中将鼠标悬停在 interfaced上，显示它返回的是 Interface，但悬停在 aliased上时，显示的却是对象字面量类型。 另一个重要区别是类型别名不能被 extends和 implements（自己也不能 extends和 implements其它类型）。 因为 软件中的对象应该对于扩展是开放的，但是对于修改是封闭的，你应该尽量去使用接口代替类型别名。 另一方面，如果你无法通过接口来描述一个类型并且需要使用联合类型或元组类型，这时通常会使用类型别名。123456type Alias = &#123; num: number &#125;interface Interface &#123; num: number;&#125;declare function aliased(arg: Alias): Alias;declare function interfaced(arg: Interface): Interface; 字符串字面量类型 字符串字面量类型允许你指定字符串必须的固定值。 在实际应用中，字符串字面量类型可以与联合类型，类型保护和类型别名很好的配合。 通过结合使用这些特性，你可以实现类似枚举类型的字符串。 这样就可以很明确的去限定输入的字符面量，只可以输入限定的那结果字符串否则就是错误的 1234567891011121314151617181920type Easing = "ease-in" | "ease-out" | "ease-in-out";class UIElement &#123; animate(dx: number, dy: number, easing: Easing) &#123; if (easing === "ease-in") &#123; // ... &#125; else if (easing === "ease-out") &#123; &#125; else if (easing === "ease-in-out") &#123; &#125; else &#123; // error! should not pass null or undefined. &#125; &#125;&#125;let button = new UIElement();button.animate(0, 0, "ease-in");button.animate(0, 0, "uneasy"); // error: "uneasy" is not allowed hereArgument of type '"uneasy"' is not assignable to parameter of type '"ease-in" | "ease-out" | "ease-in-out"' 字符串字面量类型还可以用于区分函数重载： 就是说会检测重载时的变量和返回类型123456function createElement(tagName: "img"): HTMLImageElement;function createElement(tagName: "input"): HTMLInputElement;// ... more overloads ...function createElement(tagName: string): Element &#123; // ... code goes here ...&#125; 数字字面量类型12345678910function rollDie(): 1 | 2 | 3 | 4 | 5 | 6 &#123; // ...&#125;function foo(x: number) &#123; if (x !== 1 || x !== 2) &#123; // ~~~~~~~ // Operator '!==' cannot be applied to types '1' and '2'. &#125;&#125; 换句话说，当 x与 2进行比较的时候，它的值必须为 1，这就意味着上面的比较检查是非法的。 可辨识联合（Discriminated Unions） 你可以合并单例类型，联合类型，类型保护和类型别名来创建一个叫做 可辨识联合的高级模式，它也称做 标签联合或 代数数据类型。 可辨识联合在函数式编程很有用处。 一些语言会自动地为你辨识联合；而TypeScript则基于已有的JavaScript模式。 它具有3个要素： 具有普通的单例类型属性— 可辨识的特征。 一个类型别名包含了那些类型的联合— 联合。 此属性上的类型保护。12345678910111213141516171819202122232425interface Square &#123; kind: "square"; size: number;&#125;interface Rectangle &#123; kind: "rectangle"; width: number; height: number;&#125;interface Circle &#123; kind: "circle"; radius: number;&#125;type Shape = Square | Rectangle | Circle;function area(s: Shape) &#123; switch (s.kind) &#123; case "square": return s.size * s.size; case "rectangle": return s.height * s.width; case "circle": return Math.PI * s.radius ** 2; default: return assertNever(s); // error here if there are missing cases &#125; &#125;&#125; 这里， assertNever检查 s是否为 never类型—即为除去所有可能情况后剩下的类型。 如果你忘记了某个case，那么 s将具有一个真实的类型并且你会得到一个错误。 这种方式需要你定义一个额外的函数，但是在你忘记某个case的时候也更加明显。 多态的 this类型 多态的 this类型表示的是某个包含类或接口的 子类型。 这被称做 F-bounded多态性。 它能很容易的表现连贯接口间的继承，比如。 在计算器的例子里，在每个操作之后都返回 this类型： 这里this指向的就是数据 123456789101112131415161718192021class BasicCalculator &#123; public constructor(protected value: number = 0) &#123; &#125; public currentValue(): number &#123; return this.value; &#125; public add(operand: number): this &#123; this.value += operand; return this; &#125; public multiply(operand: number): this &#123; this.value *= operand; return this; &#125; // ... other operations go here ...&#125;let v = new BasicCalculator(2) .multiply(5) .add(1) .currentValue(); // 11 由于这个类使用了 this类型，你可以继承它，新的类可以直接使用之前的方法，不需要做任何的改变。 12345678910111213141516class ScientificCalculator extends BasicCalculator &#123; public constructor(value = 0) &#123; super(value); &#125; public sin() &#123; this.value = Math.sin(this.value); return this; &#125; // ... other operations go here ...&#125;let v = new ScientificCalculator(2) .multiply(5) .sin() .add(1) .currentValue(); // 0.4559788891106302 如果没有 this类型， ScientificCalculator就不能够在继承 BasicCalculator的同时还保持接口的连贯性。 multiply将会返回 BasicCalculator，它并没有 sin方法。 然而，使用 this类型， multiply会返回 this，在这里就是 ScientificCalculator。 索引类型（Index types） 使用索引类型，编译器就能够检查使用了动态属性名的代码。 例如，一个常见的JavaScript模式是从对象中选取属性的子集。 下面是如何在TypeScript里使用此函数，通过 索引类型查询和 索引访问操作符： 12345678910111213function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123; return names.map(n =&gt; o[n]);&#125;interface Person &#123; name: string; age: number;&#125;let person: Person = &#123; name: 'Jarid', age: 35&#125;;let strings: string[] = pluck(person, ['name']); // ok, string[] 编译器会检查 name是否真的是 Person的一个属性。 本例还引入了几个新的类型操作符。 首先是 keyof T， 索引类型查询操作符。 对于任何类型 T， keyof T的结果为 T上已知的公共属性名的联合。 例如： keyof 就是检测类型里面是否拥有 1let personProps: keyof Person; // 'name' | 'age' keyof Person是完全可以与 ‘name’ | ‘age’互相替换的。 不同的是如果你添加了其它的属性到 Person，例如 address: string，那么 keyof Person会自动变为 ‘name’ | ‘age’ | ‘address’。 你可以在像 pluck函数这类上下文里使用 keyof，因为在使用之前你并不清楚可能出现的属性名。 但编译器会检查你是否传入了正确的属性名给 pluck： 1pluck(person, ['age', 'unknown']); // error, 'unknown' is not in 'name' | 'age' 第二个操作符是 T[K]， 索引访问操作符。 在这里，类型语法反映了表达式语法。 这意味着 person[‘name’]具有类型 Person[‘name’] — 在我们的例子里则为 string类型。 然而，就像索引类型查询一样，你可以在普通的上下文里使用 T[K]，这正是它的强大所在。 你只要确保类型变量 K extends keyof T就可以了。 例如下面 getProperty函数的例子： 123function getProperty&lt;T, K extends keyof T&gt;(o: T, name: K): T[K] &#123; return o[name]; // o[name] is of type T[K]&#125; getProperty里的 o: T和 name: K，意味着 o[name]: T[K]。 当你返回 T[K]的结果，编译器会实例化键的真实类型，因此 getProperty的返回值类型会随着你需要的属性改变。 123let name: string = getProperty(person, 'name');let age: number = getProperty(person, 'age');let unknown = getProperty(person, 'unknown'); // error, 'unknown' is not in 'name' | 'age' 索引类型和字符串索引签名 keyof和 T[K]与字符串索引签名进行交互。 如果你有一个带有字符串索引签名的类型，那么 keyof T会是 string。 并且 T[string]为索引签名的类型：12345interface Map&lt;T&gt; &#123; [key: string]: T;&#125;let keys: keyof Map&lt;number&gt;; // stringlet value: Map&lt;number&gt;['foo']; // number 映射类型 一个常见的任务是将一个已知的类型每个属性都变为可选的/或只读 123456789interface PersonPartial &#123; name?: string; age?: number;&#125;interface PersonReadonly &#123; readonly name: string; readonly age: number;&#125; 这在JavaScript里经常出现，TypeScript提供了从旧类型中创建新类型的一种方式 — 映射类型。 在映射类型里，新类型以相同的形式去转换旧类型里每个属性。 例如，你可以令每个属性成为 readonly类型或可选的。 下面是一些例子： 12345678910type Readonly&lt;T&gt; = &#123; readonly [P in keyof T]: T[P];&#125;type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P];&#125;// 使用type PersonPartial = Partial&lt;Person&gt;;type ReadonlyPerson = Readonly&lt;Person&gt;; 下面来看看最简单的映射类型和它的组成部分： 12type Keys = 'option1' | 'option2';type Flags = &#123; [K in Keys]: boolean &#125;; 它的语法与索引签名的语法类型，内部使用了 for .. in。 具有三个部分： 类型变量 K，它会依次绑定到每个属性。 字符串字面量联合的 Keys，它包含了要迭代的属性名的集合。 属性的结果类型。 在个简单的例子里， Keys是硬编码的的属性名列表并且属性类型永远是 boolean，因此这个映射类型等同于： 1234type Flags = &#123; option1: boolean; option2: boolean;&#125; 在真正的应用里，可能不同于上面的 Readonly或 Partial。 它们会基于一些已存在的类型，且按照一定的方式转换字段。 这就是 keyof和索引访问类型要做的事情： 12type Nullable&lt;T&gt; = &#123; [P in keyof T]: T[P] | null &#125;type Partial&lt;T&gt; = &#123; [P in keyof T]?: T[P] &#125; 在这些例子里，属性列表是 keyof T且结果类型是 T[P]的变体。 这是使用通用映射类型的一个好模版。 因为这类转换是 同态的，映射只作用于 T的属性而没有其它的。 编译器知道在添加任何新属性之前可以拷贝所有存在的属性修饰符。 例如，假设 Person.name是只读的，那么 Partial.name也将是只读的且为可选的。 下面是另一个例子， T[P]被包装在 Proxy类里：1234567891011type Proxy&lt;T&gt; = &#123; get(): T; set(value: T): void;&#125;type Proxify&lt;T&gt; = &#123; [P in keyof T]: Proxy&lt;T[P]&gt;;&#125;function proxify&lt;T&gt;(o: T): Proxify&lt;T&gt; &#123; // ... wrap proxies ...&#125;let proxyProps = proxify(props); 注意 Readonly和 Partial用处不小，因此它们与 Pick和 Record一同被包含进了TypeScript的标准库里： 123456type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;type Record&lt;K extends string, T&gt; = &#123; [P in K]: T;&#125; Readonly， Partial和 Pick是同态的，但 Record不是。 因为 Record并不需要输入类型来拷贝属性，所以它不属于同态： 非同态类型本质上会创建新的属性，因此它们不会从它处拷贝属性修饰符。1type ThreeStringProps = Record&lt;'prop1' | 'prop2' | 'prop3', string&gt; 由映射类型进行推断 现在你了解了如何包装一个类型的属性，那么接下来就是如何拆包。 其实这也非常容易： 123456789function unproxify&lt;T&gt;(t: Proxify&lt;T&gt;): T &#123; let result = &#123;&#125; as T; for (const k in t) &#123; result[k] = t[k].get(); &#125; return result;&#125;let originalProps = unproxify(proxyProps); 注意这个拆包推断只适用于同态的映射类型。 如果映射类型不是同态的，那么需要给拆包函数一个明确的类型参数。 后记 这个就是我学习Ts的第九天的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年2-4月开发心得]]></title>
    <url>%2F2019%2F04%2F23%2F2019-04-23%E5%BF%83%E5%BE%97%2F</url>
    <content type="text"><![CDATA[开发心得这段时间，参与了一些实战项目的开发，个人开发、多人协同开发都有经历，个人开发主要是自己一个人去开发，有问题解决问题但是解决问题的方法比较局限与自己的解决方法，这里多人开发优势可能会比较好，多人都会有解决问题的方案这样就可以择选更优的解决方式更有利提高，在实战开发的过程中，遇到很多自己没有尝试过的写法很多自己不懂得都得一点点的去查去理解，观看别人的源码时需要一点一点的去梳理阅读特别是那些没有注释的最为过分，与人开发比较重要的是相互的沟通，彼此包容这样才能更好的协同开发，现在终于把两个项目都写完了，确实通过项目的洗礼成长了很多，再次使用php编写后台api就显得得心应手了、小程序也熟悉了很多，使用后端常用的断点调试在前后端都是查错的好帮手，终于可以再次继续TypeScript的学习了，并完成我的elm计划（仿完整的elm前后台+后端） 半个月前买了个阿里服务器，也花了点时间备案部署网站，安装环境熟悉了node上线部署，php上线部署，并记录方法 忙碌的时候，所有的时间都用来做事，一旦闲下来好想你]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云 Centos 7 Apache 配置https]]></title>
    <url>%2F2019%2F04%2F18%2F%E9%98%BF%E9%87%8C%E4%BA%91Apache%E9%85%8D%E7%BD%AEhttps%2F</url>
    <content type="text"><![CDATA[前言 当我们购买了服务器各种环境都搭建php都搭好项目都放上去了 为了在小程序中使用所以需要配置https，在这之前申请证书是需要域名的所以我购买了域名 经过一系列的备案，是真的麻烦，告诫各位备案信息一定要看清楚不然也会和我一样弄好久 虽然今天备案成功但是信息通信还是需要时间不能马上就配置进入小程序 弄了一下午终于弄好，后来想吧nginx也配置了但是遇到了麻烦也没有找到安装包在哪里暂时放弃 先把这个记录下来，后面有时间再去攻破nginx的配置 配置/工具 阿里云服务器等 Apache环境安装 已购买域名，并且备案通过 熟悉vim为佳 开始申请证书 购买免费ssl证书地址 没钱的直接买免费，有钱的可以自行选配 跟着指示到ssl证书申请验证 申请验证通过后下载证书 下载apache证书 上传证书 创建存放证书目录 1$ mkdir /etc/httpd/cert 把所以证书放上去（先进入下载解压的路径） 1$ scp -r ./zerg.zip root@yhf7.top:/etc/httpd/cert 安装/配置mod_ssl 安装 1$ yum install mod_ssl openssl 配置(更加图片改) 1$ vim /etc/httpd/conf.d/ssl.conf 端口重定向(设置好就重启服务器)12345678$ vim /etc/httpd/conf/httpd.conf&lt;VirtualHost *:80&gt; ServerName yhf7.top //自己的域名：RewriteEngine on RewriteCond %&#123;SERVER_PORT&#125; !^443$ RewriteRule ^/?(.*)$ https://%&#123;SERVER_NAME&#125;/$1 [L,R] &lt;/VirtualHost&gt; 查看效果 后记 配置apache服务器https就说到这里了，下一次部署nginx，有问题欢迎私聊我 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记8 类型兼容性]]></title>
    <url>%2F2019%2F04%2F16%2FTypeScript%E7%AC%94%E8%AE%B08%2F</url>
    <content type="text"><![CDATA[介绍 TypeScript里的类型兼容性是基于结构子类型的。 结构类型是一种只使用其成员来描述类型的方式。 它正好与名义（nominal）类型形成对比。（译者注：在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。） 1234567891011interface Named &#123; name: string;&#125;class Person &#123; name: string;&#125;let p: Named;// OK, because of structural typingp = new Person(); TypeScript的类型系统允许某些在编译阶段无法确认其安全性的操作。当一个类型系统具此属性时，被当做是“不可靠”的。TypeScript允许这种不可靠行为的发生是经过仔细考虑的。通过这篇文章，我们会解释什么时候会发生这种情况和其有利的一面。 开始属性赋值 TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性 这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确123456789101112// 接口interface Named &#123; name: string;&#125;let x: Named;// y's inferred type is &#123; name: string; location: string; &#125;let y = &#123; name: 'Alice', location: 'Seattle' &#125;;x = y;console.log(x)// &#123; name: 'Alice', location: 'Seattle' &#125; 检查函数参数 y有个额外的location属性，但这不会引发错误。 只有目标类型（这里是Named）的成员会被一一检查是否兼容 只有相同给规则才会被提取出来 这个比较过程是递归进行的，检查每个成员及子成员12345function greet(n: Named) &#123; console.log('Hello, ' + n.name); console.log('test', + n.location)// error&#125;greet(y); 比较两个函数 相对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 下面我们从两个简单的函数入手 要赋值首先要判断参数个数和参数类型，查看赋值中的参数是否被赋值中都有对于都参数存在 12345let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;y = x; // OKx = y; // Error 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。 第二个赋值错误，因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。 你可能会疑惑为什么允许忽略参数，像例子y = x中那样。 原因是忽略额外的参数在JavaScript里是很常见的。 例如，Array#forEach给回调函数传3个参数：数组元素，索引和整个数组。 尽管如此，传入一个只使用第一个参数的回调函数也是很有用的12345678let items = [1, 2, 3];// Don't force these extra argumentsitems.forEach((item, index, array) =&gt; console.log(item));// Should be OK!items.forEach((item) =&gt; console.log(item));// 123123 下面来看看如何处理返回值类型，创建两个仅是返回值类型不同的函数 依然结果还是一样的 1234let x = () =&gt; (&#123;name: 'Alice'&#125;);let y = () =&gt; (&#123;name: 'Alice', location: 'Seattle'&#125;);x = y; // OKy = x; // Error, because x() lacks a location property 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型 函数参数双向协变 当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式 下面的例子都是指定着一些不安全的写法不允许的写法12345678910111213141516171819enum EventType &#123; Mouse, Keyboard &#125;interface Event &#123; timestamp: number; &#125;interface MouseEvent extends Event &#123; x: number; y: number &#125;interface KeyEvent extends Event &#123; keyCode: number &#125;function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) &#123; /* ... */&#125;// Unsound, but useful and commonlistenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + ',' + e.y));// Undesirable alternatives in presence of soundnesslistenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + ',' + (&lt;MouseEvent&gt;e).y));listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + ',' + e.y)));// Still disallowed (clear error). Type safety enforced for wholly incompatible typeslistenEvent(EventType.Mouse, (e: number) =&gt; console.log(e)); 可选参数及剩余参数 比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误 当一个函数有剩余参数时，它被当做无限个可选参数 这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded 其实用可选和不用是一样的123456789101112131415161718192021function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) &#123; /* ... Invoke callback with 'args' ... */ // 调用1 callback(args) // 1,2, undefined // 1,2, undefined // 调用2 callback(...args) // 1,2 // 1,2 // 调用3 callback() // undefined,undefined // undefined,undefined&#125;// Unsound - invokeLater "might" provide any number of argumentsinvokeLater([1, 2], (x, y) =&gt; console.log(x + ', ' + y));// Confusing (x and y are actually required) and undiscoverableinvokeLater([1, 2], (x?, y?) =&gt; console.log(x + ', ' + y)); 枚举 枚举类型与数字类型兼容，并且数字类型与枚举类型兼容。不同枚举类型之间是不兼容的12345678enum Status &#123; Ready, Waiting &#125;;enum Color &#123; Red, Blue, Green &#125;;// 这里如果使用status的命名接收也是会报错的let test = Status.Ready; //0test = Color.Green; // Error ，虽然报错但是执行js文件是可以输出2的console.log(test) 类 类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内1234567891011121314151617class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; feet: number; // 1.如果加入一个string在这里 test: string constructor(numFeet: number) &#123; &#125;&#125;let a: Animal;let s: Size;a = s; // OKs = a; // OK , 2.这里就无法赋值了 类的私有成员和受保护成员 的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。123456789101112131415class Animal &#123; feet: number; constructor(name: string, numFeet: number) &#123; &#125;&#125;class Size &#123; private feet: number constructor(numFeet: number) &#123; &#125;&#125;let a: Animal;let s: Size;a = s; // errors = a; // error 泛型 因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型 123456interface Empty&lt;T&gt; &#123;&#125;let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; //0k 上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了 12345678interface Empty&lt;T&gt; &#123; data: T&#125;let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; //error// 因为用到了具体实例上，就不再是范型就存在差异了 对于没指定泛型类型的泛型参数时，会把所有泛型参数当成any比较。 然后用结果类型进行比较，就像上面第一个例子123456789let identity = function&lt;T&gt;(x: T): T &#123; // ...&#125;let reverse = function&lt;U&gt;(y: U): U &#123; // ...&#125;identity = reverse; 后记 这个就是我学习Ts的第八天的笔记，后面学习ts的高级类型，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记7 枚举]]></title>
    <url>%2F2019%2F04%2F15%2FTypeScript%E7%AC%94%E8%AE%B07%2F</url>
    <content type="text"><![CDATA[前言 近来花了大量时间在做项目重构忽略了ts的学习，今天已经完成了工作 接着之前的学习，继续学习我们的ts，今天学枚举 介绍 使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 TypeScript支持数字的和基于字符串的枚举。 枚举数字枚举 我们定义了一个数字枚举， Up使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Direction.Up的值为 1， Down为 2， Left为 3， Right为 4。 如果不定义1 那就从0开始递增123456789101112enum Direction &#123; Up = 1, Down, Left, Right&#125;enum Direction &#123; Up,//0 Down,//1 Left,//2&#125; 简单的通过枚举的属性来访问枚举成员 可能会有一些报错提醒，直接运行node跑js就好了12345678910enum Response &#123; No = 0, Yes = 1,&#125;function respond(recipient: string, message: Response): void &#123; console.log('Yes', message) // 输出 Yes 1&#125;respond("Princess Caroline", Response.Yes) 数字枚举可以被混入到 计算过的和常量成员（如下所示）。 简短地说，不带初始化器的枚举或者被放在第一的位置，或者被放在使用了数字常量或其它常量初始化了的枚举后面。 换句话说，下面的情况是不被允许的： 就是说可以用但是不能放在前面1234enum E &#123; A = getSomeValue(), B, // error! 'A' is not constant-initialized, so 'B' needs an initializer&#125; 字符串枚举 字符串枚举的概念很简单，但是有细微的 运行时的差别。 在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管 反向映射会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。123456enum Direction &#123; Up = "UP", Down = "DOWN", Left = "LEFT", Right = "RIGHT",&#125; 异构枚举 从技术的角度来说，枚举可以混合字符串和数字成员，但是似乎你并不会这么做： 除非你真的想要利用JavaScript运行时的行为，否则我们不建议这样做。1234enum BooleanLikeHeterogeneousEnum &#123; No = 0, Yes = "YES",&#125; 计算的和常量成员 每个枚举成员都带有一个值，它可以是 常量或 计算出来的。 当满足如下条件时，枚举成员被当作是常量：123456789// 默认为数字常量 0enum E &#123; X &#125;// 默认为数字常量 当前是上一位的+1 , 0,1,2enum E1 &#123; X, Y, Z &#125;enum E2 &#123; // 1,2,3 A = 1, B, C&#125; 枚举成员使用 常量枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量或数字字面量） 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符 +, -, ~其中之一应用在了常量枚举表达式常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。 运算符 （字符串无法使用） | 表示两边求并集（元素相加，相同元素只出现一次）12345678910111213141516171819202122// 数字例子enum Test &#123; A = 1, B = 1, C = A | B&#125;// 由于两个相等所以只会保留两个// C = 1 = A = Benum Test &#123; A = 1, B = 2, C = A | B&#125;// C = 3 = A+B// 字符串例子 xenum Test &#123; A = "abc", B = "bcd", C = A | B&#125;// 这样是错误的 字符串是不允许用计算属性的 1234567enum AnimalFlags &#123; None = 0, HasClaws = 1 &lt;&lt; 0, // 1 x 2的0次方 CanFly = 1 &lt;&lt; 1, // 1 x 2的1次方 EatsFish = 1 &lt;&lt; 2, // 1 x 2的2次方 Endangered = 1 &lt;&lt; 3 // 1 x 2的3次方&#125; 其实可以理解为前面的数乘以后面的数的2次方倍 我们使用了左移的位运算符，将数字 1 的二进制向左移动位置得到数字 0001、0010、0100 和 1000（换成十进制结果是：1, 2, 4, 8）。当你在使用这种标记的时候，这些位运算符 | (或)、&amp; （和）、~ （非）将会是你最好的朋友 其余的用个例子来说 &amp;:表示两边是否其中一个是另外一个的子集，如果是返回子集，否则返回0（如果其中一个包含另外一个，返回被包含的，否则返回0） ^：表示从两者的并集中去除两者的交集（把两个的元素合并到一起，如果两个中有公共元素，要将这个公共元素从合并的结果中去除） ～：表示取反，返回的结果我还不知道应该是什么，以后再查一下。用法主要和“&amp;”一起使用，例如：去除其中的某个元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 枚举enum AnimalFlags &#123; None = 0, HasClaws = 1 &lt;&lt; 0,// 1 CanFly = 1 &lt;&lt; 1 // 2&#125;// 接口interface Animal &#123; flags: AnimalFlags; // &#123;None:0,HasClaws:1,CanFly:2&#125; [key: string]: any;&#125;function printAnimalAbilities(animal: Animal) &#123; console.log('+',animal) var animalFlags = animal.flags; if (animalFlags &amp; AnimalFlags.HasClaws) &#123; console.log('animal has claws'); &#125; if (animalFlags &amp; AnimalFlags.CanFly) &#123; console.log('animal can fly'); &#125; if (animalFlags == AnimalFlags.None) &#123; console.log('nothing'); &#125;&#125;// 赋值var animal = &#123; flags: AnimalFlags.None &#125;;// 0printAnimalAbilities(animal); // nothing// 两个相加，相同的不加animal.flags |= AnimalFlags.HasClaws; // 1printAnimalAbilities(animal); // animal has claws// 清除animal.flags &amp;= ~AnimalFlags.HasClaws; //0printAnimalAbilities(animal); // nothing// 和 = 两个的和animal.flags |= AnimalFlags.HasClaws | AnimalFlags.CanFly; // 3printAnimalAbilities(animal); // animal has claws, animal can fly// 结果+ &#123; flags: 0 &#125;nothing1+ &#123; flags: 1 &#125;animal has claws+ &#123; flags: 0 &#125;nothing1+ &#123; flags: 3 &#125;animal has clawsanimal can fly 联合枚举与枚举成员的类型 存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为 任何字符串字面量（例如： “foo”， “bar”， “baz”） 任何数字字面量（例如： 1, 100） 应用了一元 -符号的数字字面量（例如： -1, -100） 首先，枚举成员成为了类型！ 例如，我们可以说某些成员 只能是枚举成员的值 1234567891011121314151617181920212223242526272829enum ShapeKind &#123; Circle, Square,&#125;interface Circle &#123; kind: ShapeKind.Circle; radius: number;&#125;interface Square &#123; kind: ShapeKind.Square; sideLength: number;&#125;let c: Circle = &#123; kind: ShapeKind.Square, // ~~~~~~~~~~~~~~~~ Error! radius: 100,&#125;// 改let c: Circle = &#123; kind: 100, // 默认数字类型写个数字 // ~~~~~~~~~~~~~~~~ Error! radius: 100,&#125;console.log(c)// &#123; kind: 100, radius: 100 &#125; 另一个变化是枚举类型本身变成了每个枚举成员的 联合。 虽然我们还没有讨论联合类型，但你只要知道通过联合枚举，类型系统能够利用这样一个事实，它可以知道枚举里的值的集合。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如： 123456789101112enum E &#123; Foo, Bar,&#125;function f(x: E) &#123; if (x !== E.Foo || x !== E.Bar) &#123; // 其实就是说第一个都没有了还判断第二个干嘛是不是傻 // ~~~~~~~~~~~ // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'. &#125;&#125; 这个例子里，我们先检查 x是否不是 E.Foo。 如果通过了这个检查，然后 ||会发生短路效果， if语句体里的内容会被执行。 然而，这个检查没有通过，那么 x则 只能为 E.Foo，因此没理由再去检查它是否为 E.Bar。 运行时的枚举 枚举是在运行时真正存在的对象。 例如下面的枚举：123456789101112131415enum E &#123; X, Y, Z&#125;function f(obj: &#123; X: number &#125;) &#123; return obj.X;&#125;// 改function f(obj: &#123; Y: number &#125;) &#123; return obj.Y;&#125;// Works, since 'E' has a property named 'X' which is a number.console.log(f(E));// 0// 1 改后 反向映射 除了创建一个以属性名做为对象成员的对象之外，数字枚举成员还具有了 反向映射，从枚举值到枚举名字。 例如，在下面的例子中： 1234567891011121314// 1enum Enum &#123; A&#125;let a = Enum.A;let nameOfA = Enum[a]; // "A"// 2var Enum;(function (Enum) &#123; Enum[Enum["A"] = 0] = "A";&#125;)(Enum || (Enum = &#123;&#125;));var a = Enum.A;var nameOfA = Enum[a]; // "A" 生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。 const枚举 大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 常量枚举通过在枚举上使用 const修饰符来定义。 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。123456789101112131415const enum Enum &#123; A = 1, B = A * 2&#125;const enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举 外部枚举用来描述已经存在的枚举类型的形状。 12345declare enum Enum &#123; A = 1, B, C = 2&#125; 外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。 后记 时隔多日我又回来了，这个就是我学习Ts的第七天的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云 Linux 与本地之间如何用命令传输文件和文件夹]]></title>
    <url>%2F2019%2F04%2F09%2F%E9%98%BF%E9%87%8C%E4%BA%91%20Linux%20%E4%B8%8E%E6%9C%AC%E5%9C%B0%20%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[前言 记录一下线上和线下是如何传输的 买了服务器以来一直都是使用命令链接服务器 如果想使用界面化工具的话宝塔那些也是不错的，很多人推荐不过没用过 之前我说传文件夹不好传，应该是我那时候路径写的有问题导致的其实是可以传的 开始在本地向服务器传文件123# scp【本地文件的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】$ scp ./scp1.png root@119.23.75.150:/home/admin/ 在本地向服务器传文件夹123# scp -r【本地文件夹的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件夹的路径】$ scp -r ./html root@119.23.75.150:/home/admin/ 本地下载服务器文件123# scp【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】 【本地文件的路径】$ scp root@119.23.75.150:/home/admin/scp1.png ./ 本地下载服务器文件夹(不加-r会报错)123# scp -r【服务器用户名】@【服务器地址】：【服务器上存放文件夹的路径】 【本地文件夹的路径】$ scp -r root@119.23.75.150:/home/admin/html ./ 后记 linux的文件和文件夹下载与上传 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云 Centos7 Node + Vue + Mysql + 自定义webapck打包 线上部署七步走]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%98%BF%E9%87%8C%E4%BA%91node%2Bvue%E6%88%98%E5%B8%83%2F</url>
    <content type="text"><![CDATA[前言 买服务器就是为了尝试线上战布项目 前期我们已经把所有的环境都已经准备好了 买的是轻量级服务器自带配有node环境（node自带4.6我升到了8.0）和mongodb，不过我这个案例用的是mysql 所以我昨天安装了一下mysql，都准备好了今天就来把我之前的小案例放上来实现实战 我的整个案例原来完全是线下的，所以要把数据库迁移后台迁移再上前端 工具 线上 Centose7 服务器（这个系统无差的都可以） Node + Mysql 环境 （不懂的看我前面文章） Node + Vue + Mysql 小案例一个(我用vue-cli打包比较方便你们随意着么高兴着么来) Navicat for MySQL 数据库迁移 全局安装 node 8.0 以上版本 vs code 修改代码（软件一个自己喜欢） 熟悉vim 熟悉控制台操作为佳 开始第一步把本地数据库表迁移到线上数据库 使用navicat 导出数据库数据表 在阿里云的服务器mysql导入数据库 第二步更改后端数据库连接方式与端口号 进入node后端案例mysql连接配置文件 检查端口是否占用了（如果修改了端口请记得到后台防火墙开启权限） 第三步传输到服务器 我说过传文件夹不好传所以我们要打包传 1$ scp 上传文件的地址 root@ip地址:上传到服务器什么位置 进入到文件夹解压包文件 12$ unzip 文件夹名.zip$ rm -rf 文件夹名.zip 清除压缩包 第四步开启服务 开启后端服务 12345678# 进入文件夹$ cd node_server# 查看文件$ ls# 安装依赖包(我安装了cnpm，如果没有的用npm安装包)$ cnpm i# 跑项目$ node app.js 第五步变更vue信息/打包/上传1. 信息变更 变更请求地址，因为本来我是前后分离开发使用的是axios的请求所以默认用了vuecli的代理跨域 在线上放在服务区里面应该是不存在跨域的但是本来就是这样写了我改一下地址和端口算了其他就不做修改 2.打包方法（vue-cli/webpack自定义）打包方法一 vue-cli打包方法打包文件(得到dist文件夹)1$ npm run build 打包方法二 自定义配置webpack（非vue-cli构建的项目才使用） 安装依赖（全局安装是我的个人习惯）12# 由于现在安装的都是4.29.0以上的版本了所以要一并安装webpack-cli$ cnpm i webpack webpack-cli -g 配置打包文件（在项目的根目录建立webpack.config.js文件）123456789const path = require('path');module.exports = &#123; entry: './src/main.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;&#125;; 打包1$ npx webpack --config webpack.config.js 如果你不希望在控制它输入着么多想npm run dev这样多方式打开也是可以的1$ npm run build 3. 上传打包文件（我们只是需要里面的文件其他都不需要） 这里按照相同的方法传到线上的public文件夹里面 第六步变更后端路由 配置静态资源库 1$ vim app.js 第七步开启服务查看线上网页/持久化开启 开启服务 1$ node app.js 持久化管理 12345$ pm2 start app.js# 加名字$ pm2 start app.js --name 名字# 使用npm run 启动$ pm2 start npm --name 名字 -- run serve 后记 阿里云node+vue+mysql战部记录，不知道对不对但是我觉得是成功的 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云 Centos 7 安装 PHP开发环境 Apache/PHP]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%85PHP%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[前言 既然搭了mysql，为什么不把php也布置上来呢 这就安装Apache，弄了一晚上也是出现了一些错误弄了几次最后战胜了它 安装 Apache检查环境 查看系统是否已经安装,我已经安装了所以会已经存在 （如果没有的直接看后面安装就好）1$ rpm -qa | grep httpd 停止服务器运行 1$ /usr/sbin/httpd -k stop 清空原有点安装包 1$ yum -y erase httpd.x86_64 再次查看是否已经清空(如果没有请继续清除) 1$ yum list | grep httpd yum命令安装http 安装httpd1$ yum -y install httpd 删除默认的欢迎页面(这个没有截图) 1$ rm -f /etc/httpd/conf.d/welcome.conf 配置httpd，将服务器名称替换为您自己的环境 （默认的80端口最好别动） 1234567891011$ vim /etc/httpd/conf/httpd.conf------------------------# line 86: 改变管理员的邮箱地址ServerAdmin root@905477376@qq.com# line 95: 改变域名信息 (域名还没批先用公网ip代替着)ServerName 119.23.75.150:80# line 151: none变成AllAllowOverride All# line 164: 添加只能使用目录名称访问的文件名DirectoryIndex index.html index.cgi index.php 开启服务器 (如果用的是阿里轻量级安装有nginx的这里要注意了)12$ systemctl start httpd(这个开启也可以)$ httpd（我个人喜欢直接用这个开启服务） 假如出现上图那个98的那个错误其实就是端口被占用（nginx引起的错误） 解决方法1按照上面图片说的改一个端口就好了 解决方法2：屏蔽反向代理123456789# 1.修改配置$ vim /usr/local/nginx/conf/nginx.conf# 2.检查修改是否合法$ /usr/local/nginx/sbin/nginx -t# 出现下面这两句表示正确# the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok# configuration file /usr/local/nginx/conf/nginx.conf test is successful# 3.重启nginx$ /usr/local/nginx/sbin/nginx -s reload 设置默认启动httpd 1$ systemctl enable httpd 如果开启了防火墙的指向下面的命令开启（阿里轻量级不需要，在后台设置就好不过默认就是80） 1234$ firewall-cmd --add-service=http --permanent# 出现 success 成功$ firewall-cmd --reload# 出现 success 成功 第一个服务器页面（刚才一开始被我们删了） 1$ vim /var/www/html/index.html 写入这一段进去保存1234567&lt;html&gt;&lt;body&gt;&lt;div style="width: 100%; font-size: 40px; font-weight: bold; text-align: center;"&gt;Welcome access LinuxProbe.org,This is Test Page!&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 查看第一个服务器页面 网页打开输入自己的域名或者ip，能出现图片中的样子就是配置成功了 Apache 常用命令 开机和关闭命令中有多个，选其一使用就好123456789101112131415161718# 开启$ httpd$ /usr/sbin/httpd -k start$ systemctl start httpd.service# 关闭$ /usr/sbin/httpd -k stop$ systemctl stop httpd.service# 重启$ /usr/sbin/httpd -k restart# 开机启动/关闭systemctl enable httpd.service #开机启动systemctl disable httpd.service #开机不启动# 状态检查$ systemctl status httpd.service 安装PHP 安装1$ yum -y install php php-mbstring php-pear 设置时区123$ vim /etc/php.ini# line 878: 取消注释，设置时区date.timezone = "Asia/Shanghai" 创建一个PHP测试页面，并使用Web浏览器从客户端PC访问它。如果显示以下页面，它是确定。(ip+index.php)1$ vim /var/www/html/index.php 123456789&lt;html&gt;&lt;body&gt;&lt;div style="width: 100%; font-size: 40px; font-weight: bold; text-align: center;"&gt;&lt;?php print Date("Y/m/d");?&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 创建phpinfo测试页，确认是都开启php支持1$ echo "&lt;?php phpinfo(); ?&gt;" &gt; /var/www/html/phpinfo.php 安装常用拓展依赖(由于linux中php的源包把安装依赖去除了为了后续开发方便要把常用依赖安装了)1$ yum -y install php-mysql php-gd php-ldap php-odbc php-pear php-xml php-xmlrpc php-mbstring php-soap curl curl-devel 链接数据库测试(创建test.php,也可以下载阿里云的测试mysql) 阿里云mysql测试代码地址1234567&lt;?php$conn = @mysqli_connect(&quot;端口号&quot;,&quot;用户名&quot;,&quot;密码&quot;,&quot;数据库名&quot;);if (!$conn) &#123; die(&quot;连接失败&quot;);&#125; echo &quot;连接成功&quot;;?&gt; 后记 安装了mysql当然也要试试PHP啦，这就是我安装apache和php的方法和解决错误方法，下一个说node+vue战布 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云 Centos 7 安装5.6mysql]]></title>
    <url>%2F2019%2F04%2F07%2F%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%89%E8%A3%855.6mysql%2F</url>
    <content type="text"><![CDATA[前言 买了服务器当然要尽情的糟蹋它，给了钱的不能浪费啊 昨天开启了默认的mongodb然后把之前弄的mongodb的项目放了上去 我就想mysql的能不能放上去呢，虽然是轻量级应用但是他也是服务器啊只是默认会安装一种语言而已 那我就想把mysql装上去，为了避免新版与旧版起冲突我就安装了5.6版的我本地好像是5.6还是5.5忘记了 自己安装是个巨坑希望能帮到你 工具 Centos 7 服务器 熟悉vim 本地 Navicat of Mysql 测试连接 开始安装配置 检查服务器是否自带有mysql(用别人镜像的需要注意) 1$ yum list installed | grep mysql 如果发现有系统自带mysql，果断这么干 1$ yum -y remove mysql-libs.x86_64 随便在你存放文件的目录下执行，mysql的yum源服务器在国外的，会比较慢不过我有梯子我不怕哈哈哈 1$ wget http://repo.mysql.com/mysql-community-release-el6-5.noarch.rpm 这个rpm还不是mysql的安装文件，只是两个yum源文件，执行后，在/etc/yum.repos.d/ 这个目录下多出mysql-community-source.repo和mysql-community.repo 1$ rpm -ivh mysql-community-release-el6-5.noarch.rpm 这个时候，可以用yum repolist mysql这个命令查看一下是否已经有mysql可安装文件 1$ yum repolist all | grep mysql 安装mysql 服务器命令（一路yes） 1$ yum install mysql-community-server 安装成功后开启sql（默认没有密码）1$ service mysqld start 由于mysql刚刚安装完的时候，mysql的root用户的密码默认是空的，所以我们需要及时用mysql的root用户登录（第一次回车键，不用输入密码），并修改密码(注意看我上面的图我是用mysql进来了的)1$ update user set password=PASSWORD("这里输入root用户密码") where User='root'; 查看mysql是否自启动,并且设置开启自启动命令 12$ chkconfig --list | grep mysqld$ chkconfig mysqld on 清除安装包 1$ rm -rf mysql-community-release-el6-5.noarch.rpm 案例测试连接数据库 生产开发环境123456789101112# 一个mysql的文件夹$ mkdir mysql# 进入文件假$ cd mysql# 初始化项目$ npm init -y# 安装mysql依赖包$ npm i mysql# 建立一个文件写代码$ touch app.js# vim编写app.js$ vim app.js 编写app.js123456789101112131415var mysql = require("mysql");var conn = mysql.createConnection(&#123; host:'127.0.0.1', // ip user:'root', // 用户名 password:'xxxxx', // 密码 database:'test' // 数据库名&#125;);conn.connect(function(err)&#123; if(err)&#123; console.log("连接失败"); &#125;else&#123; console.log("连接成功"); &#125;&#125;); 用node app.js 跑起来看到如图就是正确连接到数据库了 设置权限外网连接数据库 设置权限1234$ mysql -uroot -p$ use mysql;$ Grant all privileges on *.* to 'root'@'%' identified by '密码' with grant option; $ flush privileges; 本地连接测试 使用navicat mysql 点击测试 安装后使用命令出现1044报错 处理 停掉数据库 1$ /etc/init.d/mysqld stop 进入数据库安全模式 1$ mysqld_safe --skip-grant-tables &amp; 切入到mysql然后操作修改密码 1234567$ mysql# 要看见mysql&gt; 才去执行后面的代表已经进入了数据库 (test123哪里是写密码自己喜欢什么写什么)$ use mysql;$ UPDATE user SET password=password("test123") WHERE user='root'; $ flush privileges;$ exit; 再次进入测试 12$ mysql -uroot -p$ 输入刚才设置的密码 后记 阿里云安装mysql以及连接测试，花了几个小时时间，一开始报错1044弄了好久后来弄好了，测外连接也报错后面也弄好了 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地向阿里云服务器传文件/简单的nginx端口代理]]></title>
    <url>%2F2019%2F04%2F05%2F%E9%98%BF%E9%87%8C%E4%BA%91zip%2F</url>
    <content type="text"><![CDATA[前言 既然线上已经可以跑了，那就看看着么把本地的项目放上去跑 工具 mac 已经写好的一个例子 开始使用scp传文件到服务器 本地做好的一个小案例，linux不支持传文件夹我们只好打包成zip传上去1$ scp 要传的文件路径 用户@端口号:传到系统的那个位置 安装插件解压zip 直接这样我们是无法查看zip的 所以我们只好借助里面的插件来帮助我们Linux(CentOS7)安装zip、unzip命令1$ yum install -y unzip zip 解压运行项目1$ unzip 要解压的文件 nginx端口代理 配置文件,添加代理1$ vim /usr/local/nginx/conf/nginx.conf 重启nginx服务1$ /usr/local/nginx/sbin/nginx -s reload 后记 阿里云上传文件已经nginx端口代理 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云 Centos7 node第一个项目]]></title>
    <url>%2F2019%2F04%2F05%2F%E9%98%BF%E9%87%8C%E4%BA%91hello%2F</url>
    <content type="text"><![CDATA[前言 试过很多地方的战部，没有买过阿里腾讯的服务器，今天就想自己买个服务器玩一下 趁着还是学生可以以学生价格买个便宜一点服务器自己玩一下 买了下来当然是第一个Hello world那是必须的啦！ 工具 Mac os 系统 控制台 阿里云Centos7服务器 由于我直接买的是应用程序不需要我自己去安装node那我说了 懂得vim使用，Linux命令 开始购买服务器 （是学生就去把学生认证做了） 云计划 控制台查看 本地连接服务器/激活nvm 连接服务器 这个ip号就是公网的ip地址在控制台哪里可以看到的 ssh 登录用户@ip号 激活nvm 虽然内置已经安装了node等但是一开始是无法使用的 使用命令激活nvm 123$ echo ". ~/.nvm/nvm.sh" &gt;&gt; /etc/profile$ source /etc/profile 成功激活 安装全局生成器1$ npm install –g express-generator vim编写第一个Hello wrold 项目初始化 本来就是在～了，直接创建一个text文件夹初始化项目 安装web插件（express） 为了写起来更加的方便安装的一个web插件1$ npm i express 创建文件并编写文件 vim编辑文件12345678910111213141516// vim语法i: 写入esc: 退出编辑:wq 保存并登录// 程序const express = require('express');const app = express();app.get('/',function (req,res) &#123; res.send('Hello World'); console.log('test');&#125;)console.log('test2');app.listen(8080); 项目跑起来1$ node app.js 解决无法显示页面 其实不是页面无法显示是防火墙挡住了 回到阿里云控制台把端口添加进入，再回来看页面 持久化运行项目 我们虽然是把项目跑起来了但是我们断开连接就无法访问了 默认我们系统给我们安装了pm2 那就好好的利用 一次可以允许多少个项目？ 其实只要你服务器承受的住开多少个都可以 后记 阿里云第一个hello项目记录 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>服务器</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flex 编写100度网页]]></title>
    <url>%2F2019%2F04%2F03%2Fflex%E5%86%99100%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[前言 最近都没什么时间更新博客 flex不是很会，特意花了两天时间用flex重写之前写过的一个网页界面 有利有弊，整体来说还是挺方便的 案例地址 码云 效果图]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue 开发插件]]></title>
    <url>%2F2019%2F03%2F27%2Fmpvue%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 刚踏入mpvue这个坑 有些属性还是和vue不一样的，使用一些插件来方便开发 开始wxapp-api-interceptors 微信api拦截器 （请求拦截axios） 这个插件是用来拦截微信的api的使得运用可以像axios一样使用 https://www.npmjs.com/package/wxapp-api-interceptors 安装 1$ npm install wxapp-api-interceptors --save mpvue引用 123import wxApiInterceptors from 'wxapp-api-interceptors'; wxApiInterceptors(); // 必须在调用小程序api之前调用 设置请求拦截处理(返回拦截也是可以的) 1234567891011wxApiInterceptors(&#123; request: &#123; request(params) &#123; const host = 'https://test.com' if (!/^(http|\/\/)/.test(params.url)) &#123; params.url = host + params.url; &#125; return params; &#125;, &#125;,&#125;); vuex持久化存储 在项目开发时使用vuex在刷新后是不会存储的 https://github.com/robinvdvleuten/vuex-persistedstate 安装 1$ npm install --save vuex-persistedstate 配置 123456789101112131415161718import &#123; Store &#125; from 'vuex'import createPersistedState from 'vuex-persistedstate'import * as Cookies from 'js-cookie'const store = new Store(&#123; // ... plugins: [ createPersistedState(&#123; storage: &#123; getItem: key =&gt; Cookies.get(key), // Please see https://github.com/js-cookie/js-cookie#json, on how to handle JSON. setItem: (key, value) =&gt; Cookies.set(key, value, &#123; expires: 3, secure: true &#125;), removeItem: key =&gt; Cookies.remove(key), &#125;, &#125;), ],&#125;)]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue 实现获取用户信息]]></title>
    <url>%2F2019%2F03%2F21%2Fmyvue-%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[前言 因开发需求，先来躺mpvue这个坑 首先先从获取用户信息开始吧 一开始就已经被Eslint掠得体无完肤 准备 mac os 10.13.3 vue-cli mpvue项目初始化 mpvue搭建 vs code （工具个人喜欢就好） 熟悉编写vue 不懂得可以看看我的这些笔记 熟悉小程序编写 获取用户信息微信官网 开始 其实也是很简单的操作，熟悉vue和熟悉小程序的写起来就会比较方便 绑定按钮使用open-type属性 我是在src/pages 里面建立了my来编写你们随意 mpvue和写vue没什么区别,mpvue支持小程序写法 模版编写 定义按钮12345678910&lt;template&gt; &lt;div&gt; &lt;!-- 定义一个按钮点击拉起授权 --&gt; &lt;!-- 使用vue的绑定语法绑定getuserinfo用来接收用户的操作返回值 --&gt; &lt;!-- 定义点击用来判断用户版本是否适用 --&gt; &lt;button open-type="getUserInfo" @getuserinfo="bindGetUserInfo" @click="getUserInfo1"&gt;获取权限&lt;/button&gt; &lt;!-- 获取用户信息 --&gt; &lt;button @click="getSetting"&gt;获取用户信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt; 编写srcipt 基本和官网写法可以一直，只是要注意的是绑定方法要使用vue的语法 注意操作细节1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;script&gt;export default &#123; // 编写方法 methods: &#123; /* 判断微信版本是否适用 */ getUserInfo1 () &#123; console.log('click事件首先触发') // 判断小程序的API，回调，参数，组件等是否在当前版本可用。 为false 提醒用户升级微信版本 // console.log(wx.canIUse('button.open-type.getUserInfo')) if (wx.canIUse('button.open-type.getUserInfo')) &#123; // 用户版本可用 &#125; else &#123; console.log('请升级微信版本') &#125; &#125;, // 监听用户点击触发 bindGetUserInfo (e) &#123; // console.log(e.mp.detail.rawData) if (e.mp.detail.rawData) &#123; // 用户按了允许授权按钮 console.log('用户按了允许授权按钮') &#125; else &#123; // 用户按了拒绝按钮 console.log('用户按了拒绝按钮') &#125; &#125;, // 获取用户信息 getSetting () &#123; // 拉取信息 wx.getSetting(&#123; success: function (res) &#123; // 判断是否拥有权限 if (res.authSetting['scope.userInfo']) &#123; wx.getUserInfo(&#123; success: function (res) &#123; console.log(res.userInfo) console.log(res) // 用户已经授权过 console.log('用户已经授权过') &#125; &#125;) &#125; else &#123; console.log('用户还未授权过') &#125; &#125; &#125;) &#125;, &#125;&#125;&lt;/script&gt; 效果展示 写完代码当然要看看效果的啦 按钮 初次测试小程序默认已经拥有了权限，这时点击是已经授权的 点击授权 拒绝授权 未授权获取用户信息 再次触发点击授权，允许后再次获取用户数据 后记 从搭建好mpvue到踏入它其实是第二次，但是真正开始写业务还是第一次，这就是我的第一次使用mpvue获取用户信息，写的不好仅供参考，欢迎添加微信qq交流学习 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android button点击事件/附加题]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%A4%A7%E4%BA%8C%E4%B8%8BAndroid%20%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[前言 每一门语音开发的时候都会有点击的业务 点击按钮弹出什么，点击按钮输出什么 今天的课程就学了按钮点击绑定 记录起来 实现button点击事件的方法 Button类主要的事件为android：onclick。但也可以通使用了OnclickListener监听器来监听事件，并在onClick()方法中响应。 实现button点击事件的监听方法有很多种，这里总结了常用的四种方法： 1、匿名内部类 2、外部类（独立类） 3、实现OnClickListener接口 4、添加XML属性 具体实现 匿名内部类： 在Android开发中我们会经常看到各种匿名内部类的使用，那么在实现button点击事件的时候也可以用匿名内部类。 这样使用的好处是：1）不需要重新写一个类，直接在new的时候去实现想实现的方法，很方便。 2）当别的地方都用不到这个方法的时候使用匿名内部类 3）高内聚，高内聚是设计原则之一，匿名内部类的特性之一就是拥有高内聚。 但是也有不足的地方：1）当别的地方也需要同样的一个方法时还要重新再在那个地方写一次匿名内部类，这样使得代码的冗余性很高。 2）不方便后期的维护 独立类（外部类）： 重新写一个独立的类来实现业务逻辑或是想要的效 这样写的好处是：1）一定情况下可以方便维护 2）可以降低代码的冗余性，可以同时使用到多个地方 不足的地方是：1）当只使用一次时浪费资源，程序的性能不高 2）当有很多个方法时代码的可读性不高，此时不方便维护 实现OnClickListener接口： 与独立类实现的原理是一样的，优点和缺陷也是大径相同的，实现OnClickListener接口的时候实现它其中的onClick方法 添加XML属性： 我们可以给XML添加一个onClick属性来实现点击事件的监控 这样的好处是：更加便捷，代码量能够减少 但是不足的地方是：每一次维护的时候都要去XML里面改源码，很不好维护很麻烦 总结： 在实现监听的时候都是需要两步走： 1）绑定button按钮 setOnClickListener 2）监听button事件 onclick() 具体使用什么方法去实现button按钮点击事件的监听要看具体的需求，都各有各的好处和不足。 如果只使用一次则推荐使用内部类的方法； 如果多次使用则使用外部类的方法； 实现接口的方法可以在原本的类中实现； 但是在XML里面添加属性的方法时不推荐的，毕竟很不好去维护。 内部类的使用在Android开发中是经常用到的，所以非常的重要， Android开发中有很多按钮，但是监听的方法常用的都是这几种 开始写代码 前面看完长长的笔记现在来敲代码了 XML属性（监听button事件 onclick（）） 要求：点击按钮控制台输出文字 页面：线性布局 一个按钮，一个文本框 其实很简单就只是两步，定义了然后实例化点击函数就可以了1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" tools:context=".Buttom_Demo" android:orientation="vertical"&gt; // 1. 绑定id,指定点击函数名 &lt;Button android:id="@+id/button01" android:layout_width="match_parent" android:layout_height="wrap_content" android:onClick="sss" android:text="切换"/&gt; &lt;TextView android:id="@+id/text1" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="adggegege"/&gt;&lt;/LinearLayout&gt; 1234567891011121314151617181920package com.example.yhf.button_demo;import android.graphics.Color;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;public class Buttom_Demo extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.buttom__demo); &#125; // 2. 实例化点击函数 public void sss(View view) &#123; System.out.println("--------------------该按钮是对的控制------------"); &#125;&#125; OnClickListener接口方法 我们这次就不输出控制台了，我改变文本内容 这个就比较复杂一点 纯属定义一个按钮和文本就可以，定义id1234567891011// 1. 绑定id,指定点击函数名&lt;Button android:id="@+id/button01" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="切换"/&gt;&lt;TextView android:id="@+id/text1" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="adggegege"/&gt; 接下来就是重点了认真看1234567891011121314151617181920212223242526272829303132333435363738package com.example.yhf.button_demo;// 引包输入组件的时候软件自动导入如果没有自己手打import android.graphics.Color;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;//4 抽象方法 OnClickListenerpublic class Buttom_Demo extends AppCompatActivity implements View.OnClickListener &#123; // 2. 声明变量 Button bt1; TextView t1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.buttom__demo); // 3. 这里是给变量绑定组件 // 通过id来绑定 bt1 = (Button)findViewById(R.id.button01); t1 = (TextView)findViewById(R.id.text1); // 6. 设定点击绑定到bt1也就是按钮 // 使用setOnClickListener绑定 bt1.setOnClickListener(this); &#125; // 5. 实例化抽象方法 public void onClick(View view) &#123; t1.setText("嘿，你好"); t1.setTextColor(Color.BLUE); &#125;&#125; 拓展题 按照上面的改成，可以多次点击切换不同的值，不是点了后写死了 分析一下如何做：我的第一想法是给他一个数组写好很多个文字，每一次切换就获取数组中不同的值12345678910111213141516171819202122232425262728293031323334353637383940package com.example.yhf.button_demo;import android.graphics.Color;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Buttom_Demo extends AppCompatActivity implements View.OnClickListener &#123; Button bt1; TextView t1; // 1. 定义一个i用了判断是数据的第几个 int i = 0; // 2. 数据数组 String[] str = &#123;"a","b","c","d","e"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.buttom__demo); bt1 = (Button)findViewById(R.id.button01); t1 = (TextView)findViewById(R.id.text1); bt1.setOnClickListener(this); &#125; public void onClick(View view) &#123; // 3. 判断大于后又回到0继续从0输出，不然超出会报错的 if (i&gt;str.length-1) &#123;i=0;&#125; // 4. 输出的时候拿数组的值 t1.setText(str[i]); t1.setTextColor(Color.BLUE); // 每点击一次一个数 i++; &#125;&#125; 补充其余用法 还有两种用法就是绑定外部类和内部类 和拓展题同样的业务，不同的实现方法 要注意引包 其实也是挺简单的用法都差不多只是地方不同12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394package com.example.yhf.button_demo;import android.graphics.Color;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Buttom_Demo extends AppCompatActivity &#123; // Button bt1,bt2; Button bt1; TextView t1; int i = 0; String[] str = &#123;"a","b","c","d","e"&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.buttom__demo); bt1 = (Button)findViewById(R.id.button01); t1 = (TextView)findViewById(R.id.text1); // 2。 外部类onclik，new 外面的类 bt1.setOnClickListener(new listener()); // 3. 内部类onclick bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; System.out.println("test"); &#125; &#125;); &#125; // 外部类 class listener implements View.OnClickListener &#123; public void onClick(View view) &#123; if (i&gt;str.length-1) &#123;i=0;&#125; t1.setText(str[i]); t1.setTextColor(Color.BLUE); i++; &#125; &#125;&#125;### 外部类小案例- 多按钮绑定同一点击事件，控制id改变文本- 定义了三个按钮，一个文本框``` Javapackage com.example.yhf.button_demo;import android.graphics.Color;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.View;import android.widget.Button;import android.widget.TextView;public class Buttom_Demo extends AppCompatActivity &#123; Button bt1,bt2,bt3; TextView t1; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.demo); bt1 = (Button)findViewById(R.id.bt1); bt2 = (Button)findViewById(R.id.bt2); bt3 = (Button)findViewById(R.id.bt3); t1 = (TextView)findViewById(R.id.text1); // 2。 外部类onclik bt1.setOnClickListener(new listener()); bt2.setOnClickListener(new listener()); bt3.setOnClickListener(new listener()); &#125;// 外部类 class listener implements View.OnClickListener &#123; public void onClick(View v) &#123; // 通过判断 引子是getId,点击后会返回一个view的参数 switch (v.getId()) &#123; case R.id.bt1: t1.setText("你爸1"); t1.setTextColor(Color.BLUE); break; case R.id.bt2: t1.setText("你爸2"); t1.setTextColor(Color.RED); break; case R.id.bt3: t1.setText("你爸3"); t1.setTextColor(Color.YELLOW); break; &#125; &#125; &#125;&#125; 后记 今日上课的练习和笔记都记录在这里了，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记6 范型]]></title>
    <url>%2F2019%2F03%2F19%2FTypeScript%E7%AC%94%E8%AE%B06%2F</url>
    <content type="text"><![CDATA[前言 今日继续学习ts 等待大哥确认的时间我们继续看看ts范型 介绍 软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 其实很简单，这就是为了方便复用而设立的，以前在看java的时候对范型就不是学的很好，现在看文档感觉清晰很多了 那我们继续走入ts，范型 范型-Hello World 下面来创建第一个使用泛型的例子：identity函数。 这个函数会返回任何传入它的值。 你可以把这个函数当成是 echo命令。 123function identity(arg: number): number &#123; return arg;&#125; 这个例子建立的是一个参数和返回值为数字类型的 但是我们后续想切换类型着么办？很多人说使用any任意类型啊来看看any 建立范型123function identity(arg: any): any &#123; return arg;&#125; 确实达到了预期的效果 但是发现了没有，无论什么类型都可以输入，什么类型的值都可以返回 这个和之前的js有什么区别，何必还要写呢所以我们需要一个方法去控制住参数和返回值类型相同 我们给函数添加了一个类型变量T，当我们给这个t赋值了number，他就会自动捕获到，然后赋值到参数和返回值类型当中 这样到函数叫做范型（官网这么说的）不同于使用 any，它不会丢失信息，像第一个例子那像保持准确性，传入数值类型并返回数值类型。123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 使用范型 第一种是，传入所有的参数，包含类型参数 第二种方法更普遍。利用了类型推论 – 即编译器会根据传入的参数自动地帮助我们确定T的类型 这里我们明确的指定了T是string类型，并做为一个参数传给函数，使用了&lt;&gt;括起来而不是()。（重点）12345// 传入参数let output = identity&lt;string&gt;("myString"); // type of output will be 'string'// 自动推断let output = identity("myString"); // type of output will be 'string' 注意我们没必要使用尖括号（&lt;&gt;）来明确地传入类型；编译器可以查看myString的值，然后把T设置为它的类型。 类型推论帮助我们保持代码精简和高可读性。如果编译器不能够自动地推断出类型的话，只能像上面那样明确的传入T的类型，在一些复杂的情况下，这是可能出现的。（这个要注意）使用范型变量 使用泛型创建像identity这样的泛型函数时，编译器要求你在函数体必须正确的使用这个通用的类型。 换句话说，你必须把这些参数当做是任意或所有类型。 如果这么做，编译器会报错说我们使用了arg的.length属性，但是没有地方指明arg具有这个属性。 记住，这些类型变量代表的是任意类型，所以使用这个函数的人可能传入的是个数字，而数字是没有 .length属性的。 所以是错误的不能输出 1234function loggingIdentity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // Error: T doesn't have .length return arg;&#125; 现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以.length属性是应该存在的。 我们可以像创建其它数组一样创建这个数组 他把参数设立成是一个类型的数组了 相当于我吧t定义为number arg是number类型的数组 返回值也是一个number的数组 数组是拥有.length的属性的 1234567891011121314151617181920// numberfunction loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125;let output = loggingIdentity&lt;number&gt;([1,2]); // type of output will be 'string'console.log(output);// Stringfunction loggingIdentity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125;let output = loggingIdentity&lt;String&gt;(["a"]); // type of output will be 'string'console.log(output); 你可以这样理解loggingIdentity的类型：泛型函数loggingIdentity，接收类型参数T和参数arg，它是个元素类型是T的数组，并返回元素类型是T的数组。 如果我们传入数字数组，将返回一个数字数组，因为此时 T的的类型为number。 这可以让我们把泛型变量T当做类型的一部分使用，而不是整个类型，增加了灵活性。 —————————- 还有一种写法可以更加规范上面的写法 在里面在写一次范型，直接定义数组类型1234567function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125;// 输出结果1[ 'a' ] 泛型类型 我们创建了identity通用函数，可以适用于不同的类型。 在这节，我们研究一下函数本身的类型，以及如何创建泛型接口。 我们也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以。12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &lt;U&gt;(arg: U) =&gt; U = identity; 我们还可以使用带有调用签名的对象字面量来定义泛型函数：（对签名还是带有疑惑）12345function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: &#123;&lt;T&gt;(arg: T): T&#125; = identity; 第一个范型接口123456789101112interface GenericIdentityFn &#123; &lt;T&gt;(arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn = identity;console.log(myIdentity&lt;String&gt;("abc"));console.log(myIdentitys("cba"));// 如果写了接口后我们还用这样的类型推断法是不可以的 error 接口变形 我们的示例做了少许改动。 不再描述泛型函数，而是把非泛型函数签名作为泛型类型一部分。 当我们使用 GenericIdentityFn的时候，还得传入一个类型参数来指定泛型类型（这里是：number），锁定了之后代码里使用的类型。 对于描述哪部分类型属于泛型部分来说，理解何时把参数放在调用签名里和何时放在接口上是很有帮助的。 很直接的改变就是给接口做了范型，在初始化的时候就要传入类型了 在使用的时候不再需要去指定范型1234567891011121314interface GenericIdentityFn&lt;T&gt; &#123; (arg: T): T;&#125;function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity;console.log(myIdentity(1)); //1let myIdentity2: GenericIdentityFn&lt;string&gt; = identity;console.log(myIdentity2("abc"); //abc 范型类 泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。 这个理解起来还是挺好理解的 123456789class GenericNumber&lt;T&gt; &#123; zeroValue: T; add: (x: T, y: T) =&gt; T;&#125;let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) &#123; return x + y; &#125;;console.log(myGenericNumber.add(3,4)) // 7 GenericNumber类的使用是十分直观的，并且你可能已经注意到了，没有什么去限制它只能使用number类型。 也可以使用字符串或其它更复杂的类型 与接口一样，直接把泛型类型放在类后面，可以帮助我们确认类的所有属性都在使用相同的类型。 我们在类那节说过，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。12345let stringNumeric = new GenericNumber&lt;string&gt;();stringNumeric.zeroValue = "";stringNumeric.add = function(x, y) &#123; return x + y; &#125;;console.log(stringNumeric.add(stringNumeric.zeroValue, "test")); 泛型约束 意思就是说使用extends 这个关键字来约束必须每一次都要输入一个带有length的属性，不然就是错的 1234567891011interface Lengthwise &#123; length: number;&#125;function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T &#123; console.log(arg.length); // Now we know it has a .length property, so no more error return arg;&#125;loggingIdentity(3); // ErrorloggingIdentity(&#123;length: 10, value: 3&#125;); // 这样才是对的 在泛型约束中使用类型参数 你可以声明一个类型参数，且它被另一个类型参数所约束。 比如，现在我们想要用属性名从对象里获取这个属性。 并且我们想要确保这个属性存在于对象 obj上，因此我们需要在这两个类型之间使用约束。 编译器运行的时候会报错但是js文件可以运行的，估计是我没有指定类型不过官网也是这样用的12345678function getProperty(obj: T, key: K) &#123; return obj[key];&#125;let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;// getProperty(x, "m"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.console.log(getProperty(x, "a");); 在泛型里使用类类型 (不是很懂,懂了) 当我再回头盯上你，你必是我囊中之物 其实呢我是在实例它的时候不太懂 经过查阅资料慢慢的弄懂了，要定义一个类把类放进入 在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如， 123456789101112131415161718192021// 这里是需要构建一个类 ，函数范型了类， 传入值是类，返回值也是类// 参数是一个可以new的参数那就是类啦function create&lt;T&gt;(c: &#123;new(): T; &#125;): T &#123; return new c();&#125;// 构建一个类class Student &#123; constructor () &#123; &#125; // 写一个方法 say () &#123; console.log("student say") &#125;&#125;// 实例化create// 传入范型值和参数let stu = create&lt;Student&gt;(Student)stu.say() 一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。 再去看这个升级例子，需要一定的编程基础 官网上面的还是自己去构建完整的体系1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class BeeKeeper &#123; hasMask: boolean; constructor (hasMask:boolean) &#123; this.hasMask = hasMask; &#125;&#125;class ZooKeeper &#123; nametag: string; constructor (nametag: string) &#123; this.nametag = nametag; &#125;&#125;// 主类class Animal &#123; numLegs: number; constructor (numLegs: number) &#123; this.numLegs = numLegs; &#125;&#125;// 定义继承类class Bee extends Animal &#123; // 内部元素声明的是其他的类 keeper: BeeKeeper; // 需要构造函数去实例化 constructor () &#123; super(4) this.keeper = new BeeKeeper(true); &#125;&#125;class Lion extends Animal &#123; keeper: ZooKeeper; constructor () &#123; super(4) this.keeper = new ZooKeeper("YHF"); &#125;&#125;// A的约束类型是Animal，这里不是继承是约束,需要拥有约束类型的元素，要不自己写要不继承它，这里的操作只是约束不是继承function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A &#123; return new c();&#125;console.log(createInstance(Lion).keeper.nametag); // YHFconsole.log(createInstance(Bee).keeper.hasMask); // trueconsole.log(createInstance(Lion).numLegs); // 4 在泛型里使用类类型 （理解后自定义练习） 使用类不同的声明类型 添加判断，深刻理解1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Student &#123; aa: string constructor (aa: string) &#123; this.aa = aa &#125;&#125;class Test &#123; bb: number constructor (bb: number) &#123; this.bb = bb &#125;&#125;class cat &#123; cc: boolean constructor (cc: boolean) &#123; this.cc = cc &#125;&#125;class A1 extends cat &#123; dd: Student constructor (g : boolean) &#123; if (g) &#123; super(g) this.dd = new Student("YHF"); &#125; else &#123; super(g) this.dd = new Student("err"); &#125; &#125; test (aa: string) &#123; let sum = new Student(aa) return sum.aa &#125;&#125;class A2 extends cat &#123; ee: Test constructor (g : boolean) &#123; if (g) &#123; super(g) this.ee = new Test(1); &#125; else &#123; super(g) this.ee = new Test(2); &#125; &#125;&#125;function abc&lt;T extends cat&gt;(c: new (g) =&gt; T,g: boolean): T &#123; return new c(g);&#125;let test1 = abc(A1,true);console.log(test1.dd.aa) // YHFconsole.log(test1.cc) // trueconsole.log(test1.test("改变YHF,我叫你爸爸")); // 改变YHF,我叫你爸爸console.log(abc(A2,false).ee.bb); // 2 后记 这个就是我学习Ts的第六天的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记5 函数]]></title>
    <url>%2F2019%2F03%2F18%2FTypeScript%E7%AC%94%E8%AE%B05%2F</url>
    <content type="text"><![CDATA[前言 时隔多天，今天的需求配色出了点问题等处理，我就又来继续我的Ts之旅 继续看文档学习Ts直到学完为止 今天是记录ts的第五天 今天学习ts的函数，上一次学的是类这一次到函数了 等到全部过一遍再重新回头看看 介绍函数是JavaScript应用程序的基础。 它帮助你实现抽象层，模拟类，信息隐藏和模块。 在TypeScript里，虽然已经支持类，命名空间和模块，但函数仍然是主要的定义 行为的地方。 TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。 函数 其实简单的来说和js没有什么区别 没错使用js的这两种监理方式在ts上是可以跑的12345678910function add(x,y) &#123; return x + y;&#125;console.log(add(3,4));let myAdd = function (x,y) &#123; return x + y;&#125;console.log(myAdd(5,6)); 函数类型为函数定义类型 这个其实在前面的例子里面已经遇到过了。不过还是要练一下 升级上一个例子 写入参数类型和返回类型后还是运行没问题的12345678910function add(x: number,y: number): number &#123; return x + y;&#125;console.log(add(3,4));let myAdd = function (x: number,y: number): number &#123; return x + y;&#125;console.log(myAdd(5,6)); 书写完整函数类型 简单来说就是吧整个函数的参数和返回类型在声明时就指定声明好 函数类型包含两部分：参数类型和返回值类型。 当写出完整函数类型的时候，这两部分都是需要的。 我们以参数列表的形式写出参数类型，为每个参数指定一个名字和类型 参数名称只是为了易读性，名字可以不用一样 12345// 1.let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;;// 参数名不同版本let myAdd: (baseValue: number, increment: number) =&gt; number = function(x: number, y: number): number &#123; return x + y; &#125;; 当我第一次看到这样写的时候我也是比较疑惑，前面的参数声明我是知道的 但是那个箭头指向我就不是很懂，大概猜是返回值类型的指定 不太确定着么办呢？想知道是不是那我改变一下它的属性不就知道了 我就改变了声明为字符串，我们来看看升级版 12let myAdd: (x: number, y: number) =&gt; String = function(x: number, y: number): String &#123; return (x + y) &gt; 10 ? "true" : "false"; &#125;;console.log(myAdd(5,6)); // true 这样来看我的理解是对的，确实是用了指定返回值类型的 后面看到官网也有写解释 第二部分是返回值类型。 对于返回值，我们在函数和返回值类型之前使用( =&gt;)符号，使之清晰明了。 如之前提到的，返回值类型是函数类型的必要部分，如果函数没有返回任何值，你也必须指定返回值类型为 void而不能留空。 如果使用外部的变量是不用在构建函数的时候声明的 推断类型 其实是ts自身的识别 当你前面声明并赋值的时候，编译器会自动识别出类型意思就是说不写类型也可以 官网说这叫 直接上例子一看就懂123456// myAdd has the full function typelet myAdd = function(x: number, y: number): number &#123; return x + y; &#125;;// The parameters `x` and `y` have the type numberlet myAdd: (baseValue: number, increment: number) =&gt; number = function(x, y) &#123; return x + y; &#125;; 可选参数和默认参数参数 这个可选类型我们前面也是学过的那看看例子 其实就是说设定的参数和传入的参数必须一致，对一个不可以少一个不可以 这个和js不一样，这个写了多少就是多少1234567function buildName(firstName: string, lastName: string) &#123; return firstName + " " + lastName;&#125;let result1 = buildName("Bob"); // error, too few parameterslet result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result3 = buildName("Bob", "Adams"); // ah, just right 可选参数 可选参数呢就是可以输入也可以不输入的 定义了的可以少写，不传入默认值就是undefined 当是还是不可以多输入多输入还是会报错的 假如想前面的这个数为可选参数呢，那就把它放在第二位 因为可选参数必须跟在必须输入参数的后面，之前我就遇到过这样的错误 当时还不知道是为什么现在终于明白了12345678910function buildName(firstName: string, lastName?: string) &#123; if (lastName) return firstName + " " + lastName; else return firstName;&#125;let result1 = buildName("Bob"); // works correctly nowlet result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result3 = buildName("Bob", "Adams"); // ah, just right 默认值 当我们可选参数不输入是默认是undefined 那我们可以去改变它的默认值，很简单就是在参数后面加入 传入的是undefined的时候也是会启动这个默认值的12345678function buildName(firstName: string, lastName = "Smith") &#123; return firstName + " " + lastName;&#125;let result1 = buildName("Bob"); // works correctly now, returns "Bob Smith"let result2 = buildName("Bob", undefined); // still works, also returns "Bob Smith"let result3 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result4 = buildName("Bob", "Adams"); // ah, just right 这样看起来 默认参数和可选参数其实是共享的 默认的参数其实就是可选的参数啊，可选的参数也带有默认参数啊 这样就可以解决我们想把可选参数放在前面的问题 我在前面放入默认参数不就是相当于变成了可选参数 启动的时候输入undefined就可以了 果然是个很不错的方法，不过既然这样为啥我不直接放在后面呢哈哈哈12345678function buildName(firstName = "Will", lastName: string) &#123; return firstName + " " + lastName;&#125;let result1 = buildName("Bob"); // 默认参数位于默认参数前面这样是调用不到默认参数的let result2 = buildName("Bob", "Adams", "Sr."); // error, too many parameterslet result3 = buildName("Bob", "Adams"); // okay and returns "Bob Adams"let result4 = buildName(undefined, "Adams"); // okay and returns "Will Adams" 剩余参数 必要参数，默认参数和可选参数有个共同点：它们表示某一个参数。 有时，你想同时操作多个参数，或者你并不知道会有多少参数传递进来。 在JavaScript里，你可以使用 arguments来访问所有传入的参数。 在TypeScript里，你可以把所有参数收集到一个变量里 这个…其实就是es6的语法学过的都应该懂得 然后使用数组方法合并返回，不错的方法 12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + " " + restOfName.join(" ");&#125;let employeeName = buildName("Joseph", "Samuel", "Lucas", "MacKinzie"); 剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 编译器创建参数数组，名字是你在省略号（ …）后面给定的名字，你可以在函数体内使用这个数组。 官网还给出了函数类型定义时的用法12345function buildName(firstName: string, ...restOfName: string[]) &#123; return firstName + " " + restOfName.join(" ");&#125;let buildNameFun: (fname: string, ...rest: string[]) =&gt; string = buildName; This （重点） 学习如何在JavaScript里正确使用this就好比一场成年礼。 由于TypeScript是JavaScript的超集，TypeScript程序员也需要弄清 this工作机制并且当有bug的时候能够找出错误所在。 幸运的是，TypeScript能通知你错误地使用了 this的地方。（挺认可的） this 和尖头函数js this JavaScript里，this的值在函数被调用的时候才会指定。 这是个既强大又灵活的特点，但是你需要花点时间弄清楚函数调用的上下文是什么。 但众所周知，这不是一件很简单的事，尤其是在返回一个函数或将函数当做参数传递的时候。 在js里面 this 是一个很麻烦的家伙，没有理解好会引起很多bug 1234567891011121314151617let deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), createCardPicker: function() &#123; return function() &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();console.log("card: " + pickedCard.card + " of " + pickedCard.suit); 可以看到createCardPicker是个函数，并且它又返回了一个函数。 如果我们尝试运行这个程序，会发现它并没有输出结果而是报错了。 因为 createCardPicker返回的函数里的this被设置成了window而不是deck对象。 因为我们只是独立的调用了 cardPicker()。 顶级的非方法式调用会将 this视为window。 （注意：在严格模式下， this为undefined而不是window）。 解决上面的问题 熟悉Es6语法的应该会想到箭头函数，因为箭头函数可以绑定this，而不是使用时的this 为了解决这个问题，我们可以在函数被返回时就绑好正确的this。 这样的话，无论之后怎么使用它，都会引用绑定的‘deck’对象。 我们需要改变函数表达式来使用ECMAScript 6箭头语法。 箭头函数能保存函数创建时的 this值，而不是调用时的值： 这个真的完美的解决了问题 其实箭头函数是绑定当时自身最高级的父类为this（个人理解）123456789101112131415161718let deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), createCardPicker: function() &#123; // NOTE: the line below is now an arrow function, allowing us to capture 'this' right here return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();console.log("card: " + pickedCard.card + " of " + pickedCard.suit);// card: 11 of hearts 除了es6的箭头函数我们也可以使用bind来绑定this的指向 现在我们就绑定为deck也就是我们的对象123456789101112131415161718let deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), createCardPicker: function() &#123; let picker = function() &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; return picker.bind(deck) &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();console.log("card: " + pickedCard.card + " of " + pickedCard.suit); this 参数 不幸的是，this.suits[pickedSuit]的类型依旧为any。 这是因为 this来自对象字面量里的函数表达式。 修改的方法是，提供一个显式的 this参数。 this参数是个假的参数，（这个我没有所以看不出是不是）123function f(this: void) &#123; // make sure `this` is unusable in this standalone function&#125; 让我们往例子里添加一些接口，Card 和 Deck，让类型重用能够变得清晰简单些： 这个例子对于我这个初学者来说有点绕要花点时间理解 为什么在里面的this指定Deck呢，其实就是这一步指定的声明 把这个声明放入到函数里面 使得this执行的参数类型被指定123456789101112131415161718192021222324252627interface Card &#123; suit: string; card: number;&#125;interface Deck &#123; suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;&#125;let deck: Deck = &#123; suits: ["hearts", "spades", "clubs", "diamonds"], cards: Array(52), // NOTE: The function now explicitly specifies that its callee must be of type Deck createCardPicker: function(this: Deck) &#123; return () =&gt; &#123; let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;; &#125; &#125;&#125;let cardPicker = deck.createCardPicker();let pickedCard = cardPicker();alert("card: " + pickedCard.card + " of " + pickedCard.suit); 现在TypeScript知道createCardPicker期望在某个Deck对象上调用。 也就是说 this是Deck类型的，而非any，因此–noImplicitThis不会报错了。（官网说的我不知道着么去证实） this参数在回调函数里 (这个有点不太好理解，死磕了好久) 你可以也看到过在回调函数里的this报错，当你将一个函数传递到某个库函数里稍后会被调用时。 因为当回调被调用的时候，它们会被当成一个普通函数调用， this将为undefined。 稍做改动，你就可以通过 this参数来避免错误。 首先，库函数的作者要指定 this的类型 这个暂时无法实现的，只是学习原理123interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125; 指定了this类型后，你显式声明onClickBad必须在Handler的实例上调用。 然后TypeScript会检测到 addClickListener要求函数带有this: void12345678910111213141516171819202122232425interface UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void;&#125;// UIElementd的类class UIButton implements UIElement &#123; addClickListener(onclick: (this: void, e: Event) =&gt; void): void &#123; let event = new Event("click", &#123;"bubbles":true, "cancelable":false&#125;) onclick(event) &#125;&#125;class Handler &#123; info: string; onClickBad(this: Handler, e: Event) &#123; // oops, used this here. using this callback would crash at runtime this.info = "Bad Clicked"; &#125; onClickGood(this:void,e:Event) &#123; console.log("Good Clicked") &#125;&#125;let h = new Handler();let uiElement: UIElement = new UIButton();uiElement.addClickListener(h.onClickGood); 修复错误123456789class Handler &#123; info: string; onClickGood(this: void, e: Event) &#123; // can't use this here because it's of type void! console.log('clicked!'); &#125;&#125;let h = new Handler();uiElement.addClickListener(h.onClickGood); 因为onClickGood指定了this类型为void，因此传递addClickListener是合法的。 当然了，这也意味着不能使用 this.info. 如果你两者都想要，你不得不使用箭头函数了： 1234class Handler &#123; info: string; onClickGood = (e: Event) =&gt; &#123; this.info = e.message &#125;&#125; 这是可行的因为箭头函数不会捕获this，所以你总是可以把它们传给期望this: void的函数。 缺点是每个 Handler对象都会创建一个箭头函数。 另一方面，方法只会被创建一次，添加到 Handler的原型链上。 它们在不同 Handler对象间是共享的。 重载 JavaScript本身是个动态语言。 JavaScript里函数根据传入不同的参数而返回不同类型的数据是很常见的。 这样的写法在我们平时也是会经常遇到的12345678910111213141516171819202122let suits = ["hearts", "spades", "clubs", "diamonds"];function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == "object") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == "number") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: "diamonds", card: 2 &#125;, &#123; suit: "spades", card: 10 &#125;, &#123; suit: "hearts", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];console.log("card: " + pickedCard1.card + " of " + pickedCard1.suit);let pickedCard2 = pickCard(15);console.log("card: " + pickedCard2.card + " of " + pickedCard2.suit); pickCard方法根据传入参数的不同会返回两种不同的类型。 如果传入的是代表纸牌的对象，函数作用是从中抓一张牌。 如果用户想抓牌，我们告诉他抓到了什么牌。 但是这怎么在类型系统里表示呢。 方法是为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 下面我们来重载 pickCard函数。 学习多版本的控制123456789101112131415161718192021222324let suits = ["hearts", "spades", "clubs", "diamonds"];function pickCard(x: &#123;suit: string; card: number; &#125;[]): number;function pickCard(x: number): &#123;suit: string; card: number; &#125;;function pickCard(x): any &#123; // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == "object") &#123; let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; &#125; // Otherwise just let them pick the card else if (typeof x == "number") &#123; let pickedSuit = Math.floor(x / 13); return &#123; suit: suits[pickedSuit], card: x % 13 &#125;; &#125;&#125;let myDeck = [&#123; suit: "diamonds", card: 2 &#125;, &#123; suit: "spades", card: 10 &#125;, &#123; suit: "hearts", card: 4 &#125;];let pickedCard1 = myDeck[pickCard(myDeck)];console.log("card: " + pickedCard1.card + " of " + pickedCard1.suit);let pickedCard2 = pickCard(15);console.log("card: " + pickedCard2.card + " of " + pickedCard2.suit); 这样改变后，重载的pickCard函数在调用的时候会进行正确的类型检查。 为了让编译器能够选择正确的检查类型，它与JavaScript里的处理流程相似。 它查找重载列表，尝试使用第一个重载定义。 如果匹配的话就使用这个。 因此，在定义重载的时候，一定要把最精确的定义放在最前面。 注意，function pickCard(x): any并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard会产生错误。 后记 这个就是我学习Ts的第五天的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[色表/色彩搭配网址大全]]></title>
    <url>%2F2019%2F03%2F18%2F%E9%A2%9C%E8%89%B2%E6%90%9C%E9%9B%86%2F</url>
    <content type="text"><![CDATA[十六进制色表1:https://blog.csdn.net/jockerscolor/article/details/69255346十六进制色表2:https://blog.csdn.net/binglan520/article/details/56288524十六进制颜色码表图:https://encycolorpedia.cn/颜色渐变:https://uigradients.com/#Snapchat色彩搭配:https://www.webdesignrankings.com/resources/lolcolors/]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>色彩搭配</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今日份实战笔记]]></title>
    <url>%2F2019%2F03%2F17%2F2019-03-17%2F</url>
    <content type="text"><![CDATA[前言 小程序课程表的一些需求 实现它所用到的一些知识 实现方案的决择 数组的截取/对象的对比/时间的封装/随机函数的运用 记录动态生成颜色 随机颜色生成有两种方法，一种是写一个数组把颜色放进去随机输出，另外一种就是用js动态生成 在数量不能控制时选择第二个 但是生成的颜色不好控制，有些不好看，最后我还是选择了方法一js实现随机生成颜色 这个是本来想做一个课程表课程的变色 先看看收集了几个封装好的js函数 我比较喜欢方法3123456789101112131415161718192021//颜色对象,方法1 rgbafunction Color()&#123; this.r = Math.floor(Math.random()*255); this.g = Math.floor(Math.random()*255); this.b = Math.floor(Math.random()*255); this.color = 'rgba('+ this.r +','+ this.g +','+ this.b +',0.8)';&#125;// 方法2 十六进制// arguments这个在es5开始不能用了var getRandomColor = function()&#123; return '#' + (function(color)&#123; return (color += '0123456789abcdef'[Math.floor(Math.random()*16)]) &amp;&amp; (color.length == 6) ? color : arguments.callee(color); &#125;)(''); &#125; // 方法3 还是十六进制var getRandomColor = function()&#123; return '#'+('00000'+ (Math.random()*0x1000000&lt;&lt;0).toString(16)).substr(-6); &#125; 当我配置到小程序里面我发现我自己错了，并不是说方法不好是生成出来的颜色并不是很好看 数组法动态生成颜色/数组截取/随机数 平时都会用的比较多的Math数学方法，然而我还是不记得着么写随机数最后也是看js的案例 定义数组，随机获取，随机数，数组的截取，对象的比对，三目的运用1234567891011121314// 记录颜色匹配对象let colorObj = &#123;&#125;;// 颜色let orArrays = ["#FF3399", "#CC33FF", "#33CCFF", "#ff8936", "#00e500", "#1bd1a5", "#ff4e20", "#789262", "#70f3ff", "#c9dd22"];// 判断添加颜色,二维数组，使用两次foreachdCourse.forEach((e) =&gt; &#123; e.forEach((data) =&gt; &#123; if (data.sites != "") &#123; // 通过对象的判断，没有出现过的给一个随机颜色，相同的课程使用相同的颜色 // 这里使用了随机数也是用了数组的截取splice colorObj[data.name] ? data.Color = colorObj[data.name] : data.Color = colorObj[data.name] = orArrays.splice(Math.round(Math.random() * orArrays.length - 1), 1); &#125; &#125;)&#125;) 使用封装好的时间函数写业务 动态随机生成颜色每一次都替换，影响体验 所以把它固定起来给个限定时间 想要比对首先要把时间获取出来才好比对12345678910111213141516171819202122232425262728293031323334353637383940414243444546/*业务实现*/get () &#123; // 今天 let date = this.GetDateStr(0) // 缓存期限 let time = wx.getStorageSync("d_time") // 判断第一次和过期清空颜色对象和过期时间 if (time == "" || time &lt; date) &#123; let d_time = this.GetDateStr(6) wx.setStorageSync("colorObj", &#123;&#125;) wx.setStorageSync("d_time", d_time) &#125; // 记录颜色匹配对象，获取缓存中的数据 let colorObj = wx.getStorageSync("colorObj"); // 判断添加颜色 dCourse.forEach((e) =&gt; &#123; e.forEach((data) =&gt; &#123; if (data.sites != "") &#123; colorObj[data.name] ? data.Color = colorObj[data.name] : data.Color = colorObj[data.name] = orArrays.splice(Math.round(Math.random() * orArrays.length - 1), 1); &#125; &#125;) &#125;) // 最后无论改没改都更新一下数据，也可以实在只要过期更新 wx.setStorageSync("colorObj", colorObj);&#125;, /** * 时间封装 * @param: * AddDayCount &#123;Number&#125; 天数 -1为昨日 0为今日 1为明日 以此类推 * return y-m-d */ GetDateStr (AddDayCount) &#123; var dd = new Date(); dd.setDate(dd.getDate() + AddDayCount);//获取AddDayCount天后的日期 var y = dd.getFullYear(); var m = dd.getMonth() + 1;//获取当前月份的日期 var d = dd.getDate(); return y + "-" + m + "-" + d; &#125; 后记 这就是我今天的实战笔记，欢迎添加微信qq交流学习 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决朋友问的拖拽文件后拖拽图片无法显示]]></title>
    <url>%2F2019%2F03%2F17%2Fh5%E5%A4%9A%E6%AC%A1%E6%8B%96%E6%8B%BD%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[前言 这是一个朋友的作业，做一个图片与文件拖拽显示页面的案例 主要问题是拖了文字后再拖拽图片报错无法显示 bug ko之旅错误排查 （看报错） 知道有报错我们就直接操作拖文本再拖图片 果然出现了错误，具体看图片： 查看结构（证实经验论证） 代码排查 （找出错误源） 打开代码先找到文本的代码，因为是文本后出错的 为什么不是看img的操作先，因为连续的图片赋值是没有问题 是在文件后才会出错，所以查看一下文本的操作 解决方案 本来是想直接改变文本的赋值的，但是想到还是需要覆盖所有的内容所以我改变了 选择改变img的赋值那一段 解决1 清空div内容，创建添加节点 解决2 对第一版的升级 个人觉得这样可以提升性能 避免每一次都操作dom创建节点 后记 这就是我对h5案例编写报错的查看、排查、解决，或许我这个不是最优的办法你的比我更好，欢迎添加微信qq交流学习 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 学习笔记 组件/用法/绑定（学校课程）]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%A4%A7%E4%BA%8C%E4%B8%8BAndroid%20%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前言 案例存放地:https://github.com/YHF7/Android 使用的软件是 Android Studio 组件Button/TextView id text 文本 textSize 大小 dp 为单位 background 背景色1234567&lt;Button android:id="@+id/btn1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="30dp" android:background="#00f" android:text="2"/&gt; EditText 文本字段 这个用法和上面的都是一样 这里输入文字是用hint不是text 不过可以使用inputType属性控制 123456&lt;EditText android:id="@+id/edit1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:hint="请输入密码" android:inputType="textPassword"/&gt; AutoCompleteTextView 自动提示 用法基本相同 completionHint 默认显示 completionThreshold 最少输入多少个字开始搜索1234567&lt;AutoCompleteTextView android:id="@+id/act" android:layout_width="150dp" android:layout_height="wrap_content" android:completionHint="请输入搜索内容" android:completionThreshold="1" /&gt; 绑定组件属性控制 （app/src/main/java/com.example.yhf.tablelayout/TableLayout）后面那一段就很的项目名有关联了 每一个项目里面都会有一个控制这个程序的 我们现在来吧上面几个定义的组件给他绑定一下 123456789101112131415161718192021222324252627282930313233343536373839404142public class TableLayout extends AppCompatActivity &#123; // 1. 声明控件对象 最好是和自己定义的id相同 TextView text1; EditText edit1; AutoCompleteTextView act; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); // 这个也很关键，这个表示设置拿一个视图文件 // 我这个就是app/src/main/res/layout.dem03.xml // R为res，省去了前面的部分 setContentView(R.layout.demo03); //2. 通过id建立关系 // 组件名通过id搜索 R里面的id名为text1 // R说的就是res text1=(TextView)findViewById(R.id.text1); edit1=(EditText)findViewById(R.id.edit1); act=(AutoCompleteTextView)findViewById(R.id.act); // 定义一个数组 String[] data = new String[]&#123;"China","Chiness","Check"&#125;; // 遍历到这个组件里面 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_1,data); // 最后添加到id里面 act.setAdapter(adapter);// edit1.setText("我是输入的数据"); // 测试输出用的 Log.i("abc", "onCreate: dddd"); // 改变text1的文本，背景色，字体大小 text1.setText("你个菜逼"); text1.setTextColor(Color.CYAN); text1.setTextSize(30); &#125;&#125; CheckBox复选框 CheckBox和Button一样，也是一种古老的控件，它的优点在于，不用用户去填写具体的信息，只需轻轻点击，缺点在于只有“是”和“否”两种情况， Checked属性是CheckBox最重要的属性之一，改变它的方式有三种：1、XML中申明 2、代码动态改变 3、用户触摸1234567&lt;CheckBox android:id="@+id/cb" android:layout_width="wrap_content" android:layout_height="wrap_content" android:checked="false" android:text="已婚" /&gt; 它的改变将会触发OnCheckedChange事件，而您可以对应的使用OnCheckedChangeListener监听器来监听这个事件，1234567891011//获取CheckBox实例CheckBox cb = (CheckBox)this.findViewById(R.id.cb);//绑定监听器cb.setOnCheckedChangeListener(new OnCheckedChangeListener() &#123; @Override public void onCheckedChanged(CompoundButton arg0, boolean arg1) &#123; // TODO Auto-generated method stub Toast.makeText(MyActivity.this, "选中了":"取消了选中" , Toast.LENGTH_LONG).show(); &#125; &#125;); 选择显示小案例 页面 控制 效果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Js回顾 温故而知新 可以为师矣]]></title>
    <url>%2F2019%2F03%2F16%2F%E5%9B%9E%E9%A1%BEjs%2F</url>
    <content type="text"><![CDATA[前言 每一次的回头从会看到不同的东西 不同的体会，更加深入的理解 先看看 定时器延时每一秒输出一个数字0-4 （看到别人的公众号发过） setTimeout 是一个延时执行的定时器（异步） 在var中使用，因为作用域相同所以最后赋值都是一样 let的好处体现 闭包 async await （异步中使用同步方法） 1234567891011121314// 错误用例// 计算机的执行速度是非常快的，延时1秒早全部执行完了// var 作用域相同，循环完后i的值为6，最后才输出所以为6for (var i = 0; i &lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(new Date,i) &#125;, 1000);&#125;// 执行结果2019-03-15T07:18:30.917Z 52019-03-15T07:18:30.921Z 52019-03-15T07:18:30.922Z 52019-03-15T07:18:30.922Z 52019-03-15T07:18:30.922Z 5 解决1 熟悉es6的都知道 let是个好东西 只要把var改let这个问题就解决了 因为let的i每一次都会生成一个作用域相隔开1234567891011for (let i = 0; i &lt; 5; i++) &#123; setTimeout(() =&gt; &#123; console.log(new Date,i) &#125;, 1000);&#125;// 执行结果2019-03-15T07:19:21.106Z 02019-03-15T07:19:21.110Z 12019-03-15T07:19:21.111Z 22019-03-15T07:19:21.111Z 32019-03-15T07:19:21.111Z 4 解决2 熟悉闭包的同学 这个也不是问题 每一次作为数据传进来不就可以了这也是一个不错的方法12345678910111213for (var i = 0; i &lt; 5; i++) &#123; (j =&gt; &#123; setTimeout(() =&gt; &#123; console.log(j); &#125;, 1000); &#125;)(i)&#125;// 执行结果2019-03-15T07:21:58.003Z 02019-03-15T07:21:58.007Z 12019-03-15T07:21:58.007Z 22019-03-15T07:21:58.007Z 32019-03-15T07:21:58.007Z 4 看看上面好像真的成功的但是再看看输出的时间其实还是未能实现每一秒输出一个，所有的数据都是在同一时间被执行出来，那能不能解决呢？看看下一个方法解决3 Es7 async await 实现同步（把异步的定时器限制住）123456789101112131415161718192021const sleep = (timeountMS) =&gt; new Promise((resolve) =&gt; &#123; setTimeout(resolve, timeountMS);&#125;); (async () =&gt; &#123; // 声明即执行的 async 函数表达式 for (var i = 0; i &lt; 5; i++) &#123; // await 同步操作阻止了要等待 await sleep(1000); console.log(new Date, i); &#125; await sleep(1000); console.log(new Date, i);&#125;)();// 执行结果2019-03-15T07:23:21.193Z 02019-03-15T07:23:22.198Z 12019-03-15T07:23:23.202Z 22019-03-15T07:23:24.207Z 32019-03-15T07:23:25.207Z 42019-03-15T07:23:26.208Z 5 数组去重复 （每一次看别人写的都比自己写的好学习起来） 三目运算符运用 forEach concat 数组合并 …arr es6解构123456789101112131415161718192021// 多数组合并去重复test = (arr, ...arr2) =&gt; &#123; // 先是合并数组 let array = arr.concat(...arr2); // 定义一个对象存储 let obj = &#123;&#125; // 新数组 let result = [] // 循环遍历 array.forEach(item =&gt; &#123; // 三目运算符 判断是对象中存有，没有就吧值设为真 并且添加如数组 // 这里为什么要是为真呢，如果出现数据是false的时候依然使用数据去存储这样就会出现问题了 obj[item] ? '' : (obj[item] = true) &amp;&amp; result.push(item) &#125;) return result&#125;let sum = test([1, 2, 3], [5, 6,2, 3], [4, 5,6, 2])console.log(sum);// 输出结果[ 1, 2, 3, 5, 6, 4 ] Es6版 set Map 随着 ES6 的到来，去重的方法又有了进展，比如我们可以使用 Set 和 Map 数据结构，以 Set 为例，ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值 set 123456789101112131415var array = [1, 2, 1, 1, '1'];function unique(array) &#123; return Array.from(new Set(array));&#125;console.log(unique(array)); // [1, 2, "1"]// 再次简化function unique(array) &#123; return [...new Set(array)];&#125;// 再简化var unique = (a) =&gt; [...new Set(a)] Map 1234function unique (arr) &#123; const seen = new Map() return arr.filter((a) =&gt; !seen.has(a) &amp;&amp; seen.set(a, 1))&#125; Promise 异步/回调地狱/async awaitPromise promise里面包含两个参数res,rej我喜欢用简写,一个是成功回调一个是失败回调 所以在我们调用时也是要输入两个回调函数的，一个成功执行，一个失败执行12345678910111213141516171819202122// 定义promisey异步函数const sleep = (test) =&gt; new Promise((res,rej) =&gt; &#123; if (test == 1) &#123; res('成功') &#125; else if (test == 0) &#123; res('再次成功') &#125; else &#123; rej('失败了兄弟') &#125;&#125;)// 使用// 调用传入参数 .then中有可以写入两个函数前面为成功的调用后面为失败时的调用// 和上面是一一对应的// 前面的参数等于 test 后面...thensleep(1).then((data) =&gt; &#123; console.log(data); // 成功时获取到的数据&#125;, (err) =&gt; &#123; console.log(err); // 错误时获取到的错误返回&#125;)// 输出结果成功 Promise 回调地狱 很多时候我们都想在这个执行完毕后再去执行另外一个操作 在不影响后面的操作时，我们想到了使用Promise 异步 但是我们还不满足我们想在这个操作执行完毕再去执行另外一个操作 这个时候我们就会一个套一个的函数去写，这样就会似得代码非常的繁琐 Promise中实现回调地狱解决这个问题 升级上面这个回调方法，实现回调地狱 在.then的后面再加.then方法就可以了 可以无限的去套用 虽然每个都有err但是只是输出报错没有去处理，回调地狱还是会往下走 后面的都会出错12345678910sleep(1).then((data) =&gt; &#123; console.log(data); // 成功时获取到的数据 return sleep(2) // 再次的执行异步函数&#125;, (err) =&gt; &#123; console.log(err); // 错误时获取到的错误返回&#125;).then((data)=&gt; &#123; // 继续用.then接受 console.log(data) // 再次成功&#125;,(err) =&gt; &#123; console.log(err)&#125;) catch属性解决你一切烦恼也不需要写那么多次err的错误处理 catch 的作用： 如果前面有任何的 Promise 执行失败，则立即终止所有 promise 的执行，并 马上进入 catch 去处理 Promise中 抛出的异常；12345678sleep(1).then((data) =&gt; &#123; console.log(data); // 成功时获取到的数据 return sleep(2) // 再次的执行异步函数&#125;).then((data)=&gt; &#123; // 继续用.then接受 console.log(data) // 再次成功&#125;).catch((err) =&gt; &#123;&#125;) async/await （axios封装调用中很常使用） 其实在我们很多的前端业务请求时也是使用的异步操作 例如我们前端在请求后端api时，这个过程我们需要作为一个异步去操作不影响其他业务的操作 但是这个作为异步，可是数据总不是异步把所以数据得同步的获取 es7就帮了我们很大的忙,因为await起到同步阻挡的作用12345678var test = async() =&gt; &#123; // 声明即执行的 async 函数表达式 let abc = await sleep(1);// 都是异步操作唯独到这里被卡住了，要等待数据的返回才会去执行后面 console.log(abc); console.log('这个永远不会在前面');&#125;test()console.log('这个百分之99的机会都是在前面，还有那个一估计是内存卡了'); 判断是否是一个数组(最近刚用过) Array.isArray 这个是我在做项目的时候想要判断是否是数组的时候上网查到的方法（数据过滤），用起来挺方便的 返回值是boolean12const arr=[1,2,3];Array.isArray(arr) // 是返回 true 不是返回false instanceof 在网上好像说这个不太严谨，忘记了是什么了找不到那个文章12345var isArray = function(obj) &#123; return obj instanceof Array;&#125;;var arr = '[&#123; id: 1 &#125;]';console.log(isArray(arr)); 对象/数组互转对象转数组 只取内容加入数组 123456var arr = []for (let i in obj) &#123; arr.push(obj[i]); //属性 //arr.push(obj[i]); //值&#125;console.log(arr); // [ 5, 8, 4, 6 ] 拆分为多个对象存入数组 1234567var arr = []for (let i in obj) &#123; let o = &#123;&#125;; o[i] = obj[i]; arr.push(o)&#125;console.log(arr); // [ &#123; '未完成': 5 &#125;, &#123; '已完成': 8 &#125;, &#123; '待确认': 4 &#125;, &#123; '已取消': 6 &#125; ] 数组转对象1234567let obj = &#123;&#125;;let arr = ["d", 'b', 'c']for (const key in arr) &#123; obj[key] = arr[key]&#125;console.log(obj) 数组的升序和降序 这个挺有意思的很多算法题里面都会用到，一开始我还不懂这个啥意思哎 sort 排序,再升入我就不是很会了 要实现排序必须要有的条件就是要实现排序函数先 如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。若 a 等于 b，则返回 0。若 a 大于 b，则返回一个大于 0 的值。 12345678// 升序： var arr=[5,6,7,91,2,1]; arr.sort(function(a,b)&#123;return a-b&#125;); // 排序函数 console.log(arr);//[1, 2, 5, 6, 7, 91]// 降序: var arr=[5,6,7,91,2,1]; arr.sort(function(a,b)&#123;return b-a&#125;); console.log(arr);//[91, 7, 6, 5, 2, 1] 说了排序就看看冒泡排序/快速排序冒泡排序 声明一个done作为表示判断，这个也是我看别人写才想到的 主要是用来在对比没有任何一次遍历时位置的更改，说明排序已经结束了无需在做后面的排序123456789101112131415161718192021var arr = [3, 4, 1, 2];function bubbleSort (arr) &#123; var max = arr.length - 1; for (var j = 0; j &lt; max; j++) &#123; // 声明一个变量，作为标志位 var done = true; for (var i = 0; i &lt; max - j; i++) &#123; if (arr[i] &gt; arr[i + 1]) &#123; var temp = arr[i]; arr[i] = arr[i + 1]; arr[i + 1] = temp; done = false; &#125; &#125; if (done) &#123; break; &#125; &#125; return arr;&#125;console.log(bubbleSort(arr)); 快速排序 这里面有递归的思想，然而我用断点去看把自己都绕进去了12345678910111213141516171819202122var quickSort = function(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right));&#125;;var aa = quickSort([3, 2, 5, 77, 32, 3, 1, 3, 4, 5, 2, 3])console.log(aa); 上面出现了递归，就看看递归吧第一个递归 递归:函数中调用函数自己,此时就是递归,递归一定要有结束的条件123456789101112131415161718var i = 0;function f1() &#123; i++; if (i &lt; 5) &#123; // 限制小于5都会再执行一次f1函数 f1(); &#125; console.log("从前有个山,山里有个庙,庙里有个和尚给小和尚讲故事:");&#125;f1();// 输出结果 从前有个山,山里有个庙,庙里有个和尚给小和尚讲故事:从前有个山,山里有个庙,庙里有个和尚给小和尚讲故事:从前有个山,山里有个庙,庙里有个和尚给小和尚讲故事:从前有个山,山里有个庙,庙里有个和尚给小和尚讲故事:从前有个山,山里有个庙,庙里有个和尚给小和尚讲故事: 来个小案例让你知道递归的厉害 （看了这个再回头看上面的快速排序你就和觉得开窍了很多） 递归实现：n个数字的和，5 计算 1+2+3+4+5 12345678910111213141516171819202122232425262728293031//函数的声明function getSum(x) &#123; // 判断条件就是在这只要到1就停止返回1 if (x == 1) &#123; return 1; &#125; // 每一次都是自身 + 函数调用小于自身的1 return x + getSum(x - 1);&#125;//函数的调用console.log(getSum(5));/*** 执行过程:* 代码执行getSum(5)---&gt;进入函数,此时的x是5,执行的是5+getSum(4),此时代码等待* 此时5+getSum(4),代码先不进行计算,先执行getSum(4),进入函数,执行的是4+getSum(3),等待, 先执行的是getSum(3),进入函数,执行3+getSum(2),等待,先执行getSum(2),进入函数,执行 2+getSum(1);等待, 先执行getSum(1),执行的是x==1的判断,return 1,所以,* 此时getSum(1)的结果是1,开始向外走出去* 2+getSum(1) 此时的结果是:2+1* 执行:* getSum(2)----&gt;2+1* 3+getSum(2) 此时的结果是3+2+1* 4+getSum(3) 此时的结果是4+3+2+1* 5+getSum(4) 此时的结果是5+4+3+2+1** 结果:15**** */ 求一个数字各个位数上的数字的和: 123 —&gt;6 —1+2+3 12345678function getEverySum(x) &#123; if(x&lt;10)&#123; return x; &#125; //获取的是这个数字的个位数 然后下一次的时候除去 return x%10+getEverySum(parseInt(x/10)); &#125; console.log(getEverySum(1364)); 求斐波那契数列 1234567function getFib(x) &#123; if(x==1||x==2)&#123; return 1 &#125; return getFib(x-1)+getFib(x-2); &#125; console.log(getFib(12));]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用过的响应式解决方案+网络看到的不错的移动+pc的笔记（网络摘录）]]></title>
    <url>%2F2019%2F03%2F14%2FCss%E5%93%8D%E5%BA%94%E5%BC%8F%2B%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[flex布局学习： https://www.runoob.com/w3cnote/flex-grammar.html Css 移动端响应式解决方案 vh，vw，em，px，百分比 vh,vw 没用过 em和rem差不多 百分比也是一个不错的解决方便 并没有完美的解决方案，只能说在该使用的地方去使用对的解决方法达到最好的效果 下面说两个我用过的1. 知道并用过感觉挺好的一个 js控制配合rem 这个是我在github上面看到的一个vue+vuex的练习项目中下载写了学习时发现的 感觉这个方法挺不错的，js的控制动态切换窗口大小都能切换 配合上rem的适配感觉是一个很棒的响应式的解决方法 js（把js封装在config中在min.js引入就好了方便快捷）,自调用获取dom更改html font-size123456789101112(function(doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function() &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 320) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); rem (vue项目中设置Scss) ios：6.1系统以上都支持 android：2.1系统以上都支持 根据网页的根元素来设置字体大小，和em（font size of the element）的区别是，em是根据其父元素的字体大小来设置，而rem是根据网页的跟元素（html）来设置字体大小的 默认 font-size是16px123456789/* 默认16px */html &#123; font-size:16px;&#125;/* 我们试试把p标签设置为12px的字体大小 */p &#123; font-size: 0.75rem; /* 12/16=0.75 rem */&#125; 进阶 如果利用rem来设置css的值，一般要通过一层计算才行，比如如果要设置一个长宽为100px的div，那么就需要计算出100px对应的rem值是 100 / 16 =6.25rem，这在我们写css中，其实算比较繁琐的一步操作了。 这两个方法我都没有去使用，只是知道可以这么去改变 对于没有使用scss的工程：为了方便起见，可以将html的font-size设置成100px，这样在写单位时，直接将数值除以100在加上rem的单位就可以了 对于使用scss的工程：前端构建中，完全可以利用scss来解决这个问题，例如我们可以写一个scss的function px2rem即： 123456789/* 设置定义 */@function px2rem($px)&#123; $rem : 37.5px; @return ($px/$rem) + rem;&#125;/*使用时*/height: px2rem(90px);width: px2rem(90px);; 2. 媒体查询 改变 font-size 这个挺麻烦的考虑很多 相比我更喜欢使用rem+js12345678910111213html &#123; font-size: 15px &#125;/* html &#123; font-size: 4.7vw; /* rem(root element)配合vw(viewport width) */ &#125; */@media only screen and (min-width:320PX) and (max-width:359PX) &#123; html &#123; font-size: 15px &#125;.....等&#125; 网上摘录的方法移动端准备工作写法123456789101112131415161718192021222324252627282930313233&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge，chrome=1"&gt;&lt;!-- 设置在苹果手机上以应用模式启动时，是否全屏 --&gt;&lt;meta name='apple-touch-fullscreen' content='yes'&gt;&lt;!-- ios 系统 作用未知 --&gt;&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;&lt;!-- iso 系统 作用未知 --&gt;&lt;meta content="fullscreen=yes,preventMove=no" name="ML-Config"&gt;&lt;!-- iso 系统 作用未知 --&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black" /&gt; &lt;!-- 是否识别 手机号码、 电子邮件 地址 等--&gt; &lt;meta name="format-detection" content="telephone=no,email=no,address=no" /&gt;&lt;!-- 让360双核浏览器用webkit内核渲染页面 --&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;!-- 避免IE使用兼容模式 --&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; 允许全屏模式浏览,隐藏浏览器导航栏--&gt;&lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;&lt;!--微信缓存--&gt; &lt;meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" /&gt; &lt;meta http-equiv="Pragma" content="no-cache" /&gt; &lt;meta http-equiv="Expires" content="0" /&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; pc端准备工作12345678910&lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge，chrome=1"&gt;&lt;!-- 让360双核浏览器用webkit内核渲染页面 --&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;!--[if lt IE 9]&gt; &lt;script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"&gt;&lt;/script&gt; &lt;script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; base.css公共样式pc端1234567891011121314151617181920212223242526272829303132333435363738body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, abbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp, small, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu, nav, section, summary, time, mark, audio, video &#123; margin:0;padding:0；border: 0;&#125;ol,li,ul,dl,dt,dd&#123;list-style:none;&#125;table&#123;border-collapse:collapse;border-spacing:0&#125;h1,h2,h3,h4,h5,h6,i,strong &#123;font-weight: normal;&#125; img &#123;vertical-align: middle;border: none;width: 100%;&#125; i &#123;font: inherit;&#125; a &#123;color: #fff;text-decoration: none;-webkit-tap-highlight-color: rgba(0, 0, 0, 0); background-color:transparent;&#125;a:hover &#123;text-decoration: underline; outline: none;&#125; select::-ms-expand &#123; display: none; &#125; a:active,a:hover&#123;outline:0&#125;.clearfix::before,.clearfix::after&#123; content: ''; display: block; height: 0; line-height: 0; visibility: hidden; clear: both;&#125;.fl&#123; float:left;&#125;.fr&#123;float:right;&#125;input,select,option&#123;vertical-align:middle;border-radius:0px;-moz-appearance:none;-webkit-appearance:none;appearance:none;-webkit-tap-highlight-color: rgba(0, 0, 0, 0);outline: none;&#125;input[type="text"],input[type="button"],input[type="submit"],input[type="reset"]&#123;-webkit-appearance: none;appearance: none;border-radius: 0;outline: none;&#125; .overflow &#123;overflow:hidden; &#125; base.css公共样式移动端123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111body, div, span, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, abbr, address, cite, code, del, dfn, em, img, ins, kbd, q, samp, small, strong, sub, sup, var, b, i, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, figcaption, figure, footer, header, hgroup, menu, nav, section, summary, time, mark, audio, video &#123; margin:0;padding:0&#125;ol,li,ul,dl,dt,dd&#123;list-style:none;&#125;.fl &#123;float: left;&#125; .fr &#123;float: right;&#125; table&#123;border-collapse:collapse;border-spacing:0&#125;html &#123; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; /* 解决IOS默认滑动很卡的情况 */ -webkit-overflow-scrolling : touch; &#125; /* 禁止缩放表单 */ input[type="submit"], input[type="reset"], input[type="button"], input &#123; resize: none; border: none; &#125; /* 取消链接高亮 */ body, div, ul, li, ol, h1, h2, h3, h4, h5, h6, input, textarea, select, p, dl, dt, dd, a, img, button, form, table, th, tr, td, tbody, article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; -webkit-tap-highlight-color: rgba(0, 0, 0, 0); &#125; /* 设置HTML5元素为块 */ article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block; &#125; /* 图片自适应 */ img &#123; width: 100%; height: auto; width: auto\9; /* ie8 */ -ms-interpolation-mode: bicubic;/*为了照顾ie图片缩放失真*/ &#125; em, i &#123; font-style: normal; &#125; textarea &#123; resize:none; /*禁用了文本的拖拉，尤其在谷歌下*/ &#125; p &#123; word-wrap:break-word; /* 不够的单词自动换行 而不会被截掉 */ &#125; .clearfix:after &#123; content: ""; display: block; visibility: hidden; height: 0; clear: both; &#125; .clearfix &#123; zoom: 1; &#125; a &#123; text-decoration: none; color: #fff; font-family: 'Microsoft YaHei', Tahoma, Arial, sans-serif; &#125; a:hover &#123; text-decoration: none; outline: none;&#125; h1, h2, h3, h4, h5, h6 &#123; font-size: 100%; font-family: 'Microsoft YaHei'; &#125; img &#123; border: none; &#125; input&#123; font-family: 'Microsoft YaHei'; &#125; /*单行溢出*/ .one-txt-cut&#123; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; &#125; /*多行溢出 手机端使用*/ .txt-cut&#123; overflow : hidden; text-overflow: ellipsis; display: -webkit-box; /* -webkit-line-clamp: 2; */ -webkit-box-orient: vertical; &#125; /* 移动端点击a链接出现蓝色背景问题解决 */ a:link,a:active,a:visited,a:hover &#123; background: none; -webkit-tap-highlight-color: rgba(0,0,0,0); -webkit-tap-highlight-color: transparent; &#125; .overflow &#123;overflow:hidden; &#125;.w50&#123; width: 50%; &#125; .w25&#123; width: 25%; &#125; .w20&#123; width: 20%; &#125; .w33&#123; width: 33.333333%; &#125; 移动端布局使用方法rem (他这个和我那个差不多)第一种：js控制html字体大小， js代码放在head里面 html设置初始font-size：320px的字体大小 123456789101112131415 var html = document.getElementsByTagName('html')[0];if(html)&#123; var w = window.innerWidth; var fontSize = (w&gt;640?640:w)/640 *30; 这里最少30， html.style.fontSize = fontSize + 'px';&#125;window.onload = function()&#123; window.onresize = function()&#123; var w = window.innerWidth; console.log(w); var fontSize = (w&gt;640?640:w)/640 * 30;这里最少30， html.style.fontSize = fontSize + 'px'; &#125;&#125; 第二种：js控制html字体大小常用 ，js代码放在head里面 html设置初始font-size：320px的字体大小 1234567891011121314151617181920212223(function(doc, win) &#123; var docEl = doc.documentElement; var resizeEvt = 'orientationchange' in window ? 'orientationchange': 'resize'; var recalc = function() &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = (clientWidth&gt;640?640:clientWidth)/ 320 *20 + 'px'; &#125;; // 不同浏览器resize事件处理机制不同 // 使用定时器延迟处理resize回调函数以降低重复响应 var recalcTimer = null; var delaycalc = function() &#123; win.clearTimeout(recalcTimer); recalcTimer = win.setTimeout(recalc, 100); &#125;; // 移动端不需要考虑事件注册函数的兼容性 if (!doc.addEventListener) return; win.addEventListener(resizeEvt, delaycalc, false); // DOMContentLoaded事件只在DOM文档树加载完毕触发，此处不用延迟处理 doc.addEventListener('DOMContentLoaded', recalc, false); &#125;)(document, window); 第三种：用媒体查询控制html字体大小（这种也是我用过的看看他着么说）一：字体大小为15px开始 常用1234567891011121314151617181920212223242526272829303132333435363738394041424344454647html &#123; font-size: 15px &#125;html &#123; font-size: 4.7vw; /* rem(root element)配合vw(viewport width) */ &#125;@media only screen and (min-width:320PX) and (max-width:359PX) &#123; html &#123; font-size: 15px &#125;&#125;@media only screen and (min-width:360PX) and (max-width:374PX) &#123; html &#123; font-size: 16.875px &#125;&#125;@media only screen and (min-width:375PX) and (max-width:389PX) &#123; html &#123; font-size: 17.5781px &#125;&#125;@media only screen and (min-width:390PX) and (max-width:400PX) &#123; html &#123; font-size: 18.75px &#125;&#125;@media only screen and (min-width:401PX) and (max-width:414PX) &#123; html &#123; font-size: 19.4063px &#125;&#125;@media only screen and (min-width:415PX) and (max-width:640PX) &#123; html &#123; font-size:22.5px &#125;&#125;@media screen and (min-width:641PX) &#123; html &#123; font-size: 30px &#125;&#125; 二：字体大小为13.65px 不常用12345678910111213141516171819202122232425262728293031323334353637383940414243444546html &#123; font-size: 4.2vw; /* rem(root element)配合vw(viewport width) */ &#125; html &#123; font-size: 13.65px &#125; @media only screen and (min-width:320PX) and (max-width:360PX) &#123; html &#123; font-size: 13.65px &#125; &#125; @media only screen and (min-width:360PX) and (max-width:375PX) &#123; html &#123; font-size: 15.36px &#125; &#125; @media only screen and (min-width:375PX) and (max-width:390PX) &#123; html &#123; font-size: 16px &#125; &#125; @media only screen and (min-width:390PX) and (max-width:414PX) &#123; html &#123; font-size: 16.64px &#125; &#125; @media only screen and (min-width:414PX) and (max-width:460PX) &#123; html &#123; font-size: 17.664px &#125; &#125; @media only screen and (min-width:460PX) and (max-width:640PX) &#123; html &#123; font-size: 20px &#125; &#125; @media screen and (min-width:640PX) &#123; html &#123; font-size: 27.31px &#125; &#125; 移动端布局用flex和自动缩放 新旧版本兼容：这里设置flex容器为.box，子元素为.item Flex 布局1234567.box&#123; display: -ms-flexbox; display: -webkit-flex; display: flex; display: -webkit-box; display: -moz-box; &#125; 旧版：display：box新版：display：flex 定义主轴的方向 水平方向 1234567.box&#123; -moz-flex-direction: row; -webkit-flex-direction: row; flex-direction: row; -webkit-box-direction: normal; -webkit-box-orient: horizontal; &#125; 垂直方向 1234567.box&#123; -moz-flex-direction: column; -webkit-flex-direction: column; flex-direction: column; -webkit-box-direction: normal; -webkit-box-orient: vertical;&#125; 旧版：box-direction: normal 水平方向 | reverse 垂直方向 | inherit ，跟子元素的方向一致; 定义子元素的显示方向。 box-orient: horizontal 水平排列| vertical 垂直排列| inline-axis 默认 | block-axis 快方式排列 | inherit继承父元素; 定义子元素是否应水平或垂直排列。 这两种要同时设置才能确定排列方式； 水平方向：box-direction: normal；box-orient: horizontal 垂直方向：box-direction: normal； box-orient:vertical 新版：flex-direction：row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 子元素主轴对齐方式123456.box&#123; -moz-justify-content: center; -webkit-justify-content: center; justify-content: center; -webkit-box-pack: center;&#125; 旧版： box-pack: start | end | center | justify; 注意：兼容写法新版语法的space-around是不可用的 新版：justify-content：flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 子元素交叉轴对齐方式123456.box&#123; -moz-align-items: center; -webkit-align-items: center; align-items: center; -webkit-box-align: center; &#125; 旧版： box-align: start | end | center | baseline | stretch; 新版：align-items：flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 子元素属性：子元素在水平或者垂直方向占几分123456.item&#123; -moz-flex: 1; -webkit-flex: 1; flex: 1; -webkit-box-flex: 1.0;&#125; 旧版：box-flex：1.0浮点数字新版：flex：1 数字 超出要不要换行 不兼容，就是兼容了也无效 要求换行1234.box&#123; flex-wrap:wrap; box-lines: multiple; &#125; 旧版： box-lines: single默认不允许 | multiple 允许; 新版：flex-wrap: nowrap 不换行 wrap 换行，第一行在上方 wrap-reverse 换行，第一行在下方 新版的其他语法 行内元素也可以定义flex语法：不常用 1234.box&#123; display: -webkit-inline-flex; display: inline-flex;&#125;： 父元素属性align-content属性 定义在多跟抽线的对齐方式，一般是换行以后的对齐方式，只有一条抽线改属性不生效，常用在换行以后有间距的问题：设置align-content：flex-start； 不常用 align-content：flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 子元素属性flex，是flex-grow, flex-shrink 和 flex-basis的简写，一般只定义子元素占多少份，常用 子元素属性flex-grow 定义子元素占一行的多少份，值为数字 不常用 05、子元素属性flex-basis属性 定义了在分配多余空间之前，项目占据的主轴空间 像素单位和百分比，默认auto 子元素属性flex-shrink属性 定义了子元素的缩小比例，如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值无效 子元素属性order属性 定义子元素的排列方式，数值越小，越靠前排列，数字 子元素属性align-self属性 定义允许单个项目有与其他项目不一样的对齐方式，会覆盖algin-items属性 不常用 align-self: auto 默认 表示继承父元素 flex-start 与交叉轴的起点对齐。 flex-end 与交叉轴的终点对齐。 center 与交叉轴的中点对齐 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 兼容无效 justify-content: space-around 不能用 flex-wrap: wrap 不能用 flex兼容的标准写法1234-webkit-前缀标准版-moz-前缀标准版标准版-webkit-前缀09版 试例1234567.box&#123; display: -ms-flexbox; display: -webkit-flex; display: flex; display: -webkit-box; display: -moz-box; &#125; 新版的语法定义flex:123456789.box&#123; display: -webkit-flex; /*webkit*/ display: flex;&#125;/*行内flex*/.box&#123; display: -webkit-inline-flex; /*webkit*/ display:inline-flex;&#125; 父元素属性：12345678910111213141516171819.box&#123; flex-direction: row | row-reverse | column | column-reverse; /*主轴方向：左到右（默认） | 右到左 | 上到下 | 下到上*/ flex-wrap: nowrap | wrap | wrap-reverse; /*换行：不换行（默认） | 换行 | 换行并第一行在下方*/ flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; /*主轴方向和换行简写*/ justify-content: flex-start | flex-end | center | space-between | space-around; /*主轴对齐方式： 左对齐（默认） | 右对齐 | 居中对齐 | 两端对齐 | 平均分布*/ align-items: flex-start | flex-end | center | baseline | stretch; /*交叉轴对齐方式：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/ align-content: flex-start | flex-end | center | space-between | space-around | stretch; /*多主轴对齐：顶部对齐（默认） | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 上下平均分布*/&#125; 子元素属性：12345678910111213141516171819.item&#123; order: &lt;integer&gt;; number /*排序：数值越小，越排前，默认为0*/ flex-grow: &lt;number&gt;; /* default 0 */ /*放大：默认0（即如果有剩余空间也不放大，值为1则放大，2是1的双倍大小，以此类推）*/ flex-shrink: &lt;number&gt;; /* default 1 */ /*缩小：默认1（如果空间不足则会缩小，值为0不缩小）*/ flex-basis: &lt;length&gt; | auto; /* default auto */ /*固定大小：默认为0，可以设置px值，也可以设置百分比大小*/ flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ] /*flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto，*/ align-self: auto | flex-start | flex-end | center | baseline | stretch; /*单独对齐方式：自动（默认） | 顶部对齐 | 底部对齐 | 居中对齐 | 上下对齐并铺满 | 文本基线对齐*/&#125; 后记 前面是使用过的解决方案后面这些是网上摘录的一些方法，侵权立删 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记4 类]]></title>
    <url>%2F2019%2F03%2F10%2FTypeScript%E7%AC%94%E8%AE%B04%2F</url>
    <content type="text"><![CDATA[前言 自学TypeScript第四天 今天对学过java的很友好基本上都是后端的东西 介绍 传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。 类 类我们学过后端的话对这个就会非常的熟悉，类在后端是一个非常常用的属性，在es6开始js增加了类 这个添加对很多开发者来说算是一个福音 如果你使用过C#或Java，你会对这种语法非常熟悉。 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个 greet方法。 你会注意到，我们在引用任何一个类成员的时候都用了 this。 它表示我们访问的是类的成员。 最后一行，我们使用 new构造了 Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个 Greeter类型的新对象，并执行构造函数初始化它。 作为一个学过后端的人，我对这一个类感到非常熟悉也很容易上手 12345678910111213class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return "Hello, " + this.greeting; &#125;&#125;let greeter = new Greeter("world");console.log(greeter.greet()) 继承 继承也是很常见的 在TypeScript里，我们可以使用常用的面向对象模式。 基于类的程序设计中一种最基本的模式是允许使用继承来扩展现有的类。 很简单的说就是，儿子继承了爸爸的所有东西 12345678910111213141516class Animal &#123; move(distanceInMeters: number = 0) &#123; console.log(`Animal moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Dog extends Animal &#123; bark() &#123; console.log('Woof! Woof!'); &#125;&#125;const dog = new Dog();dog.bark();dog.move(10);dog.bark(); 这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自 Animal 基类，通过 extends关键字。 派生类通常被称作 子类，基类通常被称作 超类。 这个例子展示了一些上面没有提到的特性。 这一次，我们使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。 与前一个例子的不同点是，派生类包含了一个构造函数，它 必须调用 super()，它会执行基类的构造函数。 而且，在构造函数里访问 this的属性之前，我们 一定要调用 super()。 这个是TypeScript强制执行的一条重要规则。 这个例子演示了如何在子类里可以重写父类的方法。 Snake类和 Horse类都创建了 move方法，它们重写了从 Animal继承来的 move方法，使得 move方法根据不同的类而具有不同的功能。 注意，即使 tom被声明为 Animal类型，但因为它的值是 Horse，调用 tom.move(34)时，它会调用 Horse里重写的方法：1234567891011121314151617181920212223242526272829303132333435class Animal &#123; // 属性 name: string; // 构造函数 constructor(theName: string) &#123; this.name = theName; &#125; // 内部方法 move(distanceInMeters: number = 0) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;class Snake extends Animal &#123; // 构造函数，super调用父级构造函数 constructor(name: string) &#123; super(name); &#125; // 子类重写方法 move(distanceInMeters = 5) &#123; console.log("Slithering..."); // 内部调用了父级的方法 super.move(distanceInMeters); &#125;&#125;class Horse extends Animal &#123; constructor(name: string) &#123; super(name); &#125; move(distanceInMeters = 45) &#123; console.log("Galloping..."); super.move(distanceInMeters); &#125;&#125;let sam = new Snake("Sammy the Python");let tom: Animal = new Horse("Tommy the Palomino");sam.move();tom.move(34); 公共，私有与受保护的修饰符默认 public 公共类型 我以前学习java的时候这个属性的要写出来的 但是js给我们默认了12345678910111213141516class Animal &#123; public name: string; public constructor(theName: string) &#123; this.name = theName; &#125; public move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125;// 我们平时都是这么写的class Animal &#123; name: string; constructor(theName: string) &#123; this.name = theName; &#125; move(distanceInMeters: number) &#123; console.log(`$&#123;this.name&#125; moved $&#123;distanceInMeters&#125;m.`); &#125;&#125; 理解 private 私有化 private 就是私有化，简单点说就是唯独我有，你们虽都不可以用只可以我自己用 我自己拥有的连儿子都不可用唯独我自己可以用 12345678910111213141516171819class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;// 定义使用报错new Animal("Cat").name; // 错误: 'name' 是私有的.// 我们来试试在继承中能不能用，儿子继承父亲的东西class Test &#123; constructor(test: string) &#123; super(test) &#125; Test () &#123; console.log(this.name) // 注意了，这样也是错误的 &#125;&#125; 其实就是说不是同一个爸爸生出来的都不算有关系。 TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的 然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则 这个例子中有 Animal和 Rhino两个类， Rhino是 Animal类的子类。 还有一个 Employee类，其类型看上去与 Animal是相同的。 我们创建了几个这些类的实例，并相互赋值来看看会发生什么。 因为 Animal和 Rhino共享了来自 Animal里的私有成员定义 private name: string，因此它们是兼容的。 然而 Employee却不是这样。当把 Employee赋值给 Animal的时候，得到一个错误，说它们的类型不兼容。 尽管 Employee里也有一个私有成员 name，但它明显不是 Animal里面定义的那个。1234567891011121314151617181920class Animal &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;class Rhino extends Animal &#123; constructor() &#123; super("Rhino"); &#125;&#125;class Employee &#123; private name: string; constructor(theName: string) &#123; this.name = theName; &#125;&#125;let animal = new Animal("Goat");let rhino = new Rhino();let employee = new Employee("Bob");animal = rhino;animal = employee 理解 protected （比私有低一个级别） 和私有化几乎一模一样 这个属性比私有化低一个级别，儿子可以用了 在继承中还是可以使用的 属性12345678910111213141516171819202122232425// 这个例子比较经典class Person &#123; protected name: string; constructor(name: string) &#123; this.name = name; &#125;&#125;// 继承class Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name) this.department = department; &#125; public getElevatorPitch() &#123; // 继承类里面是可以使用父级的name的 return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee("Howard", "Sales");console.log(howard.getElevatorPitch());// 外面就不可用了console.log(howard.name); // 错误 构造函数也是可以被保护起来的 在外面是无法使用的哈哈哈，起到了很好的保护作用123456789101112131415161718192021class Person &#123; protected name: string; protected constructor(theName: string) &#123; this.name = theName; &#125;&#125;// Employee 能够继承 Personclass Employee extends Person &#123; private department: string; constructor(name: string, department: string) &#123; super(name); this.department = department; &#125; public getElevatorPitch() &#123; return `Hello, my name is $&#123;this.name&#125; and I work in $&#123;this.department&#125;.`; &#125;&#125;let howard = new Employee("Howard", "Sales");let john = new Person("John"); // 错误: 'Person' 的构造函数是被保护的. readonly修饰符 （只读） 你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化 说白了只能看看不能改变，一开始就定义好 就好像你妈打你只能挨着不能还手123456789class Octopus &#123; readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) &#123; this.name = theName; &#125;&#125;let dad = new Octopus("Man with the 8 strong legs");dad.name = "Man with the 3-piece suit"; // 错误! name 是只读的. 参数属性 参数的自带属性然我们可以减少一些写法 在上面的例子中，我们必须在Octopus类里定义一个只读成员 name和一个参数为 theName的构造函数，并且立刻将 theName的值赋给 name，这种情况经常会遇到。 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性： 参数属性通过给构造函数参数前面添加一个访问限定符来声明。 使用 private限定一个参数属性会声明并初始化一个私有成员；对于 public和 protected来说也是一样。1234567891011121314// 在这里可以验证，自读属性会自动初始化一个私有成员class Octopus &#123; readonly numberOfLegs: number = 8; constructor(readonly name: string) &#123; // 在这里可以得到证实 this.name = name; &#125; test () &#123; return this.name; &#125;&#125;let test1 = new Octopus('YHF');console.log(test1.test()); // YHF 存取器 （get/set，es5以上才可以用，编译会报错但是可以使用的） 这个get/set 写java的真的在熟悉不过了，这个是结合私有化属性使用的 私有化属性，就是通过get/set来限制学习 TypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问 注意：首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。12345678910111213141516171819202122232425262728293031323334353637// 版本1// 在这里面fullname可以随意更改，确实方便也带来了很多麻烦class Employee &#123; fullName: string;&#125;let employee = new Employee();employee.fullName = "Bob Smith";if (employee.fullName) &#123; console.log(employee.fullName);&#125;// 升级版，设置权限let passcode = "secret passcode";class Employee &#123; private _fullName: string; get fullName(): string &#123; return this._fullName; &#125; set fullName(newName: string) &#123; if (passcode &amp;&amp; passcode == "secret passcode") &#123; this._fullName = newName; &#125; else &#123; console.log("Error: Unauthorized update of employee!"); &#125; &#125;&#125;let employee = new Employee();employee.fullName = "Bob Smith";if (employee.fullName) &#123; alert(employee.fullName);&#125; 静态属性 类的静态属性，每一次调用都是直接通过类名去调用 哪里都可用的很广泛，无需实例，调用就是实例 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。123456789101112131415161718class Grid &#123; static origin = &#123;x: 0, y: 0&#125;; calculateDistanceFromOrigin(point: &#123;x: number; y: number;&#125;) &#123; let xDist = (point.x - Grid.origin.x); let yDist = (point.y - Grid.origin.y); return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; &#125; constructor (public scale: number) &#123; &#125;&#125;let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scale// 这个今天属性在外面页面可以用的console.log(Grid.origin)console.log(grid1.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;));console.log(grid2.calculateDistanceFromOrigin(&#123;x: 10, y: 10&#125;)); 抽象类 （和继承差不多） 又是一个后端的最爱 抽象类，就是只是写元素名，方法名，但继承了这个抽象类，并实例化里面但抽象方法 抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法 123456789101112131415161718192021222324252627282930313233343536373839// 抽象类abstract class Department &#123; constructor(public name: string) &#123; &#125; printName(): void &#123; console.log('Department name: ' + this.name); &#125; // 抽象方法 abstract printMeeting(): void; // 必须在派生类中实现&#125;// 继承抽象类class AccountingDepartment extends Department &#123; constructor() &#123; super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() &#125; printMeeting(): void &#123; console.log('The Accounting Department meets each Monday at 10am.'); &#125; generateReports(): void &#123; console.log('Generating accounting reports...'); &#125;&#125;// 声明一个抽象类但属性let department: Department; // 允许创建一个对抽象类型的引用// 抽象类是不可实例的department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();// 这个错误并不是因为不可以这样去写，只是声明但时候抽象类里面没有department.generateReports(); // 错误: 方法在声明的抽象类中不存在 高级技巧构造函数 当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西。 首先就是类的 实例的类型 这里，我们写了 let greeter: Greeter，意思是 Greeter类的实例的类型是 Greeter。 这对于用过其它面向对象语言的程序员来讲已经是老习惯了。 let Greeter将被赋值为构造函数。 当我们调用 new并执行了这个函数后，便会得到一个类的实例。 这个构造函数也包含了类的所有静态属性。 换个角度说，我们可以认为类具有 实例部分与 静态部分这两个部分。12345678910111213class Greeter &#123; greeting: string; constructor(message: string) &#123; this.greeting = message; &#125; greet() &#123; return "Hello, " + this.greeting; &#125;&#125;let greeter: Greeter;greeter = new Greeter("world");console.log(greeter.greet()); 这里会比较绕不过是解释构造函数 这个例子里， greeter1与之前看到的一样。 我们实例化 Greeter类，并使用这个对象。 与我们之前看到的一样。再之后，我们直接使用类。 我们创建了一个叫做 greeterMaker的变量。 这个变量保存了这个类或者说保存了类构造函数。 然后我们使用 typeof Greeter，意思是取Greeter类的类型，而不是实例的类型。 或者更确切的说，”告诉我 Greeter标识符的类型”，也就是构造函数的类型。 这个类型包含了类的所有静态成员和构造函数。 之后，就和前面一样，我们在 greeterMaker上使用 new，创建 Greeter的实例。12345678910111213141516171819202122class Greeter &#123; static standardGreeting = "Hello, there"; greeting: string; greet() &#123; if (this.greeting) &#123; return "Hello, " + this.greeting; &#125; else &#123; return Greeter.standardGreeting; &#125; &#125;&#125;let greeter1: Greeter;greeter1 = new Greeter();console.log(greeter1.greet());let greeterMaker: typeof Greeter = Greeter;greeterMaker.standardGreeting = "Hey there!";let greeter2: Greeter = new greeterMaker();console.log(greeter2.greet()); 把类当做接口使用 如上一节里所讲的，类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。12345678910class Point &#123; x: number; y: number;&#125;interface Point3d extends Point &#123; z: number;&#125;let point3d: Point3d = &#123;x: 1, y: 2, z: 3&#125;; 后记 这个就是我学习Ts的第四天的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记3 接口]]></title>
    <url>%2F2019%2F03%2F09%2FTypeScript%E7%AC%94%E8%AE%B03%2F</url>
    <content type="text"><![CDATA[前言 个人学习笔记，仅供参考 介绍 TypeScript的核心原则之一是对值所具有的结构进行类型检查。 它有时被称做“鸭式辨型法”或“结构性子类型化”。 在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 接口初探 类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 需要注意的是，我们传入的对象参数实际上会包含很多属性，但是编译器只会检查那些必需的属性是否存在，并且其类型是否匹配 不但要求传入参数还要求这个参数里面有一个名为label的string参数 如果没有把label这个必须传入的参数传入就会报错123456function printLabel(labelledObj: &#123; label: string &#125;) &#123; console.log(labelledObj.label);&#125;let myObj = &#123; size: 10, label: "Size 10 Object" &#125;;printLabel(myObj); 重写这个例子 类型检查器不会去检查属性的顺序，只要相应的属性存在并且类型也是对的就可以 interface 泛指接口12345678910111213// 接口 后面这个是名称// 定义一个名为LabelledValue的接口interface LabelledValue &#123; label: string;&#125;// 在接收参数时，作为指定类型引用function printLabel(labelledObj: LabelledValue) &#123; console.log(labelledObj.label);&#125;let myObj = &#123;size: 10, label: "Size 10 Object"&#125;;printLabel(myObj); 可选属性 这个可选属性我们在之前也有学过了 带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号 接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 可选属性在应用“option bags”模式时很常用，即给函数传入的参数对象中只有部分属性赋值了。 下面是应用了“option bags”的例子： 这里考到了两个知识点 可选属性的使用 返回类型的指定 重点： 可选参数 返回参数123456789101112131415161718192021// 接口 interface SquareConfig &#123; // 两个可选属性 color?: string; width?: number;&#125;// 函数参数调用接口，可不传参数，给空对象// 但是返回中，指定了必须返回 color 和area这两个属性function createSquare(config: SquareConfig): &#123;color: string; area: number&#125; &#123; let newSquare = &#123;color: "white", area: 100&#125;; if (config.color) &#123; newSquare.color = config.color; &#125; if (config.width) &#123; newSquare.area = config.width * config.width; &#125; return newSquare;&#125;let mySquare = createSquare(&#123;color: "black"&#125;); 只读属性 （readonly） 在Ts中更好的体现了，权限的控制 限制为只读属性 一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性1234567891011// 1. 定义一个接口，x变量设置为只读interface Point &#123; readonly x: number; readonly y: number;&#125;// 2. 构造出一个point的对象let p1: Point = &#123;x:10,y:20&#125;// 3.尝试改变内部的x值,会说这是个只读属性不能修改p1.x = 5;// err Cannot assign to 'x' because it is a read-only property. ReadonlyArray 只读数组 不要以为只有数据有，数组也是有的哦 ReadonlyArray 类型用于数组 一旦创建后无法更改，不能赋值，也不能赋值给别的数据123456let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! ReadonlyArray赋值到一个普通数组也是不可以的 但是有一种情况可以赋值给别人那就是使用类型断言重写 这样就是可以赋值的1let b = ro as number[]; readonly vs const 最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly 额外的属性检查额外检查错误 我们学会了可选属性知道了optionbages 模式的使用 但是把可选属性和传值结合在一起时会发出错误，就是在参数中加入指定类型以外的属性 ts中定义了类型指定后，会做额外的检查 虽然是可选属性但是还是报出错误,限制没有属性就会报错 TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误12345678910111213interface SquareConfig &#123; color?: string; width?: number;&#125;function createSquare(config: SquareConfig): &#123; color: string; area: number &#125; &#123; // ...&#125;// 注意传入的参数colour// error: 'colour' not expected in type 'SquareConfig'// 在指定类型中是没有的let mySquare = createSquare(&#123; colour: "red", width: 100 &#125;); 解决额外检查错误（绕开检查）解决方法一 （断言） 在传入参数时后面加入断言1let mySquare = createSquare(&#123; width: 100, opacity: 0.5 &#125; as SquareConfig); 解决方法二 （完美解法，添加一个字符串索引签名） 前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它 所以虽然是最完美的解决方法，但是要一开始就确立是否会带有 只要它们不是color和width，那么就无所谓它们的类型是什么。123456interface SquareConfig &#123; color?: string; width?: number; // 字符串索引签名 [propName: string]: any;&#125; 解决方法三 （耍赖皮,没有理解，我觉得这样是一个漏洞） 将这个对象赋值给一个另一个变量： 因为 squareOptions不会经过额外属性检查，所以编译器不会报错12let squareOptions = &#123; colour: "red", width: 100 &#125;;let mySquare = createSquare(squareOptions); 要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。 函数类型 接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型 为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。 其实和声明函数差不多，只是没有了前面的function和后面的业务 使用像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量1234567891011121314// 定义名为 SearchFunc 的接口interface SearchFunc &#123; // 定义参数为source，subString 都为string // 返回类型为boolean (source: String, subString: String) : boolean;&#125;// 使用接口let mySearch: SearchFunc = function (source: string, subString: string) &#123; let result = source.search(subString); return result &gt; -1;&#125;console.log(mySearch('aaabb','bb')) 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配 因为只是参数，传入时也无法判断12345let mySearch: SearchFunc;mySearch = function(src: string, sub: string): boolean &#123; let result = src.search(sub); return result &gt; -1;&#125; 函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配 定义时可以不写指定类型 但是传入和返回类型不匹配就会报错12345let mySearch: SearchFunc;mySearch = function(src, sub) &#123; let result = src.search(sub); return result &gt; -1;&#125; 可索引的类型数字索引(数组) 第一感觉这个索引是为数组而设立的 通过不同类型的值去索引 与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值12345678interface StringArray &#123; [index: number]: string;&#125;let myArray: StringArray;myArray = ["Bob", "Fred"];let myStr: string = myArray[0]; 字符串索引（对象） TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致12345678910111213// 错误class Animal &#123; name: string;&#125;class Dog extends Animal &#123; breed: string;&#125;// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!interface NotOkay &#123; [x: number]: Animal; [x: string]: Dog;&#125; 字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以123456789101112interface NumberDictionary &#123; [index: string]: number; length: number; // 可以，length是number类型 name: string // 错误，`name`的类型与索引类型返回值的类型不匹配&#125;let myArray: NumberDictionary;myArray = &#123;test1:100,length:20,test2:200&#125;;console.log(myArray.test1)console.log(myArray.test2)console.log(myArray.length) 防止索引被篡改 (只读) 最后，你可以将索引签名设置为只读，这样就防止了给索引赋值12345interface ReadonlyStringArray &#123; readonly [index: number]: string;&#125;let myArray: ReadonlyStringArray = ["Alice", "Bob"];myArray[2] = "Mallory"; // error! 类类型实现接口 与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。 其实就是java的抽象方法 定义了就必须去执行 接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 元素123456789// 实现元素interface ClockInterface &#123; currentTime: Date;&#125;class Clock implements ClockInterface &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125; 方法 你也可以在接口中描述一个方法，在类里实现它1234567891011121314151617interface ClockInterface &#123; currentTime: Date; setTime(d: Date); // constructor(d: Date) // 这个是不允许的构造函数是不允许这样被定义的&#125;class Clock implements ClockInterface &#123; currentTime: Date; setTime(d: Date) &#123; this.currentTime = d; return this.currentTime; &#125; constructor(h: number, m: number) &#123; &#125;&#125;let test = new Clock(10,20);console.log(test.setTime(new Date())); //2019-03-09T14:12:10.617Z 类静态部分与实例部分的区别 （令人费解的地方，未知） 这个地方不太好理解 当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误 因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内 因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名 这个直指类中的构造函数，就是在new时要传参，并有返回值 因为在类中是不会去检索构造函数，所以直接定义就会出错 所以我们在fn中传参数时定义，就会去检测构造函数签名 其实就是说作为参数和类是不想同的检索方式12345678910111213141516171819202122232425262728293031323334353637383940// 错误interface ClockConstructor &#123; new (hour: number, minute: number);&#125;class Clock implements ClockConstructor &#123; currentTime: Date; constructor(h: number, m: number) &#123; &#125;&#125;------------------------------// 正确interface ClockConstructor &#123; // 约束 new 一个实例，直接针对class的构造函数 new (hour: number, minute: number): ClockInterface;&#125;interface ClockInterface &#123; tick();&#125;function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface &#123; return new ctor(hour, minute);&#125;class DigitalClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log("beep beep"); &#125;&#125;class AnalogClock implements ClockInterface &#123; constructor(h: number, m: number) &#123; &#125; tick() &#123; console.log("tick tock"); &#125;&#125;let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32);console.log(digital.tick()) 继承接口 和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里 这个就比较好理解，就是儿子继承爸爸的东西 也可多接口123456789101112131415161718192021222324252627282930interface Shape &#123; color: string;&#125;interface Square extends Shape &#123; sideLength: number;&#125;// 定义let square = &lt;Square&gt;&#123;&#125;;square.color = "blue";square.sideLength = 10;// 多接口interface Shape &#123; color: string;&#125;interface PenStroke &#123; penWidth: number;&#125;interface Square extends Shape, PenStroke &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = "blue";square.sideLength = 10;square.penWidth = 5.0; 混合类型 一个对象可以同时做为函数和对象使用，并带有额外的属性 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 接口继承类 当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement） 当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系 123456789101112131415161718192021222324class Control &#123; private state: any;&#125;interface SelectableControl extends Control &#123; select(): void;&#125;class Button extends Control implements SelectableControl &#123; select() &#123; &#125;&#125;class TextBox extends Control &#123; select() &#123; &#125;&#125;// 错误：“Image”类型缺少“state”属性。class Image implements SelectableControl &#123; select() &#123; &#125;&#125;class Location &#123;&#125; 在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的 在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上， SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的 后记 这个就是我学习Ts的第三天的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记2 变量声明]]></title>
    <url>%2F2019%2F03%2F07%2FTypeScript%E7%AC%94%E8%AE%B02%2F</url>
    <content type="text"><![CDATA[前言 个人学习笔记，仅供参考 Var 声明 可以在函数内部定义变量 可以在其它函数内部访问相同的变量123456789101112131415function f() &#123; var a = 1; a = 2; var b = g(); a = 3; return b; function g() &#123; return a; &#125;&#125;f(); // returns 2 作用域规则 对于var声明奇怪的作用域规则 在这里以为程序在执行时会先编译一遍所以x就已经被声明了 可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问 12345678910function f(shouldInitialize: boolean) &#123; if (shouldInitialize) &#123; var x = 10; &#125; return x;&#125;f(true); // returns '10'f(false); // returns 'undefined' var多次声明并不会报错 1234567891011function sumMatrix(matrix: number[][]) &#123; var sum = 0; for (var i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (var i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 捕获变量怪异之处 setTimeout 定时器，而且每一次的时间就加长了 执行的速度是非常快的，很快就循环完毕开启了所有的定时器 但是定时器的执行会延时，在最后执行时i已经是10了 所以所有的输出都是10，并不是想象的1……9 123for (var i = 0; i &lt; 10; i++) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * i);&#125; 解决方案，使用闭包,每一次的值都是传进去的就不会被改变 1234567for (var i = 0; i &lt; 10; i++) &#123; // capture the current state of 'i' // by invoking a function with its current value (function(i) &#123; setTimeout(function() &#123; console.log(i); &#125;, 100 * i); &#125;)(i);&#125; Let声明 在let中和var还是有一定的区别的 let中使用的是作用域或块作用域 所有在区块内没有定义是不可以使用的 let并没有作用域提示的概念 块作用域 这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块 这就是我们提到的变量不会提升，所以不能使用 如果是用var这个就可以是用了 而且我们使用ts 在编译时就会报错的 直接会 error TS2304: Cannot find name ‘b’ 提示没有定义这个名称的变量 但是a为什么可以获取呢？因为a所在的作用域块大于if，而在外面的作用域是不能访问内部定义的变量123456789101112131415function f(input: boolean) &#123; let a = 100; // if内部定义的b if (input) &#123; // 但是在这里面是可以获取a的因为a在fn的作用域块比if大 // Still okay to reference 'a' let b = a + 1; return b; &#125; // 外面是无法访问的，就会报错 // Error: 'b' doesn't exist here return b;&#125; 暂时性死区 未声明前无法读/写 很多人对这个let不了解就想当然的像var一样去用 但是虽然变量存在，在let声明前所定义的所有代码都是无效的，因为let有着暂时性死区（声明前的所有区域都是） ts中编译也是会爆出来的12a++; // illegal to use 'a' before it's declared;let a; 注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。12345678910function foo() &#123; // okay to capture 'a' return a;&#125;// 不能在'a'被声明前调用'foo'// 运行时应该抛出错误foo();let a; 重定义及屏蔽重定义 我们在使用var 时可以无限的重复声明最后只会得到一个（会出现bug） let在同一作用域下是不可以重复声明的 并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。 并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。1234567891011121314151617181920212223242526272829303132333435363738394041424344// 例1let x = 10;let x = 20; // 错误，不能在1个作用域里多次声明`x`// 例2// 变量和声明明显在同一个作用域下function f(x) &#123; let x = 100; // error: interferes with parameter declaration&#125;// 例3// 无论let前后都不能重新定义变量function g() &#123; let x = 100; var x = 100; // error: can't have both declarations of 'x'&#125;// 例4// 正确的重定义// 这样就分开了两个完全不同的作用域// if内部只可以使用x = 5的这个和x=100一点关系都没有function g() &#123; let x = 100; console.log('fn g x',x) //fn g x 100 if (true) &#123; let x = 5; console.log('fn if x',x)//fn if x 5 &#125; console.log('fn g x',x)//fn g x 100&#125;// 例5// 正确的重定义function f(condition, x) &#123; if (condition) &#123; let x = 100; return x; &#125; return x;&#125;f(false, 0); // returns 0f(true, 0); // returns 100 屏蔽 在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误 使用let重写sumMatrix上面var写过的 在这里 在重新定义的数据，会出现一个数据屏蔽把前面定义的数据屏蔽掉 这样解决了数据不会相互影响的问题 123456789101112- function sumMatrix(matrix: number[][]) &#123; let sum = 0; for (let i = 0; i &lt; matrix.length; i++) &#123; var currentRow = matrix[i]; for (let i = 0; i &lt; currentRow.length; i++) &#123; sum += currentRow[i]; &#125; &#125; return sum;&#125; 块级作用域变量的获取 在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。 因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。 12345678910111213141516function theCityThatAlwaysSleeps() &#123; // fn作用域定义了 let getCity; if (true) &#123; let city = "Seattle"; // if内部赋值 getCity = function() &#123; // 在if作用域已经执行获取到了 return city; &#125; &#125; // 外侧依然是能访问 return getCity();&#125; 当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。 这样就可以理想的输出1-9了123for (let i = 0; i &lt; 10 ; i++) &#123; setTimeout(function() &#123;console.log(i); &#125;, 100 * i);&#125; const 声明 它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值 1234567891011121314151617181920const numLivesForCat = 9;const kitty = &#123; name: "Aurora", numLives: numLivesForCat,&#125;// 定义后，外层是无法被重新定义的// 可以使用但是无法重新在外层整体的去赋值// Errorkitty = &#123; name: "Danielle", numLives: numLivesForCat&#125;;// 但是使用这样的方式去更改内部的值是不受限制的// all "okay"kitty.name = "Rory";kitty.name = "Kitty";kitty.name = "Cat";kitty.numLives--; 解构【es6特性】数组解构 相当于使用了索引，但更为方便 你可以在数组里使用…语法创建剩余变量 可以解开单个 可以获取多个 可以跳过,隔开就可以12345678910111213141516171819202122232425262728293031// 1.数组使用let input = [1, 2];let [first, second] = input;console.log(first); // outputs 1console.log(second); // outputs 2// 相当于first = input[0];second = input[1];// 2.函数使用结构数组，传递一个数组解开两个变量function f([first, second]: [number, number]) &#123; console.log(first); console.log(second);&#125;f(input);// 3. 剩余变量let [first, ...rest] = [1, 2, 3, 4];console.log(first); // outputs 1console.log(rest); // outputs [ 2, 3, 4 ]// 4. 单独提取也可以let [first] = [1, 2, 3, 4];console.log(first); // outputs 1// 5. 获取其他元素,隔开let [, second, , fourth] = [1, 2, 3, 4]; 对象解构 和数组的没什么区别 同样不需要的可以直接忽略12345678910let o = &#123; a: "foo", b: 12, c: "bar"&#125;;let &#123; a, b &#125; = o;// 剩余变量let &#123; a, ...passthrough &#125; = o;let total = passthrough.b + passthrough.c.length; 属性重命名 在对象中结构我们可以赋于其他于属性不同的名字 这里就会有疑惑ts里面‘:’后面不是加的是指示类型么 如果你想指定它的类型， 仍然需要在其后写上完整的模式。 12345678910// 前面为属性名：后面为更改的属性名let &#123; a: newName1, b: newName2 &#125; = o;// 相等于let newName1 = o.a;let newName2 = o.b;//添加指示类型let &#123;a, b&#125;: &#123;a: string, b: number&#125; = o; 默认值 ? 可选属性 在指定类型前面加?号代表可以不传 在结构时用=给定默认值 默认值可以让你在属性为 undefined 时使用缺省值 12345678function keepWholeObject(wholeObject: &#123; a: string, b?: number &#125;) &#123; let &#123; a, b = 1001 &#125; = wholeObject;&#125;let wholeObject = &#123;a:'abc'&#125;console.log(keepWholeObject(wholeObject)) // a=abc b=1001 函数声明 解构也能用于函数声明。 看以下简单的情况1234type C = &#123; a: string, b?: number &#125;function f(&#123; a, b &#125;: C): void &#123; &#125; 可以使用结构的同时使用默认值 通常情况下更多的是指定默认值，解构默认值有些棘手。 首先，你需要在默认值之前设置其格式 官网的例子并不能实现123456function f(&#123; a="", b=0 &#125; : &#123;a?:String,b?:Number&#125;): void &#123; // ... console.log(a); console.log(b);&#125;f(&#123;&#125;); 展开 展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象 这样我们合并数组/对象就方便了很多 但是展开对，对象的缺陷还是有的 两个对象展开相同还是对象，相同的属性就会覆盖12345678// 合并数组let first = [1, 2];let second = [3, 4];let bothPlus = [0, ...first, ...second, 5];// 合并对象let defaults = &#123; food: "spicy", price: "$$", ambiance: "noisy" &#125;;let search = &#123; ...defaults, food: "rich" &#125;; 对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：123456789class C &#123; p = 12; m() &#123; &#125;&#125;let c = new C();let clone = &#123; ...c &#125;;clone.p; // okclone.m(); // error! 后记 这个就是我学习Ts的第二天的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 以上的个人遇到的知识积累]]></title>
    <url>%2F2019%2F03%2F07%2FES6%2B%E7%9A%84%E7%94%A8%E6%B3%95%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[… 数组/对象的扩展 在我一开始看到…后面带参数是我写vue中时使用vuex引入数据的时候使用的 在一开始我只是以为它只是vuex引入数据的写法 但是在我再次遇到的时候我对这个表示很疑惑，所以就问人 通过查阅资料和他人的告知我知道了这个是数组/对象的扩展是es6以上的知识 我就去查阅了es6+的资料并知道了是着么的一个东西 相当于把整个对象搬迁过来本地一样 对象 (分开放test.js) 1234567var test = &#123; test1 (e) &#123; console.log(e); &#125;&#125;export &#123;test&#125; 引入方法 1234567891011121314import &#123;test&#125; from './test.js'// 小程序中使用Page(&#123; // 函数的扩展 es6+ 等于new一个类 ...detailsTpl, test() &#123; // 在内部就可以直接用this来使用，相当于把整个函数搬迁过来了 this.test1('测试'); &#125;&#125;) for in/for of for of一直都没着么关注看到别人说是es6的语法改进了for in 的不足就去看看 这个of 呢不能用在对象哦，用在数组是可以的 这个of和foreach好像没啥区别啊….,官网说是用来代替foreach实例的12345678910111213141516171819let arr = ['a','b','c','d','e'];// 这个呢是用了做一个小实验arr.foo = "hello"// 先看看 数组的情况// of里面是不会输出上面的foo的for (const e of arr) &#123; console.log(e)&#125; // a,b,c,d,e// 看看foreach// foreach 这个也是一样的arr.forEach(item =&gt; &#123; console.log(item)&#125;)// a,b,c,d,e// 这个就不同的，它会输出foofor (const e in arr) &#123; console.log(e)&#125; // 0,1,2,3,4,foo 看看用在对象里面 对象是不可以使用的，直接报错123456789let object = &#123;'a':11,'b':22,'c':33&#125;// 先看看 数组的情况for (const e of object) &#123; console.log(e)&#125; // errorfor (const e in arr) &#123; console.log(e)&#125; // // a,b,c,d,e]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js复习笔记（学校课程）]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%A4%A7%E4%BA%8C%E4%B8%8Bjs%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[今天内容：1、js的内置对象2、js的函数3、js的事件4、js的BOM5、js的DOM 一、js的内置对象1、Number对象创建方式：“var myNum=new Number(value);var myNum=Number(value);”常用方法：toString():把数字转换为字符串，使用指定的基数。valueOf():返回一个 Number 对象的基本数字值。2、Boolean对象创建方式：“var bool = new Boolean(value);var bool = Boolean(value);”常用方法：toString():把逻辑值转换为字符串，并返回结果。valueOf():返回 Boolean 对象的原始值。 3、String对象创建方式：“var str = new String(s);var str = String(s);”属性：length:字符串的长度常用方法：indexOf():检索字符串。lastIndexOf():从后向前搜索字符串。split():把字符串分割为字符串数组。substring():提取字符串中两个指定的索引号之间的字符。包括头不包括尾substr():从起始索引号提取字符串中指定数目的字符。toUpperCase():把字符串转换为大写。valueOf():返回某个字符串对象的原始值。 4、Date对象创建方式：var myDate=new Date(); Date 对象会自动把当前日期和时间保存为其初始值。var myDate=new Date(毫秒值); 1970年1月1日到先目前的时间点的毫秒常见方法：getFullYear():从 Date 对象以四位数字返回年份。getMonth():从 Date 对象返回月份 (0 ~ 11)。getDate():从 Date 对象返回一个月中的某一天 (1 ~ 31)。getDay():从 Date 对象返回一周中的某一天 (0 ~ 6)。getTime():返回 1970 年 1 月 1 日至今的毫秒数。toString():把 Date 对象转换为字符串。toLocaleString():根据本地时间格式，把 Date 对象转换为字符串。 5、Math对象“Math 对象并不像 Date 和 String 那样是对象的类，因此没有构造函数 Math()，像 Math.sin() 这样的函数只是函数，不是某个对象的方法。您无需创建它，通过把 Math 作为对象使用就可以调用其所有属性和方法。” 常用的方法：ceil():对数进行上舍入。floor():对数进行下舍入。round():把数四舍五入为最接近的整数。random():返回 0 ~ 1 之间的随机数。 6、RegExp对象对象的方式：var reg = new RegExp(pattern);直接量语法：var reg = /pattern/;注意：正则规则一般是^开始 以$结束正则规则：[0-9]:代表0-9的数字[A-Z]:代表大写字母[a-z]:代表小写[A-z]:大小写都行\d：代表数字 \D:非数字\w:代表单词 \W:非单词{n}:n个{n,m}:n到m个n+:1次或多次n?:0次或一次n*:0次或多次 常用方法：test(待校验的字符串) 需求：校验一个邮箱：haohao_827@163.com 7、Array对象“var arr = new Array();var arr = new Array(size);var arr = new Array(element0, element1, …, elementn);var arr = [element0, element1, …, elementn];”属性：length:数组的长度常用方法：join();把数组的所有元素放入一个字符串。元素通过指定的分隔符进行分隔。pop():删除并返回数组的最后一个元素reverse():颠倒数组中元素的顺序。sort():对数组的元素进行排序 按照字典顺序排序 二、js的函数1、自定义函数(1) 普通函数语法：function 函数名称(参数列表){函数体} (2) 匿名函数语法：function(参数列表){函数体} (3) 对象函数语法：new Function(“参数1”，”参数2”，…”参数n”，”函数体”);注意：函数体必须写在最后，参数和函数体需要字符串的形式 参数列表:NaN:not a number 不是一个数字arguments对象：数组对象，负责收集实参 返回值：返回值不需要在定义函数的时候声明函数需要返回值只需在函数体中使用return进行返回，return后的代码不执行 2、js的全局函数(1) 编码和解码encodeURI():把字符串编码为 URI。decodeURI():解码某个编码的 URI。encodeURIcomponent():把为 URI 组件进行编码。decodeURIcomponent()：把为 URI 组件进行解码。escape():编码字符串unescape():解码字符串需求：对url进行编码 http://www.baidu.com?name=张&amp;pass=123区别：对一些特殊字符编码的范围不同http://www.baidu.com?name=%E5%BC%A0&amp;pass=123http%3A%2F%2Fwww.baidu.com%3Fname%3D%E5%BC%A0%26pass%3D123：适合编码提交的参数部分http%3A//www.baidu.com%3Fname%3D%u5F20%26pass%3D123：适合编码单独的字符串(2) 强制转换Boolean()String()Number()(3) 转成数字parseFloat():解析一个字符串并返回一个浮点数。parseInt():解析一个字符串并返回一个整数。(4) eval()函数把字符串作为脚本代码来执行。 三、js的事件事件、事件源、响应行为 1、常用事件onchange事件 onfocus()事件和onblur()事件 onmouseover事件和onmouseout事件onload事件2、事件与事件源的绑定方式(1) 事件与响应行为与事件源绑定(2)事件与事件源绑定 响应行为使用函数封装this关键字：代表本事件源对象(3) 事件、响应行为 与事件源完全分离3、阻止事件的默认行为W3C的标准：e.preventDefault()IE标准：window.event.returnValue = false;4、阻止事件的传播W3C的标准：e.stopPropagation();IE标准：window.event.cancelBubble = true;四、js的BOM1、window对象(1) 弹框的方法提示框：alert(确认信息);确认框：confirm(确认信息);存在返回值：如果点击确认返回true 点击取消 返回false输入框：prompt(输入提示信息)存在返回值：如果输入内容点击确认返回输入的内容 点击取消返回null(2) open()方法作用就是在js中使用此方法打开新页面 参数是url地址(3) 定时器方法指定的延时时间后执行一定行为setTimeout(函数对象，毫秒值) var timer = setInterval(函数对象，毫秒值)clearInterval(timer); 2、location对象location.href=”url路径”;location.href = “http://www.baidu.com&quot;; 需求：实现页面注册成功后的跳转主页技术：location.href+setInterval 3、history对象history.back();返回上一页history.forward():进入下一页history.go();跳转到哪一页 五、DOM对象document.getElementById(“id属性值”);document.getElementsByTagName(“标签名称”);document.getElementsByName(“name属性值”);innerHTML：获取某个元素中的html代码]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 学习笔记 布局/布局常用属性（学校课程）]]></title>
    <url>%2F2019%2F03%2F07%2F%E5%A4%A7%E4%BA%8C%E4%B8%8BAndroid%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前言 案例存放地:https://github.com/YHF7/Android 安卓几大布局记录 LinearLayout 线性布局布局排列方式 垂直布局 orientation = “vertical” 水平布局 orientation = “horizontal” 1234&lt;LinearLayout // 垂直布局 android:orientation="horizontal"&gt;&lt;/LinearLayout&gt; 大小格式 充满父类 match_parent 根据内容改变 wrap_content1234567&lt;LinearLayout // 设置宽高均为充满父类 android:layout_width="match_parent" android:layout_height="match_parent" // 垂直布局 android:orientation="horizontal"&gt;&lt;/LinearLayout&gt; 权重 android:layout_weight=”1” RelativeLayout 相对布局 是通过相对定位的方式让控件出现在布局任意位置； 在相对布局中如果不指定控件摆放的位置，那么控件都会被默认放在RelativeLayout的左上角。 因此要先指定第一个控件的位置，其他控件为该位置的相对位置； RelativeLayout属性： (使用相对布局属性需要先指定控件的id，其他控件根据该控件的id，来确定相对于该控件的相对位置) 第一个控件默认在布局左上角，如果指定放在第一个控件的左边或者上面，会看不到第二个控件 123456&lt;RelativeLayout // 设置宽高均为充满父类 android:layout_width="match_parent" android:layout_height="match_parent"&gt; ......&lt;/RelativeLayout&gt; 与兄弟控件的边缘对齐：（值为id）@id/android:layout_below 将该控件的上边缘对齐指定控件的下边缘android:layout_above 将该控件的下边缘对齐指定控件的上边缘android:layout_toLeftOf 将该控件的右边缘对齐指定控件的左边缘 android:layout_toRightOf 将该控件的左边缘对齐指定控件的右边缘android:layout_alignRight 将此控件的右边缘与给定ID的控件右边缘对齐。android:layout_alignLeft 将此控件的左边缘与给定ID的控件左边缘对齐。android:layout_alignTop 将此控件的上边缘与给定ID的控件上边缘对齐。android:layout_alignBottom 将此控件的底部边缘与给定ID的控件底部边缘对齐。 与父控件的边缘对齐： （属性值为true，false） （可以同时使用两个属性，如android:layout_alignParentRight ?android:layout_alignParentBottom 表示将该控件放到父控件的右下角）android:layout_alignParentLeft 将此控件的左边缘与父容器的左边缘匹配。android:layout_alignParentRight 将此控件的右边缘与父容器的右边缘匹配。android:layout_alignParentTop 将此控件的上边缘与父容器的上边缘匹配。android:layout_alignParentBottom 将此控件的底部边缘与父容器的底部边缘匹配。 对齐置父控件的中间： (属性值为true，false)android:layout_centerInParent 放置到父控件的正中间android:layout_centerHorizontal 放置到父控件的水平中间 android:layout_centerVertical 放置到父控件的垂直中间android:layout_alignStart 对齐置兄弟控件的起始位置android:layout_alignEnd 对齐置兄弟控件的末尾位置android:layout_alignParentStart 对齐置父控件的起始位置android:layout_alignParentEnd 对齐置父控件的末尾位置 基准线android:layout_alignBaseline 对齐基准线 (值为id） 控件之间的距离设置android:padding:指定控件中的内容与到此控件的四边缘的距离 android:layout_margin:设置此控件的四边缘与其他控件的距离android:paddingBottom:设置控件内容与控件下边缘的距离android:paddingTop:设置控件内容与控件上边缘的距离android:paddingLeft:设置控件内容与控件左边缘的距离 android:paddingRight:设置控件内容与控件右边缘的距离android:layout_marginBottom:设置此控件的下边缘与其他控件的距离android:layout_marginTop:设置此控件的上边缘与其他控件的距离android:layout_marginLeft:设置此控件的左边缘与其他控件的距离android:layout_marginRight:设置此控件的右边缘与其他控件的距离 FrameLayout 帧布局android:layout_gravity:控制位置android:foreground:设置改帧布局容器的前景图像android:foregroundGravity:设置前景图像显示的位置 TableLayout 表格布局 相信学过HTML的朋友都知道,我们可以通过&lt; table &gt;&lt; tr &gt;&lt; td &gt;就可以生成一个HTML的表格, 而Android中也允许我们使用表格的方式来排列组件,就是行与列的方式,就说我们这节的TableLayout! 但却不像我们后面会讲到的Android 4.0后引入的GridLayout(网格)布局一样,直接就可以设置多少行与多少列！ 如何确定行数与列数①如果我们直接往TableLayout中添加组件的话,那么这个组件将占满一行！！！②如果我们想一行上有多个组件的话,就要添加一个TableRow的容器,把组件都丢到里面！③tablerow中的组件个数就决定了该行有多少列,而列的宽度由该列中最宽的单元格决定④tablerow的layout_width属性,默认是fill_parent的,我们自己设置成其他的值也不会生效！！！ 但是layout_height默认是wrap_tencontent的,我们却可以自己设置大小！⑤整个表格布局的宽度取决于父容器的宽度(占满父容器本身)⑥有多少行就要自己数啦,一个tablerow一行,一个单独的组件也一行！多少列则是看tableRow中 的组件个数,组件最多的就是TableLayout的列数 三个常用属性android:collapseColumns:设置需要被隐藏的列的序号android:shrinkColumns:设置允许被收缩的列的列序号android:stretchColumns:设置运行被拉伸的列的列序号以上这三个属性的列号都是从0开始算的,比如shrinkColunmns = “2”,对应的是第三列！可以设置多个,用逗号隔开比如”0,2”除了这三个常用属性,还有两个属性,分别就是跳格子以及合并单元格,这和HTML中的Table类似:android:layout_column=”2”:表示的就是跳过第二个,直接显示到第三个格子处,从1开始算的!android:layout_span=”4”:表示合并4个单元格,也就说这个组件占4个单元格 GridLayout 网格矩阵布局 GridLayout布局是Android4.0（API Level 14）新引入的网格矩阵形式的布局控件。 属性android:columnCount说明：GridLayout的最大列数android:rowCount说明：GridLayout的最大行数android:orientation说明：GridLayout中子元素的布局方向。有以下取值：horizontal – 水平布局。 vertical – 竖直布局。android:layout_column说明：显示该子控件的列，例如android:layout_column=”0”,表示当前子控件显示在第1列，android:layout_column=”1”,表示当前子控件显示在第2列。android:layout_columnSpan说明：该控件所占的列数，例如android:layout_columnSpan=”2”,表示当前子控件占两列。 android:layout_row说明：显示该子控件的行，例如android:layout_row=”0”,表示当前子控件显示在第1行，android:layout_row=”1”,表示当前子控件显示在第2行。 android:layout_rowSpan说明：该控件所占的行数，例如android:layout_rowSpan=”2”,表示当前子控件占两行。 android:layout_columnWeight说明：该控件的列权重，与android:layout_weight类似，例如有GridLayout上两列，都设置android:layout_columnWeight = “1”,则两列各占GridLayout宽度的一半 android:layout_rowWeight说明：该控件的行权重，原理同android:layout_columnWeight。 平均分配格行/列的问题GridLayout在Android 5.1(API Level 21)时引入了android:layout_columnWeight和android:layout_rowWeight来解决平分问题，但是API21前怎么办呢？ 需要用到兼容包： 1.compile ‘com.android.support:gridlayout-v7:22.+’ 2.布局中使用android.support.v7.widget.GridLayout&lt;android.support.v7.widget.GridLayout…&lt;/android.support.v7.widget.GridLayout&gt; 3.使用app:layout_columnWeight 和app:layout_rowWeight 设置权重 后记 Android学习记录，老师笔记加自己的笔记 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序前端笔记]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[小程序中ES6类 在小程序中我们也是可以使用ES6的语法去是实现我们的业务逻辑 在ES6中新增了，类方法那我们就来一起用一样吧 实际与后端的类没有区别 创建类 123456789101112131415// class 构建一个类class Home&#123; // 类的构造函数 constructor () &#123; &#125; // 自定义的类内部方法 getBannerData () &#123; ... &#125;&#125;//外部想要使用这个类就需要向export抛出这个类export &#123;Home&#125;; 使用类 12345678910111213// 1.首先引入这个类 home-mode.js这个是我的类文件名import &#123;Home&#125; from 'home-model.js';// 2.实例化 home-model 的home类var home = new Home();// 3.调用Page(&#123; onLoad: function () &#123; // 调用方法 home.getBannerData(() =&gt; &#123; .... &#125;) &#125;&#125;) 小程序中ES6类继承12345678910111213141516171819// 1.引入类import &#123;Base&#125; from '../../utils/base.js'// 2.继承类class Home extends Base &#123; constructor () &#123; // 有构造函数的时候必须调用基类的构造函数 super(); &#125; // 3. 调用基类方法 getBannerData () &#123; // 直接this加方法名就可以了 this.request() &#125;&#125;export &#123;Home&#125;; requert请求封装 （如何使用上面说了） 在我们调用后端的api的时候我们会大量的去请求后端的Api，这样会使得我们前端的业务逻辑不断的重复 我们使用面向对象的方式对请求函数做了封装 这样我们代码的复用性更高，代码的重复性更少 封装这种复用性很高的函数时我们都要创建基类使得让其他的类去继承使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 1. utils/base.js 创建utils 新疆base基类文件// 2. 新建 config.js 用来储存公共数据或配置信息// 3. 引入配置类import &#123;Config&#125; from 'config.js'// 2. 创建基类Baseclass Base &#123; // 构造函数 constructor() &#123; // 获取配置在信息类的 公共url信息 this.baseRequestUrl = Config.restUrl; &#125; /** * 请求封装 */ request (params) &#123; // url内外拼接 var url = this.baseRequestUrl + params.url; // 判断没有传获取方式默认为get if (!params.type) &#123; params.type = 'GET' &#125; // 调用微信请求api wx.request(&#123; url: url, data: params.data, method: params.type, header: &#123; 'content-type':'application/json', 'token': wx.getStorageSync('token') &#125;, success: res =&gt; &#123; // 判断函数，存在才调用 // 返回信息的函数回调 params.sCallback&amp;&amp;params.sCallback(res.data); &#125;, fail: err =&gt; &#123; console.log(err); &#125; &#125;) &#125;&#125;export &#123;Base&#125;; 小程序自定义模版 在我们的页面开发中也会存在很多的页面会有复用 那我们定义一个模块模版就更容易让我们使用 创建模版 1234567// 模版// 为模版加name 唯一标示用来调用的时候用的，其实内部和写html没有区别&lt;template name="products"&gt; &lt;view class="products-box"&gt; &lt;/view&gt;&lt;/template&gt; 调用模版 12345678910&lt;!-- 引入模版文件 --&gt;&lt;import src="../tpls/products/products-tpl.wxml" /&gt;&lt;view&gt; &lt;!-- 使用模版和定义一样只是吧name改为is就可以了 --&gt; &lt;!-- data给模版传递数据 --&gt; &lt;!-- 做一个对象传递过去使用起来会方便一点，方法名自定义 --&gt; &lt;!-- key为products 传递的值为productsArr --&gt; &lt;template is="products" data="&#123;&#123;products:productsArr&#125;&#125;"&gt;&lt;/template&gt;&lt;/view&gt; 事件绑定、页面跳转、数据传输 小程序中的事件绑定就是 bindtap 后面带函数名 页面跳转 wx.navigateTo api调用 页面之间数据传输，可以同url传输 数据绑定，数据传输 12345678910&lt;swiper indicator-dots="true" autoplay="true" class="swiper"&gt; &lt;block wx:for="&#123;&#123;bannerArr&#125;&#125;" wx:key="index"&gt; &lt;!-- 事件绑定，bindtap绑定事件，后面带方法名就可以了 --&gt; &lt;!-- 数据传输 data-开头后面自定义名字 --&gt; &lt;!-- 没有为什么微信规定的反正就这么干 --&gt; &lt;swiper-item data-id="&#123;&#123;item.key_word&#125;&#125;" bindtap="onProductsItemTap"&gt; ..... &lt;/swiper-item&gt; &lt;/block&gt; &lt;/swiper&gt; 实现方法，跳转页面 12345678910111213141516171819202122Page(&#123; /** * banner点击事件 * event自带的变量 */ onProductsItemTap: function (event) &#123; // id，存放在event.currentTarget.dataset.id中 // 所有传过来的数据都在 event.currentTarget.dataset 中，传过来的时候是不带data的要记住 // 这里我做了一个小小的封装提高复用性，放在了基类中 //getDataSet(event,key) &#123; // return event.currentTarget.dataset[key]; //&#125; var id = home.getDataSet(event,"id"); // 调用接口 // url就是你要跳转页面的地址 // 可以通过url传送参数到页面中去 wx.navigateTo(&#123; url: '../product/product?id=' + id, &#125;); &#125;&#125;) 跳转的页面获取调整前传过来的数据 12345678910111213Page(&#123; /** * 生命周期函数--监听页面加载 * 就是在跳转后的页面js文件中， onload 里面获取 * options是自带的常量 */ onLoad: function (options) &#123; // 传的是命名什么就.什么 var id = options.id; console.log(id) &#125;&#125;) 动态修改导航栏 wx.setNavigationBarTitle123456789/** * 生命周期函数--监听页面初次渲染完成 */ onReady: function () &#123; // 动态设置导航栏 wx.setNavigationBarTitle(&#123; title: this.data.name &#125;) &#125; 拒绝频繁向服务器请求数据 在我们请求数据时使用对象保存起来 再次请求前判断以请求的不让请求直接再对象中获取 触底刷新123456/** * 页面拉到底部 */ onReachBottom: function () &#123; &#125; wx:key 官网 这个也是挺重要的，用来锁定属性 我们在微信中使用for循环时，如果我们使用创建添加数据后，可能会造成数据的村乱 可以自定义唯一表示也可以，使用本地的*this也是可以的 文字说不清楚直接来例子 12345678910&lt;switch wx:for="&#123;&#123;objectArray&#125;&#125;" wx:key="unique" style="display: block;"&gt; &#123;&#123;item.id&#125;&#125;&lt;/switch&gt;&lt;button bindtap="switch"&gt;Switch&lt;/button&gt;&lt;button bindtap="addToFront"&gt;Add to the front&lt;/button&gt;&lt;switch wx:for="&#123;&#123;numberArray&#125;&#125;" wx:key="*this" style="display: block;"&gt; &#123;&#123;item&#125;&#125;&lt;/switch&gt;&lt;button bindtap="addNumberToFront"&gt;Add to the front&lt;/button&gt; 123456789101112131415161718192021222324252627282930313233343536373839Page(&#123; data: &#123; objectArray: [ &#123;id: 5, unique: 'unique_5'&#125;, &#123;id: 4, unique: 'unique_4'&#125;, &#123;id: 3, unique: 'unique_3'&#125;, &#123;id: 2, unique: 'unique_2'&#125;, &#123;id: 1, unique: 'unique_1'&#125;, &#123;id: 0, unique: 'unique_0'&#125;, ], numberArray: [1, 2, 3, 4] &#125;, switch(e) &#123; const length = this.data.objectArray.length for (let i = 0; i &lt; length; ++i) &#123; const x = Math.floor(Math.random() * length) const y = Math.floor(Math.random() * length) const temp = this.data.objectArray[x] this.data.objectArray[x] = this.data.objectArray[y] this.data.objectArray[y] = temp &#125; this.setData(&#123; objectArray: this.data.objectArray &#125;) &#125;, addToFront(e) &#123; const length = this.data.objectArray.length this.data.objectArray = [&#123;id: length, unique: 'unique_' + length&#125;].concat(this.data.objectArray) this.setData(&#123; objectArray: this.data.objectArray &#125;) &#125;, addNumberToFront(e) &#123; this.data.numberArray = [this.data.numberArray.length + 1].concat(this.data.numberArray) this.setData(&#123; numberArray: this.data.numberArray &#125;) &#125;&#125;)]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 自学笔记1 基础类型]]></title>
    <url>%2F2019%2F03%2F03%2FTypeScript%E7%AC%94%E8%AE%B01%2F</url>
    <content type="text"><![CDATA[前言 现在Ts也是比较流行，想自学一下ts 所以就一起来学习一下，做下笔记吧 笔记目录 安装ts 第一个ts 项目使用 五分钟上手ts 基础类型 安装ts 全局安装ts 1$ sudo npm install -g typescript 全局安装编译环境tsc 1$ sudo npm install -g tsc 第一个ts 创建 greeter.ts文件 文件内部写一个greeter的函数 123456function greeter(person) &#123; return "Hello, " + person;&#125;let user = "Jane User";console.log(greeter(user)) 编译 1$ sudo tsc greeter.ts 运行查看 1$ sudo node greeter.js 项目使用 npm init -y 初始化 定义package 123&quot;build&quot; : &quot;tsc greeter.ts&quot;, &quot;test&quot; : &quot;node greeter.js&quot;, &quot;start&quot; : &quot;npm run build &amp;&amp; npm run test&quot; npm run start 就等于运行了全部 五分钟上手TypeScript定义类型实现规范化，类型注解1234567891011// 给输入的类型添加约束// 在函数参数接受的时候定义一个类型从而在编译时，把不真确的类型就会报错拦截下来// 没有按照规定输入就会报错// 从而更加的规范化function greeter (person:string) &#123; return "Hello, " + person;&#125;let user = "YHF";document.body.innerHTML = greeter(user); 接口12345678910111213141516// 定义接口interface Person &#123; firstName: string; lastName: string;&#125;// 函数// 在接收函数时接受 接受这个约束的接口function greeter(person: Person) &#123; return "Hello, " + person.firstName + " " + person.lastName;&#125;// 输入时定义对象输入let user = &#123; firstName: "Y", lastName: "HF" &#125;;console.log(greeter(user)); 类 可以使用类的方法对数据进行约束 在构造函数的参数上使用public等同于创建了同名的成员变量 在定义的时候也是可以使用数据约束的1234567891011121314class Student &#123; fullName: string; constructor(public firstName,public middleInitial : number,public lastName) &#123; this.fullName = firstName+ " " + middleInitial.toString() + " " + lastName; &#125;&#125;// 等同于class Student &#123; fullName: string; firstName: string; middleInitial: number; lastName: string;&#125; 在web如何使用ts 其实很简单就是调用ts打包出来的js文件就可以了 基础类型布尔值12345// 参数约束 后面直接跟布尔值let isDoneNew : boolean = true;// 像这样的写法是不严谨的是错误的 ，不能接受带有字符串的值let isDoneString: boolean = "true"; 数字12345// 2,8,10,16进制都可以let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; 字符串 单双引号无差别12345678910let name: string = "bob";name = "smith";// 也可以使用字符串模版，在开发的过程中也是常用的一种// 与字符串拼接效果相同的let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is $&#123; name &#125;.I'll be $&#123; age + 1 &#125; years old next month.`; 数组 可以定义类型数组，和定义范型1234// number数组let list : number[] = [1,2,3];// 范型let list2: Array&lt;number&gt; = [1, 2, 3]; 元组 (其实还是数组) 这个东西看起来很人性化 在内部每一个位置你都可以定义类型，不相同的类型 但是需要插入数据时要一一的对应 123456// 数组中定义每一个位的属性let x: [string, number];// 这样来赋值就是对的x = ['hello', 10]; // OK// 没有按相应的来就会报错x = [10, 'hello']; // Error 枚举 （和js比起来容易实现很多） 这个枚举呢说是对象也不像对象，说数值也不像数组 用对象获取法，获取到的是对应的编号 用数组获取法，获取到的是对应的文字1234567891011121314151617// 1. 对象获取，通过名字获取值enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; // 1// 2. 数组获取，通过便利枚举值得到名字enum Color &#123;Red, Green, Blue&#125;let colorName: string = Color[2]; // Blue// 3. 改变编号，默认为0// 改变后为 1，2，3enum Color &#123;Red = 1, Green, Blue&#125;let c: Color = Color.Green;// 4. 全手工赋值enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green; Any （简称任意类型什么都可以支持）12345678let notSure: any = 4; // numbernotSure = "maybe a string instead"; // StringnotSure = false; // boolean// 也可以用来数组上let list:any[] = [1,true,"free"];// 但是在第一个的类型确立了后再去改变是不可以的list[0] = 'aaa' // 这个是错误的不可以这样用，虽然任意类型但是还是要注意 Void (不能拥有返回类型，就是无返回类型)12345678910// 1. 函数function warnUser(): void &#123; console.log("This is my warning message"); // return 这样呢可以编译通过 // return 1 只要加上值这样就不可以了&#125;// 2. 变量// 只能接收null 和 undefinedlet unusable: void = undefined; null/undefined 这个就不说了只可以接收自己本身null或undefined 或者 赋值给 void Never (永远无法到达的类型…) 简单的说就是一下常抛出异常 数据永不为真时也是never类型 任何类型除了never本身都不可以赋值给他 但是never可以赋值给任何类型123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never &#123; throw new Error(message);&#125;// 推断的返回值类型为neverfunction fail() &#123; return error("Something failed");&#125;// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never &#123; while (true) &#123; &#125;&#125; Object (简单点就是对象) object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。1234567891011121314// declare 声明// declare function 在ts是声明函数的意思// 这里就是声明一个名为create 参数o类型为object 或null，的无返回函数declare function create(o: object | null): void;// 正确的调用方法create(&#123; prop: 0 &#125;); // OKcreate(null); // OK// 错误的调用方法create(42); // Errorcreate("string"); // Errorcreate(false); // Errorcreate(undefined); // Error 类型断言 （明确类型） 有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。 其实就是给他明确类型的意思，就是你知道这个是什么类型就直接写什么 但是如果上面any定义的类型和你写的不一样，就会出现报错就是出不来 两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。 123456789let someValue: any = "this is a string";let strLength: number = (&lt;string&gt;someValue).length;// as 语法 和上面一样的,但是就这样运行跑不起来，等到后面jsx的时候再去看看let someValue: any = "this is a string";let strLength: number = (someValue as string).length; 后记 这个就是我学习Ts的第一天的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置maven 下载jar包，配置Idea maven , 导入项目 下包]]></title>
    <url>%2F2019%2F03%2F03%2FMac%20%E5%AE%89%E8%A3%85maven%2F</url>
    <content type="text"><![CDATA[前言 maven其实我也不是很会，只是帮助一位朋友解决前后的交互问题需要用到，据说maven现在比较流行都是这样了应用和下包 我很久没有接触java 对这个不是很了解，在他的帮助下知道了要搭建maven和构建好项目 所以把这个方法记录下来以后遇到还能用起来 重点 插入指令时要把位置配置成自己的配置，我的图片哪里有一点点选错了，知道就好了我不再去修改那个图片 配置/工具 Mac Os 10.13.3 maven 包 我下载的是3.6.0（一会说着么下载） 控制台 Intelli IDEA （我的是2018） apache-tomcat 服务器（我的是9.0.11） 开始第一步maven包 点击进入官网 下载 maven 包 解压 maven 包 直接电脑双击解压 存放 放在系统文件夹下，哪里都可以自己要记住后面要用(记住这个地址后面配置需要) 我是放在/Users/yhf/apache-maven-3.6.0 第二步 安装 打开控制台 1$ vi ~/.bash_profile 插入配置指令 12export M2_HOME=/Users/yhf/apache-maven-3.6.0export PATH=$PATH:$M2_HOME/bin 说明一下图片里面选错了，是红框和红框下面那句，反正接着export后面哪里加入就好了 运行指令 这一条是运行刚才的配置文件 输入命令以使bash_profile生效1$ source ~/.bash_profile 输入mvn -v查看Maven是否安装成功 看到下面这样就是配置成功了1$ mvn -v 第三步 配置Idea maven 按照图片的来就可以了 导入项目 导入pom.xml 下载jar包 刚才我们导入了现在下jar包 点开右侧的maven projects 选择安装 安装好配置 开启项目跑起来- 配置serve，然后跑起来 后记 这个就是我安装mave 导入项目 和配置mave 跑起来的笔记，希望能帮到有缘人 如有什么问题加微信我们互相学习共同讨论]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序后端笔记]]></title>
    <url>%2F2019%2F02%2F18%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8Fphp%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[微信小程序商城构建全栈应用 php+微信小程序全栈应用 软件/素材 mac os 10.13.3 PhpStorm 2018 Postman XAMPP 7.0.2-1 ThinkPHP 5.0.7 项目目录结构1234567891011121314151617├─application 应用目录 ├─api 公共模块目录（可以更改） │ │-controller 控制器目录 （版本以及业务） │ │-model 模型目录 （关联模型处理） │ │-service 模型服务层（相对复杂的业务处理） │ └─validate 验证层 （客户端数据验证） ├─extra 自定义公共资源层（tp5自带的） ├─lib 模块目录 │ ├─enum 枚举 │ └─exception 全局异常处理目录 │ ├─command.php 命令行工具配置文件 ├─common.php 公共函数文件 ├─config.php 公共配置文件 ├─route.php 路由配置文件 ├─tags.php 应用行为扩展定义文件 └─database.php 数据库配置文件 笔记第八章数据表关系分析 （写着写着就绕了） 数据表之间的关系： 1 对 1 1 对多 多对多 如何判断数据表之间的结构 首先确立是否是一个多对多的关系 查看表与表之间是否存在双方的外建均能被多个表调用，如果不是那就去除多对多关系 1 对 1 1 对多 在 thinkphp 中问题不大 如何去分析 1 对多或 1 对 1 1 对 1 的关系中， 两个表直接同时并且单次被执行，就是说一个关联请求中，表 1 一次只可以调用一个表 2 的元素，并且表 2 也只是被调用了一次 1 对多 的关系中， 表 1 通过一个外建，调用了多个表 2 的数据,并且表 2 的数据不能属于多个表 1，这样就是 1 对多的表现了 模型关联（我们确立了 er 关系再来做这么的一个关联） 模型关联查询 在我们的 model 是作为一个 ORM 模式的模型结构 在这之前我们就已经定义了模型了 我们有两个模型 Banner 与 BannerItem tp5 对我们提供了关联查询的方法 hasMany 定义关联查询 1234567// 在当前模型 Banner 新建类 类名自定义喜欢什么来什么// 函数体要写在 Banner 这个主模型中，BannerItem是被关联模型// 调用模型关联时要清晰的知道 外键 以及主建（某程度下是不用写后面两个，不建议）public function items () &#123; // 关联查询方法hasMany 关联模型 外建 当前模型 banner id主建 return $this-&gt;hasMany('BannerItem','banner_id','id');&#125; 调用关联查询 12 // 在调用 模型的时候加上 with这么个方法 （括号内填写的就是刚才定义的函数名）$banner = BannerModel::with('items')-&gt;find($id); 模型嵌套关联查询 在我们的 查询中 会存在被关联体中还关联着变得关联体，在 tp5 中就形成了嵌套查询 当然 tp5 也给我们提供了方法：belongsTo 嵌套关系 Banner -&gt; BannerItem -&gt; Image (这里就存在了多重的嵌套) 模型 Banner BannerItem Image 是 BannerItem 关联 Image 所以关联函数我们写在 BannerItem 中 定义嵌套查询 1234 public function img() &#123;// 处理方法名其他都是一样的，这里就不多说了 return $this-&gt;belongsTo('Image','img_id','id'); &#125; 调用查询 (这个比较关键，不过还是很简单的) 12345// with 可以是字符串也可以是数组（嵌套关联时就会用数组）// 为什么是items.img 而不是 直接img呢，因为是嵌套关系，在模型中可以嵌套这里也是可以的// 但是在 嵌套时 是items 关联的 img ，这里就会用.来链接// 这个解释比较绕但是，知道方法就是要这样去用的就好啦$banner = BannerModel::with(['items','items.img'])-&gt;find($id); 隐藏模型字段 (模型自带) hidden 方法隐藏字段 12// 数据 方法 字段名 $banner-&gt;hidden(['字段名例：id']) visible 只显示的字段 1$banner-&gt;visible(['字段名例：id','update_time]) 模型内部隐藏字段 （自定义模型的内部隐藏,把一些前端不需要的字段隐藏了） hidden 隐藏 直接在 model 定义的模型内添加方法 （以 Banner 为例） 1234567891011121314151617181920namespace app\api\model;use think\Model;class Banner extends Model&#123; // 直接添加 $hidden的数组填入要隐藏的字段即可 // visible 等方法用法一样，那个模型内部的字段要隐藏就在那个模型内部设置 protected $hidden = ['id']; public function items () &#123; // 关联模型 外建 当前模型 banner id主建 return $this-&gt;hasMany('BannerItem','banner_id','id'); &#125; public static function getBannerByID($id) &#123; $banner = self::with(['items','items.img'])-&gt;find($id); return $banner; &#125;&#125; 自定义配置 /application/extra （extra 自己新建的，凡是放在这里面的配置文件都会被自动加载） 手动配置一个本地的 img 图片路径 在 extra 下 新建 setting.php 1234return [ // 名称 域名 路径（直接放在public下的images就是这样写就可以了） 'img_prefix' =&gt; 'http://zerg.cn/images']; 使用自定义变量 因为是在 extra 内部定义的所以会自动调用，那么我们用 config 就可以去掉用到了12 // 配置文件名.变量名config('setting.img_prefix'); 静态文件存放 静态的外部文件，例如图片啊文本啊等的文件，必须放在 public 这个公共目录下 并不是放在 application 的这个开发目录下，因为 tp5 的架构里面只有 public 这个目录是对外开放的 所以文件都必须是要放在 public 目录下 tp 模型读取器 (数据拼合) 为了获取数据/修改数据，tp5 给出了一个读取器的方法 用来给我们读取数据修改数据用的 那个模型要修改数据就在哪个模型定义 定义读取器（其实也是一个函数方法） 读取器命名规范 开头 get 必须有 + 读取数据的名称并且开头要大写例 Url + Attr 必须加的（利用驼峰命名法） getUrlAttr （完整的编写，除了中间的那个数据，其他都是必须有的，中间数据名开头必须大写） 传入一个值，名字自定义 （这个传入的数据其实就是我们要获取到要修改的数据） 每一次传入一个数据，有多个输出就会重复的执行读取器 因为在我们的业务逻辑中会调用到当前模型的其他数据，但是第一个参数只是获取到的是当前读取器的数据，并无法读取到其他的数据 所以添加了第二个参数 （这个参数会给我们返回一个这个模型的数据，就是所有的数据） 123public function getUrlAttr ($value,$data) &#123;&#125; 使用读取器 （做数据的修改然后返回） 1234public function getUrlAttr ($value) &#123; // 这里我们只是做了一个自定义的 变量和url路径的拼接 return config('setting.img_prefix').$value;&#125; 业务逻辑添加 12345678public function getUrlAttr ($value,$data) &#123;$finalUrl = $value; // 判断是否要拼接if ($data['from'] === 1) &#123; $finalUrl = config('setting.img_prefix') . $value;&#125;return $finalUrl;&#125; 自定义基类 （面向对象，提取模型读取器） 一开始这样做会觉得好像代码还多了啊，这么不就是做无用功吗，在业务不断增加的时候，后期修改就可以看出来好处了 集中业务逻辑 创建 BaseModel.php 作为模型基类 把让所有的模型都继承这个基类 把读取器提取到 模型基类 （这样做是一个面向对象的思想） 但是提取了模型基类后我们所有的子模型都会自动的去执行模型 这样可能会造成一些数据的变更和错误，比如说，两个命名一样但是代表的数据不同是就会出现错误 所以我们把它封装为一个自调用的方法123456789// BaseModel// 读取器protected function prefixImgUrl ($value,$data) &#123; $finalUrl = $value; if ($data['from'] === 1) &#123; $finalUrl = config('setting.img_prefix') . $value; &#125; return $finalUrl;&#125; 子模型调用基类方法 Image123public function getUrlAttr ($value,$data) &#123; return $this-&gt;prefixImgUrl($value,$data);&#125; 定义 api 版本号 在互联网的项目中，我们会对项目版本对升级，以及业务逻辑改变和变更 同时也是需要去兼容旧版本，所以会保留旧版本的 api 开发开闭原则 代码对拓展开发，对修改封闭 添加功能直接以拓展的方式添加就可以，不需要去改变代码 修改是封闭的，业务变更上升版本 不可以修改原来的版本代码，会破坏了原版本的代码，和影响功能调用的风险 需要修改就要添加新的版本 多版本 版本的分离，新旧版本不发生冲突 新老版本的兼容问题 给用户缓冲时间，也不能兼容太多的版本，成本太高 v1 做 v1 版本层 v2 做 v2 版本层 路由 api 动态变更1234// 动态版本 实现传什么就调用什么版本的api，同时也是要修改版本指向接口// 传 v1 就是 v1// 传 v2 就是 v2 动态写入Route::get('api/:version/banner/:id','api/:version.Banner/getBanner'); 一对一关系选择关联方法 belongsTo 在有外建的表内请求就用 belongsTo hasOne 在没有外建的表亲求就用 hasOne 多对多查询 （belongsToMany）- 多对多的查询呢 就比一对多和 1 对 1 的查询要多了一个参数 在参数中第二个是放入第三个表也就是中间表 1234public function products () &#123; // 关联表名 中间表名 关联表id 主建 return $this-&gt;belongsToMany('Product','theme_product','product_id','theme_id');&#125; 开启路由完整匹配模式 开我们开发的过程中难免会有 api 相同当是请求的方式以及传参的不同，但是又需要相同的 api 名称 在我们的 tp5 中，会自动追寻一个半路径的匹配，所以当匹配到了相关的路由时就会停止匹配 但是这样返回的结果肯定不是我们要的，所以就要开启这个完整的路由匹配模式 在 config.php 配置文件中，我们就可以来更改了 123// 只有找到这句话改变就可以了 false -&gt; true// 路由使用完整匹配'route_complete_match' =&gt; true, 合理利用数据冗余 在查询量上来的时候避免数据量大多表查询之间耗时 合理的利用数据冗余来减少联合表的查询减少查询时间 但不要太过多但使用，只是为了减少数据库压力 在数据库中做相关的优化 collection 字符集 我们使用获取到的数据是字符集更方便让我们来修改数据 tp5 修改获取返回数据 （/application/database.php） 123// 找到这个吧 arr改为 collection// 数据集返回类型'resultset_type' =&gt; 'collection', 使用字符集就可以轻松的临时隐藏字段 当我们在开发的过程中，不是所有业务逻辑都需要隐藏的字段，我们就不可以在关联模型中直接就隐藏字段 我们会使用临时隐藏字段 当然数组我们是不可以直接这样来隐藏的，但是使用字符集的话就可以直接的去使用函数进行数据的隐藏12// 使用hidden进行隐藏$products = $products-&gt;hidden(['summary']); 字符集判空 isEmpty 内置函数 1234// 判断空抛出异常if ($products-&gt;isEmpty()) &#123; throw new ProductException();&#125; ##第九章 service (建立在 model 上的，用来处理复制的业务) 在我们的 tp5 中，我们的 model 代表的一个很重要的位置 可以写业务逻辑，也访问数据库 但是 service 不可以用来访问数据库，因为上建立在 model 之上的 我们都会把复杂的业务逻辑放在 service 层中 公共应用文件 common.php 编写公共的 http 请求 123456789101112131415161718/** @param string $url get 请求地址* @param int $httpCode 返回状态码* @return mixed*/function curl_get ($url,&amp;$httpCode = 0) &#123; $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);// 不做证书校验，部署在linux环境下请改为true curl_setopt($ch,CURLOPT_SSL_VERIFYPEER,false); curl_setopt($ch,CURLOPT_CONNECTTIMEOUT,10); $file_contents = curl_exec($ch); $httpCode = curl_getinfo($ch,CURLINFO_HTTP_CODE); curl_close($ch); return $file_contents;&#125; 模型插入数据（create） 在 tp5 中如何向数据库插入数据 tp5 模型给我们准备了 create 的方法 1234 // 模型名 create方法 数组传入要添加的字段和数据$user = UserModel::create([ 'openid' =&gt; $openid ]); 动态传入数值随机生成字符串方法1234567891011121314/* * 生成随机字符串 */function getRandChar ($length) &#123; $str = null; $strPol = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz"; $max = strlen($strPol) - 1; for ($i=0;$i &lt; $length; $i++) &#123; $str .= $strPol[rand(0,$max)]; &#125; return $str;&#125; 文件缓存 chache 使用 cache 写入缓存 使用文件存储的方式 缓存的地址在目录文件/runtime/cache 文件内 1$request = cache($key,$value,$expire_in); 路由分组 由于我们 api 接口的不断增加 在一个分类中会有很多的相同的接口路由 这个时候如果我们业务的变更修改起来就会很麻烦 所以我们是用来路由分组来实现 group 方法 第一个是公共的路由部分，第二个是一个闭包（也就是一个 function 的方法） 在里面还是安装路由一样去定义就可以了 也能提高路由的效率 12345678910//Route::get('api/:version/product/recent','api/:version.Product/getRecent');//Route::get('api/:version/product/by_category','api/:version.Product/getAllInCategory');//Route::get('api/:version/product/:id','api/:version.Product/getOne',[],['id'=&gt;'\d+']);Route::group('api/:version/product', function () &#123; Route::get('/recent','api/:version.Product/getRecent'); Route::get('/by_category','api/:version.Product/getAllInCategory'); Route::get('/:id','api/:version.Product/getOne',[],['id'=&gt;'\d+']);&#125;); 关联模型下个关联数据排序（tp5 没有的，重点） 使用 模型+query 添加排序 12345678910// 关联模型 imgs properties 查询// 模型的嵌套 imgurlpublic static function getProductDetail ($id) &#123; // 在 with 中 嵌套function // 在内部添加 query $product = self::with(['imgs' =&gt; function ($query) &#123; $query-&gt;with(['imgUrl'])-&gt;order('order','asc'); &#125;])-&gt;with(['properties'])-&gt;find($id); return $product;&#125; 使用 关联模型 添加/更新数据 添加数据的方法有很多，我们来使用一下关联模型的方法 两个的区别在于 修改操作的 关联 不可以用括号 1234// 调用 user 中的 address 关联 使用 save方法添加数据$user-&gt;address()-&gt;save($dataArray);// 调用 user 中的 address 关联 使用 save方法修改数据$user-&gt;address-&gt;save($dataArray); 第十章前置操作 在我们编写 api 业务逻辑的时候，我们会想在调用 api 接口之前，需要满足某些条件 这样才可以去访问我们的接口中的业务逻辑 所以我们要在做一个前置操作，抵挡不满足条件的抛出异常 tp5 中使用前置操作需要基础自带的一个基类 Controller 定义一个名为 \$beforeActionList 的数组 1234567891011121314151617181920212223242526272829use think\Controller class Address extends Controller &#123; // 定义前置属性 // 第一个字段是 访问api接口前 需要 访问的一个前置方法 // 箭指的 是一个数组 // 数组内部定义一个箭指数据，也可以直接是一个字符串（内部填入api接口函数就可以了） // 否则向下面这样写 // 多api编写 protected $beforeActionList = [ 'first' =&gt; ['only' =&gt; 'second,third'] ]; // 触发api前 执行的前置函数 protected function first () &#123; echo 'first'; &#125; // api接口 public function second () &#123; echo 'second'; &#125; // api接口 public function third () &#123; echo 'third'; &#125; &#125; 重构前置验证操作 （实现面向对象） 提取验证业务逻辑到 service 的基类中 提取前置方法到 BaseController 的基类中 继承基类，执行前置方法 提取出一个前置的基类 BaseController （继承内置 Controller） 1234567891011121314151617use app\api\service\Token as TokenService;// 继承class BaseController extends Controller&#123; // 前置方法 // 验证初级权限作用域,用户和cms都可以访问 protected function checkPrimaryScope () &#123; // 向Token调用验证方法 TokenService::needPrimaryScope(); &#125; // 验证权限，只有用户可以访问，cms无法访问 protected function checkExclusiveScope () &#123; TokenService::needExclusiveScope(); &#125;&#125; 提取验证业务逻辑（因为是 token 相关的就归并到 token 的 service 业务层中） 1234567891011121314151617// 重构前置方法，验证权限// 用户和cms管理员都可以访问的权限public static function needPrimaryScope () &#123; // 调用token中的方法获取scope $scope = self::getCurrentTokenVar('scope'); // 判断是否存在 if ($scope) &#123; // 判断 scope的权限大小 if ($scope &gt;= ScopeEnum::User) &#123; return true; &#125; else &#123; throw new ForbiddenException(); &#125; &#125; else &#123; throw new TokenException(); &#125;&#125; 继承 BaseController 基类使用前置方法 12345678910111213141516 // 继承基类class Address extends BaseController&#123; // 调用前置的方法 protected $beforeActionList = [ // 前置验证的方法名 需要前置验证的函数 'checkPrimaryScope' =&gt; ['only' =&gt; 'createOrUpdateAddress'] ]; /* * @url api/v1/address */ public function createOrUpdateAddress () &#123; &#125;&#125; 验证器数据自定义子项验证 自定义子项验证，通过自定义的方法调用实现 当我们在验证时，传入的是一个二维数组，就可以使用来验证子项 我们就自定义一个验证的方法，通过基类的验证的调用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748// 整体验证protected $rule = [ 'products' =&gt; 'checkProducts'];// 数据子项的验证protected $singleRule = [ 'product_id' =&gt; 'require|isPositiveInteger', 'count' =&gt; 'require|isPositiveInteger'];/* * 自定义整体验证 */protected function checkProducts ($values) &#123; // 验证是不是数组 if (!is_array($values)) &#123; throw new ParameterException([ 'msg' =&gt; '商品参数不正确' ]); &#125; // 验证不为空 if (empty($values)) &#123; throw new ParameterException([ 'msg' =&gt; '商品列表不能为空' ]); &#125; // 循环对每一项进行验证 foreach ($values as $value) &#123; $this-&gt;checkProduct($value); &#125; return true;&#125;// 基础调用子项验证protected function checkProduct ($value) &#123; $validate = new BaseValidate($this-&gt;singleRule); $result = $validate-&gt;check($value); if (!$result) &#123; throw new ParameterException([ 'msg' =&gt; '商品参数不正确' ]); &#125;&#125; 自动添加时间戳（TP5 内置添加时间戳） 在我们的操作中，我们的数据中会带有数据，tp5 为我们提供了自动添加时间戳 找到自己要添加的时间戳的模型 我是在 order 添加那我就去 orde 人的模型中 \$autoWriteTimestamp 添加为 true，需要是模型的方式才可以使用的 创建 修改 删除 默认为 create_time update_time delete_time 修改方法名 在模型下修改 12345// 自动写入时间戳protected $autoWriteTimestamp = true;// 修改字段名// 内置名称 自定义修改的名称protected $createTime = 'create_timestamp'; Tp5 事务应用 在我们的应用中可能会出现分步的操作，可能会本地与服务端出现不一致 所以我们使用事务来做处理 在中间出现错误就会把数据回滚保持数据的一致性 123456789101112131415161718192021222324252627282930313233343536373839// 开头加入开始 Db::startTrans(); try &#123; $orderNo = $this-&gt;makeOrderNo(); $order = new \app\api\model\Order(); $order-&gt;user_id = $this-&gt;uid; $order-&gt;order_no = $orderNo; $order-&gt;total_price = $snap['orderPrice']; $order-&gt;total_count = $snap['totalCount']; $order-&gt;snap_img = $snap['snapImg']; $order-&gt;snap_name = $snap['snapName']; $order-&gt;snap_address = $snap['snapAddress']; $order-&gt;snap_items = json_encode($snap['pStatus']); $order-&gt;save(); $orderID = $order-&gt;id; $create_time = $order-&gt;create_time; foreach ($this-&gt;oProducts as &amp;$p) &#123; $p['order_id'] = $orderID; &#125; $orderProduct = new OrderProduct(); $orderProduct-&gt;saveAll($this-&gt;oProducts); // 结尾加上结束 Db::commit(); return [ 'order_no' =&gt; $orderNo, 'order_id' =&gt; $orderID, 'create_time' =&gt; $create_time ]; &#125; catch (Exception $ex) &#123; // 异常出现回滚 Db::rollback(); throw $ex; &#125; 引入没有命名空间的文件与调用(Loader)，手动引入微信支付 php 使用 loader 的 import 方法 extend/WxPay/WePay.Api.php 12345 // 文件开头的第一个 文件路径 // 类的名称Loader::import('WxPay.WxPay',EXTEND_PATH,'.Api.php');// 调用// 调用的时候前面要加反斜杠$wxOrderData = new \WxPayUnifiedOrder(); TP5 模型实现数据减少 setDec12 // 前面是查询 第一个数是写要改变的字段 第二个是要减少的数量Product::where('id','=',$singlePStatus['id'])-&gt;setDec('stock',$singlePStatus['count']); 数据库锁与事务锁的区别 数据库模型-&gt;lock(true) 事务锁 Db 事务锁是等待整个事务提交才会执行第二次事务，但是数据库模型锁只是单步的锁着了数据库查询语句 在后面的操作还没有执行时，数据库模型锁已经放开了 外部网址使用 要从根目录一直到 index.php 后面才是路由 www.yhf7/zerg/public/index.php/api/v1/pay/notify 模型分页查询(paginate) 第一个参数是分类数 第二个数是否简洁模式 第三个是数组填入分页数 12345public static function getSummaryByUser ($uid,$page=1,$size=15) &#123; $paginData = self::where('user_id','=',$uid)-&gt;order('create_time desc')-&gt;paginate($size,true,['page' =&gt; $page]); return $paginData;&#125; 后记 这是学习微信小程序开发后端PHP时候的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序 笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git ssh 重构]]></title>
    <url>%2F2019%2F02%2F11%2Fgitshh-%E9%87%8D%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言 昨天我说了忘记密码，今天我想说一下ssh的配置 有时候可以用但是ssh内部公钥可能会存在问题 所以今天我就来重构ssh 解决 进入.ssh 1$ cd .ssh/ 备份文件 把公钥文件拷贝出来以防万一 生成公钥 生成密钥 输入后后面所有的都是直接回车就可以了 如果你要设置密码那就设置吧，ssh本来就是用来免密登录的，最好就是不用密码吧1$ ssh-keygen 查看密钥 查看密钥配置1$ cat ~/.ssh/id_rsa.pub 添加密钥 把查看密钥生成的代码拷贝到Github或码云 删除原有的输入新的就可以了 ssh下载项目 复制项目到ssh地址下载 第一次使用ssh遇到Are you sure you want to continue connecting (yes/no)? yes 要输入yes表示同意验证本地ssh1$ git clone git@gitee.com:yhf7/zerg.git 查看ssh配置了什么地方 要在.ssh文件下 在什么地方设置了会看的出来1$ cat known_hosts 后记- 才疏学浅，遇到了问题还好有大哥教我重构才得以解决，马上记录解决办法 - [欢迎进入我的博客](https://yhf7.github.io/)：https://yhf7.github.io/ - 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-01 - 02心得]]></title>
    <url>%2F2019%2F02%2F10%2F%E6%96%B0%E5%B9%B4%E6%84%9F%E6%82%9F%2F</url>
    <content type="text"><![CDATA[在新的一年的这两个月中，看了书看了教学视频，也在掘金认识了一些人，加了一些学习交流群，看到了很多志同道合的人，很多也是和我一样科班出身然后也自己努力学习的前端后端的同学们，大家有问题就拿出来讨论一起学习你帮我解决一下问题你帮我解决一下问题这样的学习氛围非常的好，看到小伙伴们都很用功的学习，大年三十也是有人开着电脑敲着代码，奋力的去学习，生怕被人超越了看到被人都很努力的在学习进步，你自己就在那里玩手机玩电脑的闲着，不是老天不公平而是你自己不努力怨不得天，当别人在拼命学习的时候你在为自己的小小能力而沾沾自喜的时候你已经输了我不希望自己到了毕业也不知道找什么工作，什么工作适合自己，我想通过自己的努力改变生活改变自己的未来，所以我自己也开始了学习，但是知识永远是学不完的只能每天学一点慢慢的去积累，只有拼了才知道自己到底有多强大，也只有拼了才知道自己到底有多么的渺小，世界之大无奇不有比你强的人大有人在，比你弱的也是大有人在，为何不做人中龙凤呢？只有自己强大起来才不会被人欺负被人看不起，我不想靠别人帮我什么，欠了的人情是要还的，我一直希望的是只要实力够强大就不会需要别人的帮助，所以自己要强大起来，用什么强大自己呢，那就只有学习，不断的学习在it的领域中技术的更新换代是非常快了，我们还没来得及学完这一个，又到了下一个新的时代了，作为一个学生我非常想知道的是在职场中到底我们需要做什么可以做什么，需要很多的实战经验，但是经验是需要积累起来的，问过很多的大神在工作中要做什么，问很多的实战的东西，但是别人的回答也只是做项目做多了就会有经验了，作为一个学生而且很多都是自学的自己对于做项目我是非常的吃力的，即使我可以写出前后端交互的项目来，毕竟也是一些小的项目，对于权限分级啊、路由拦截啊等的一些我都不会，遇到稍微难一点的业务逻辑我就要很久很久才可以想出来，而且还是用了很多很笨的方法去实现，所以2019年的目标就是打好基础练好技术，找一份实习2019目标：3月完成小程序4月vue的项目实战，reacts学习5月 项目实战后面都是一些实战，暑假找一份实习锻炼一下自己]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Git ssh 密钥忘记密码]]></title>
    <url>%2F2019%2F02%2F10%2Fgit-ssh%E5%BF%98%E8%AE%B0%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[前言 如果在之前有创建SSH的时候设置过密码，那就很有可能git操作时出现忘记密码的尴尬情况。 今天我就忘记了密码，在网上找到了解决的方法就记录下来 解决 在ssh密码忘记密码我们是无法去修改的，这个是一个保护机制，我们无法修改当是我们可以重新创建一个ssh密钥 进入本地ssh 1$ cd ~/.ssh 查看文件 ls 如果本地有ssh秘钥的话会有id_rsa.pub，config，known_hosts等文件。如果本地没有ssh的话cd ~/.ssh这一步可能就会有找不到文件的提示了。 一般忘记密码都是已经有的我们就不说了 创建新的ssh 输入这个后面改自己git的邮箱1$ ssh-keygen -t rsa -b 4096 -C "905477376@qq.com" 新密码 如果本地有ssh，会出现如下提示：这里选择y，表示覆盖本地的ssh key，这也就是ssh秘钥删除的意思。接着就是让你输入密码的，可以直接回车不设置密码，我还是设置密码的 查看密钥 把之前的公钥删掉添加新的 输入代码查看密钥然后复制到 GitHub或者码云上1$ cat ~/.ssh/id_rsa.pub 后记 这就是我实践了的方法 欢迎一起学习交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue动画多个元素嵌套使用过渡]]></title>
    <url>%2F2019%2F01%2F17%2Fvue%20%E5%8A%A8%E7%94%BB%E5%B5%8C%E5%A5%97%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言 在我们前端的工作中我们的去写页面，总会觉得这样的效果给到用户好像很干没有什么体验 那我们就想搞搞新意思？ 弄点动画上去憋，那么弄动画我又想他滚动又想他偏移又想有渐变效果 渐变和移动可以写在一起，但是滚动和偏移好像不可以一起执行喔 那我们就要分开两步来执行但是，vue的transition里面好像不可以同时执行两个transform 所以我们就来解决这个问题 其实嘛是可以嵌套使用的哦 工具/资料 mac os 10.13.3 vue官方文档 https://cn.vuejs.org/v2/guide/transitions.html vs code 开始 套用我们的 transition 在我们需要定义效果的外面包上 transition 这个 name 呢是自定义的也可以不写，个人认为最好是写一下12345&lt;transition name="move"&gt; &lt;div class="cart-decrease" v-show="food.count&gt;0" @click="decreaseCart"&gt; &lt;span class="inner icon-remove_circle_outline"&gt;&lt;/span&gt; &lt;/div&gt;&lt;/transition&gt; 定义Css 如果使用name了，-前面写的就是name定义的名称，如果没有写那就直接用v就好 在我们要嵌套动画的地方也是向平时css关系那些嵌套进去就好了1234567891011121314151617181920/* 这里我们定义了滑动和渐变 */.move-enter-active, .move-leave-active transition: all .4s linear opacity: 1 transform translate3d(0,0,0).move-enter, .move-leave-to /* .fade-leave-active below version 2.1.8 */ opacity: 0 transform translate3d(24px,0,0)/* 定义滚动 这里我是动画下的，span想添加效果 那么我们就把类名拼接在后面去使用就好了 如果添加了不生效，那就换一个类名，因为有一些是官方的类名是不允许使用的 */.move-enter-active .inner, .move-leave-active .inner transition: all .4s linear transform rotate(0).move-enter .inner, .move-leave-to .inner transform rotate(180deg) 这样我们就实现了即滚动也偏移 后记 看了有没有发现很简单哈，其实本来也就是很简单嘛，只是一开始傻乎乎的用了in使得效果没粗来以为不可以这样用 这是本人的学习问题记录的笔记，有需要的可以借鉴 欢迎添加微信交流学习 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装/解决Hexo next搜索错误笔记]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%90%9C%E7%B4%A2%E9%94%99%E8%AF%AF%2F</url>
    <content type="text"><![CDATA[前言 搜索功能无效，一直在哪转圈圈，头都晕了 说起就来气，添加了那么多篇文章，突然就这几天就不可以用hexo的搜索功能，我写了那么多篇文章突然今天写项目发现不记得想来查一下居然用不了气得我 横看竖看都不知道错哪里，配置了好几遍也是不行 最后还是被我ko了 赶紧记录下来下一次就不用怕了 所需工具/资料 mac 10.13.3 VS code (软件很多自己喜欢，这个失败了一会说原因) Chrome Sublime (这个是解决问题的关键哦) 开始ko错误之旅 查错第一步（其实和安装没有啥区别） 查看package 根目录 package.json看看有没有 hexo-generator-searchdb 看这个的主要原因的看看有没有安装这个中间件，如果没有安装就安装一下1$ npm install hexo-generator-searchdb --save 查看 /themes/next/_config.yml 配置 搜索 local_search看看这个下面的enable 是否处于12local_search: enable: true 查看添加配置（这个我个人觉得嘛加和不加没有区别） 添加 /themes/next/_config.yml12345search: path: search.xml field: post format: html limit: 10000 查错第二步 有可能是文字的数量太多引起的 可以修改刚才配置的 search：内的limit 把数值加大试试 查看文件名什么的有没有定义错误或者是什么弄错了 直接 sudo hexo g 打包就知道了，如果报错了那就是文件有问题 查错第三步（关键，很多的问题会出在这里） 有可能是文章内部的一下符号引起的错误 （我就知道是这样引起的为什么不执行我真的不懂）（这样的错误有可能是因为跟编辑器或者输入法有关系） 字符错误 Bytes: 0x08 0xE4 0xB8 0x80 其实也是空格只是不识别的软件才可以看的出了 在我们的 vs code 这个软件呢就是识别了这种符号所以并没有显示出了 在我们的Sublime 就是不识别直接就可以显示出来了解决问题方法一 （这些只可以在sublime或者其他的软件中做，vs code不可以的哦） 直接就在 search.xml 文件中 直接搜索 \x08 或者 \u0008删掉 但是呢这样的方法治标不治本啊 在你下一次的添加文件编译的时候还是会带上的解决方法二（方法一治标不治本那我们再来一个方法） 直接找到错误文件 这里我是把文件都考出来然后把一些比较早点文件先放回去 然后后面都文件一个一个那样去测试找到错误文件 （主要是我一开始不知道是这样的错误才那样去找） 现在知道了错误直接就在 Sublime 打开所有的md看看有没有 上面的错误字符 有就删掉就可以了 这个是我的错误（每个人的都可能不一样） 后记 终于吐槽完，也说完错误了，这是我个人的一个查错以及解决的方法，希望有缘人看到可以帮到你 这些都是我的一些笔记，欢迎一起学习讨论 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网上抓取 Git进阶笔记]]></title>
    <url>%2F2019%2F01%2F09%2FGit%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[前言 这个git的解说是我在网上看到然后觉得挺好抓取下来给自己用的，并非个人所写 Git 进阶知识点作为分布式的版本控制系统，Git 的操作指令非常多，但是我们可以灵活的组合使用一些常用指令，就可以玩转大多数的日常 Git 使用场景。 1、温习 Git 工作 区域先来温习一下 Git 的工作区域划分：工作目录、暂存区、本地仓库，实际操作中，我们需要知道每一步操作发生在哪个工作区域，那么再复杂的 Git 问题都能 轻松解决。 先看一张逻辑工作区域划分图： 物理 工作区域划分图： .git 是隐藏文件夹，大多版本控制软件都会用一个隐藏的文件夹作为其本地版本仓库，SVN 也是如此。用户的每一步操作都被这个隐藏文件夹里的代码记录着。 2、一次完整的本地提交虽然 Git 是分布式的 版本控制系统，工作中，我们都会有远程仓库的概念，但只需熟练玩转本地仓库即可，因为远程仓库不过是别人电脑上的本地仓库。接下来我们来看看一次完整的提交，是如何在三个工作区域之间转换的： 上图中也引出了 git reset 回滚命令的三个参数：–soft –mixed –hard，三个 参数回滚的程度 逐渐增强，实际使用中可以根据具体需求灵活使用。 另外不要忽略了 git commit 只提交那些被记录到了暂存区的修改。 3、使用好 checkoutcheckout 可能是 git 中比较多功能的一个命令。 git checkout [分支名] : 切换分支。 git checkout [commit 序列号] : 穿越到指定的某次 commit。 git checkout -b [分支名] : 创建并切换分支。 git checkout –ours/theirs : 解决冲突时用来检出某方的提交。 git checkout [文件名/路径/.] : 丢弃某些文件/文件夹/所有修改。 所以 checkout 这个检出操作，不仅仅是用来切换分支，还有很多强大的功能；注意点：git checkout . 指令丢弃的文件是无法找回的，使用请谨慎，防止车祸现场。 4、使用简单的组合命令进行历史修改修改历史中的某次提交信息由于某些原因， 有时候总要修改一下提交历史，或者叫重写历史，最简单的修改最近一次提交命令 git commit –amend，然后会进入文本编辑状态，修改你的提交信息。 但是如果不是最近一次提交，而是历史中较远的前几条信息，那么单纯使用 git commit –amend 就不行了，比如下图这种情况，想要将 “第一次提交” 改为 “首次提交”。 这时你可能马上会想到 git rebase 变基命令，但是对于这种情况，我们可以使用 git checkout 组合 git commit –amend 完成同样的工作: 1、先用 git checkout 36ae20… 穿越回第一次提交的节点中，此时我们执行 git log 看到的只有第一次提交的 commit: 2、那么接下来你也猜到了，执行 git commit –amend 吧。3、然后再次 git checkout master 穿越回当前分支的最新节点。 合并多次提交历史 为一次合并多次历史是比较常见的需求，同样我们先不用 rebase，使用一些常用的命令；例如我们要将上边例子中的三次提交合并为一次，我们可以先用 reset 回滚多次历史提交，然后 commit –amend 重写提交即可： 1、 先用 git reset –soft 36ae20…，软回滚到第一次提交(36ae20…是历史中第一次的提交序列号，这里也可以使用 HEAD~3 这种头指针回数的形式)，这时候 git log 又变成了只有第一次的 commit 信息： 但是通过 git status 可以看到其他两次提交都已经被我们 使用 reset –soft 将最近两次提交回滚到了暂存区： 2、接下来，使用 git commit –amend 重新提交并修改最近一次的 commit 信息即可。 使用 reset –soft 我们将提交回滚到暂存区，这样可以在重新提交的时候，少写一次 git add。如果多次合并的 commit 不是从最近一次的提交历史 开始，那么久多使用一次 git checkout 。 你看，貌似不需要 学习 rebase 也能完成 Git 重写历史。 5、使用 git rebase 修改历史对于 4、使用简单的组合命令进行历史修改 中的案例，我们可以使用更加高级的 git 工具 rebase，使用 rebase 来干这些事情会显得更加专业，当然 rebase 的功能也更加强大一些。但是依然要写出来 4、使用简单的组合命令进行历史修改 这一部分内容，是想表达，有时候一些问题的解决办法并不唯一，灵活使用一些我们已经学过的 知识点也能曲线救国；假如你还不会使用 rebase，眼下又个紧急的 git 历史合并任务要做，马上去学习 rebase 又有些来不及，那么只能急中生智了。 接着 4 中的例子，我们使用 git rebase -i 36ae20… ，然后我们会看到如下的文本编辑界面： 123456789101112131415161718192021222324252627282930313233343536373839pick 1f737d8 第二次提交pick 8e401d5 第三次提交pick bc9c6f0 第四次提交# Rebase d973330..bc9c6f0 onto d973330 (3 commands)## Commands:# p, pick = use commit# r, reword = use commit, but edit the commit message# e, edit = use commit, but stop for amending# s, squash = use commit, but meld into previous commit# f, fixup = like "squash", but discard this commit's log message# x, exec = run command (the rest of the line) using shell# d, drop = remove commit## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.## However, if you remove everything, the rebase will be aborted.## Note that empty commits are commented out 注释中，我们看到 reword edit squash 等指令，这里我们把 pick 改为 edit。 123edit 1f737d8 第二次提交pick 8e401d5 第三次提交pick bc9c6f0 第四次提交 然后保存退出，接下来 git 会把你带入第二次的 commit 节点， 并有如下提示： 到这里，我们需要执行 git commit –amend 来执行 commit 修改。编辑保存后，再执行： 1$ git rebase --continue 然后 git 把你带回到 master 分支的最新节点，整个操作完成。 如果要合并提交，我们需要把 edit 改为 squash：123pick 1f737d8 修改为第二次提交squash 8e401d5 第三次提交squash bc9c6f0 第四次提交 接下来，git 会进入另一个编辑界面： 1234567891011121314151617# This is a combination of 3 commits.# This is the 1st commit message:修改为第二次提交# This is the commit message #2:第三次提交# This is the commit message #3:第四次提交# Please enter the commit message for your changes. Lines starting# with '#' will be ignored, and an empty message aborts the commit. 这个界面里，可以修改你最终要显示的提交信息，这里直接保存退出，完成合并，此时 git log 显示如下： 除了修改和 合并提交，还可以使用 git rebase 进行拆分、删除提交操作，就不一一演示。 最终你会发现，使用 git rebase 来修改历史步骤比较繁琐，还不如使用 4、使用简单的组合命令进行历史修改 的方式来操作简单。 理解分支合并中的 Fast-forward/merge/rebase在分支合并的场景 中，我们有时会看到 Fast-forward ， Fast-Forword 很好理解，在 Git 中就是它直译 过来的意思’快进‘，下面我做了四个小视频，来解释 Fast-forward/merge/rebase。 观看视频前，我们以下图做个 demo 背景说明： 图中有两条分支，master 和 feature1 分支，feature1 是从 master 的 C2 节点拉出来的分支，背景说明完毕。 Fast-forward 合并模式 Fast-forward 的合并模式永远不会有冲突产生。 非 Fast-forward 合并模式 这种非 Fast-forward 的合并模式下才有可能发生合并冲突。 merge 过程为了和下边的 rebase 做对比，视频中在 feature1 分支中做 git merge master 操作 rebase 过程 前边我们用 rebase 来重写历史，这里的 rebase 用来在分支之间合并变基，变基可以理解为改变基点，基点就是某条分支在另一条分支上的起点，这个点是出现分支的点；rebase 和 merge 在从结果上来看，及其相似，但是其过程却大不相同，我想看了视频，你应该理解了。 rebase 的目的并不是做一次合并，而是为了让某条分支 与主分支的 当前进程保持同步更新，进而在合入主分支的时候，能够以 Fast-forward 的过程合并，避免冲突；rebase 的过程 有冲突的可能，但是这种冲突时发生在当前分支，不会影响主分支，所以也不会影响和你一起合作的其他小伙伴。所以 在多人合作的时候经常使用 rebase 是个好习惯。 一次完整的 rebase 场景 解决冲突解决冲突其实很简单，理解了 git 本地操作和 git merge 过程，解决冲突就是个体力活了；cherry-pick/merge/rebase/revert 等操作都有可能发生冲突； 冲突产生时我们只需要通过 git status 查看具体发生冲突的文件，然后打开编辑文件，选择保留的内容后保存文件，然后继续 merge 或者 rebase，指令分别是：git merge –continuegit rebase –continue；除了 –continue 参数，我们还可以使用 –abort 来终止 merge 或者 rebase 。 之所以说解决冲突是个体力活主要看，冲突文件的数量和内容多不多，如果冲突较多时，我们一一修改可能就比较累了，这时候可以借助 checkout 指令来保留冲突双方的其中一方修改： 12$ git checkout --ours // 保留自己的修改$ git checkout --their // 保留别人的修改 注意点：rebase 的过程，ours 和 theirs 是反过来的。当然，我们也可以借助图像化工具来解决冲突： 选择后，会进入图像化操作： 关联远程仓库当我们需要关联远程仓库的时候，可以通过 git remote add [远程仓库命名][ssh/http 地址]，例如： 1$ git remote add origin git@git.coding.net:demo/demo.git 这里把远程仓库 git@git.coding.net:demo/demo.git 命名为 origin。一个仓库可以关联多个远程仓库，但是仓库名不能相同： 1$ git remote add gh git@git.github.com:demo/demo.git 这里，我们把另一个远程仓库 git@git.github.com:demo/demo.git 命名为 gb 关联了本地仓库，当我们需要同时往多个远程仓库推送文件时，可以使用了。 最后通过 git remote -v 可以查看本地仓库关联的所有远程仓库。 git config 配置文件在 Mac 系统中，git 的配置文件有两处，一个是全局配置文件：~/.gitconfig ，在用户目录下；另一个是当前仓库的配置文件，在 .git 文件夹下，两种重复时，优先使用 .git 文件下的 config 文件。 config 文件的内容： 一些情况下，我们可以直接编辑 config 文件来修改 git 的配置。 git 常用指令表 参数省略 本地操作 git init git add/rm git commit git squash git rebase git checkout 状态查看及信息检查和比较 git status git log git diff 配置及别名 git config git alias 分支操作 git branch git merge git rebase git cherry-pick git checkout 远程操作 git clone git remote git push/pull git fetch git 时间旅行：分支切换、 回退历史、保存/清理现场 git reset git revert git stash git checkout git clean -fdx 后记 个人认为这个git的笔记还是挺不错的 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli 2.0/3.0 mock数据配置]]></title>
    <url>%2F2019%2F01%2F06%2Fvue-cli-mock%2F</url>
    <content type="text"><![CDATA[前言 在我们开发的时候现在都是前后端分离的模式，后端给前端提供一个接口，由前端向后端发请求，得到数据后前端进行渲染。由于前后端开发进度的不统一，前端往往使用本地的测试数据进行数据渲染的测试。 所以我们就会用本地的json，来实现一个本地的数据测试，从而就有我们的mock数据 在我们使用 vue 开发的时候 也随着 vue-cli 脚手架的版本不断的升级，我们的配置方法也是不一样来，vue-cli3 基本自动会没有配置文件 在之前我也说过了vue-cli 编写node服务的 其实 app和express 并不用自己去引入的直接使用就可以了（我也是后面才意识到了这个问题） 所需工具/资料 mac 10.13.3 vue-cli 2/3 (版本个人喜欢吧，我现在是3.0) VS code (软件很多自己喜欢) Chrome插件 jsonView (这个是用来在你页面看数据的时候自动对json进行格式化) Postman 用来对api接口测试的 开始vue-cli2 在vue-cli构建的项目，我们可以借助devServer开启一个服务，然后我们可以通过路由模拟一个接口来进行测试。 第一步我们当然的建立一个json数据的文件（我这里自己定义好了,至于放不放在mock文件夹里面见仁见智） 当然是配置啦 （打开build/webpack.dev.conf.js 进行配置） 打开文件后先引入 json文件数据 找到 devServer 这个对象在里面添加 before 这里的app 是不需要我们自己去定义的直接调用就好123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960 // 引入文件 var appData = require("../data.json"); var seller = appData.seller; var goods = appData.goods; var ratings = appData.ratings; // 配置devServer devServer: &#123; before(app) &#123; // 我直接就加在了开头的位置 // 获取方法 路由 返回的数据 app.get('/seller', (req, res) =&gt; &#123; // res.json(mockdata); res.json(&#123; errno: 0, data: seller &#125;); &#125;); app.get('/goods', (req, res) =&gt; &#123; // res.json(mockdata); res.json(&#123; errno: 0, data: goods &#125;); &#125;); app.get('/ratings', (req, res) =&gt; &#123; // res.json(mockdata); res.json(&#123; errno: 0, data: ratings &#125;); &#125;); &#125;, clientLogLevel: "warning", historyApiFallback: &#123; rewrites: [&#123; from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, "index.html") &#125;] &#125;, hot: true, contentBase: false, // since we use CopyWebpackPlugin. compress: true, host: HOST || config.dev.host, port: PORT || config.dev.port, open: config.dev.autoOpenBrowser, overlay: config.dev.errorOverlay ? &#123; warnings: false, errors: true &#125; : false, publicPath: config.dev.assetsPublicPath, proxy: config.dev.proxyTable, quiet: true, // necessary for FriendlyErrorsPlugin watchOptions: &#123; poll: config.dev.poll &#125;&#125; 调用 后面的before(app)部分就定义了可以通过向/seller发送get请求来得到我们要的json文件。 同时我们在vue文件中只要 123456// 利用了axiosaxios.get("/seller").then(res =&gt; &#123; this.seller = res.data; &#125;).catch(error=&gt;&#123; console.log(error); &#125;); 页面查看/postman 调试 vue-cli3 vue-cli3主打自动化，0配置。但是我们往往需要进行一些配置，这时我们就要创建一个配置文件。 mock 是我创建的文件夹存放data数据的 vue.config.js就是我们手动创建的配置文件，完整的配置项可以在官网看到，在这里我们着重于devServer 在这里的配置和2.0的差不多的只是简化了很多 配置1234567891011121314151617181920212223242526272829303132333435const appData = require('./mock/data.json');const seller = appData.seller;const goods = appData.goods;const ratings = appData.ratings;module.exports = &#123; devServer: &#123; // port: 8080, before(app) &#123; app.get('/seller', (req, res) =&gt; &#123; // res.json(mockdata); res.json(&#123; errno: 0, data: seller &#125;); &#125;); app.get('/goods', (req, res) =&gt; &#123; // res.json(mockdata); res.json(&#123; errno: 0, data: goods &#125;); &#125;); app.get('/ratings', (req, res) =&gt; &#123; // res.json(mockdata); res.json(&#123; errno: 0, data: ratings &#125;); &#125;); &#125; &#125; &#125; 运行就可以了会自动检查并运行 后面的效果和2.0的是一样的那我们就不再看了 后记 这个vue-cli 的配置方法是本人解决问题所记录的笔记，欢迎更多的同行大哥指导交流 欢迎进入我的博客：https://yhf7.github.io/ 如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman 调试Api，以及xdebug断点调试补充]]></title>
    <url>%2F2019%2F01%2F06%2FPostman%2F</url>
    <content type="text"><![CDATA[前言 无论我们作为一个后端开发，还是前端开发我们都需要用到api接口 但是作为前端呢就倾向于直接调用接口 作为后端人员不单要编写接口还是要去测试一下自己到接口是否能有或者通过经验测试相关会引起到bug，从而去编写全局异常处理到机制 那我们就来走入测试接口的世界其实还是很简单的 xdebug断点调试每一次都配置web的话太麻烦了，我们用小技巧就可以不用那么麻烦 所需工具/资料 mac 10.13.3 Xampp （小编使用的是集成开发的,开启状态） PHPStorm (https://www.jetbrains.com/phpstorm/download/download-thanks.html，没有的就去官网下载，破解什么的我就不说了如果需要直接联系我) 已经安装及配置好了 xdebug ThinkPHP 5.07 postman（https://www.getpostman.com/，官网免费安装） 开始简单的说一下安装吧 直接进入官网 点击下载安装包，然后双击运行就可以了 https://www.getpostman.com/ 安装好的效果 测试 我们用的是 ThinkPHP 那我们就在路由哪里定义一个get的路由（其他的业务逻辑就自己写吧） 我们来到 postman 测试 选择相应的 获取方式和地址 点击send进行测试 这样我们就会的到来相应的结果，如果报错了就是端口有问题（以及看到错误端口） 看了一个报错一个异常处理后，我们来看看真正的获取到接口信息 传值的方法很多 ? / body这些都可以 测试就是这样的还是很简单 测试api小技巧 日常我们测试的端口会比较多，一个个的过很容易忘记也很麻烦，那我们有方法可以把它收藏到一个文件里面用哪个点那个 postman为我们提供了这样的收藏的方法 点击收藏 选择文件和修改信息（这个不强求自己喜欢就好） seve to 文件夹名 再下次打开的时候点击文件夹就可以看到要测试的api了 多人的话可以右上角登录 xdebug断点调试 每一次都配置会使得加重工作都负担以及不必要 设置断点，启动测试 获取测试码（每一次的启动都是不一样的，如果想多次测试那就不要断开，只是执行完就好，下一次send的时候还是会继续启用刚才的端口，如果终止了的话下一次开启需要拷贝新的端口） 断点测试 后记 Postman的api测试，以及小技巧，有什么疑问请直接添加小编微信，欢迎有更多的技术交流 欢迎进入我的博客：https://yhf7.github.io/ 这只是本人的一些解决做法，个人笔记，如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>Api</category>
      </categories>
      <tags>
        <tag>Api</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaWeb 实训项目]]></title>
    <url>%2F2019%2F01%2F01%2FJavaWeb%E5%AE%9E%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[前言 先来吐槽一下这个项目 既然是吐槽，我先从自身出发，作为一个前端为主的开发人员我看到这个界面的是我是忍不住的，哪有人做界面这么难看（不过从后端的角度出发界面也就那么回事吧能实现业务逻辑就好） 虽然是后端，也用了 java 的语言 但是这样绕来绕去的写法看得我头皮发麻，我还是喜欢简单明了的写法 不过既然是一个学习的项目那就要好好的去对待 这次只是分享项目不是写，看着可以的可以下来看看研究研究还是可以的 所需工具/资料 mac 10.13.3 mysql 5.0+ 的版本（不要太高不然链接方式有问题） Intelli IDEA 2018 （软件自己去官网下，破解不会可以私聊我） 项目源码 是存放在一个大的文件内可以全部都下了，使用浏览器迅雷可以下单独的哦 里面有 sql 直接导入就可以了 Github(https://github.com/YHF7/JavaWeb/tree/master/netstop) 效果图]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XAMPP 配置虚拟域名/localhost重定向]]></title>
    <url>%2F2019%2F01%2F01%2FXAMPP%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[前言 说到这个 xampp 这个东西配置虚拟域名，小编一肚子的气啊，搞技术这些东西还是网上搞比较容易。 相同的方法同样的配置，白天弄了一天还是不行，晚上洗完澡把东西都回执到原样结果就可以了 记录下来以后配置的时候可以用 坑提醒 mac 下域名不可使用 test_1.cn 类似此种格式的域名，windows 下面可以，mac 下不可以，今天碰到的大坑 hosts 填写的域名和 httpd-vhosts.conf 中的域名请保持一致 ErrorLog 和 CustomLog 这两个最好就是不要修改吧，不然很容易出现权限不足就报错的，之前我也试过（导出错误一般都不回去看吧，也看不懂最好就不要动了） 网上说的添加什么这些不用去添加的，添加了反而错了（因为本来自带的就是有访问权限的） 1234567&lt;Directory &quot;/Applications/XAMPP/xamppfiles/htdocs&quot;&gt; #Options Indexes FollowSymLinks ExecCGI Includes #don&apos;t permission see list Options All AllowOverride All Order allow,deny Allow from all&lt;/Directory&gt; 在配置完后 localhost 地址也会被改变，无法访问同目录下的其他项目，所以我们要做一次重定向 配置完记得重启服务器不然看不到修改的效果然后就觉得自己弄错了 所需工具/资料 mac 10.13.3 Xampp （7.0 版本基本无差） VS code (vim 个人觉得麻烦还是用界面的快一点) 配置配置本地域名 前往本地的/etx/hosts 打开 hosts 文件（我用的是 vscode，你们自己可以随意，也可以用命令直接修改） 填写自己想要的域名 127.0.0.1 zerg.cn # added by Apache Friends XAMPP （我自己用的） 图片中黄色部分，可写可不写，最好写上吧 配置 xampp httpd.conf(其实就是检查开启了域名配置了没有) 前往本地 xampp/xamppfiles/etc/httpd.conf 查找 etc/extra/httpd-vhosts.conf 看看是否打开，如果被注释了去掉# 配置 xampp httpd-vhosts.conf (域名的向导) 前往本地 xampp/xamppfiles/etc/extra/httpd-vhosts.conf 添加域名导向(ServerName 必须要和定义的域名一致) *:80 表示端口 DocumentRoot 表示项目的目录 ServerName 你要使用的虚拟域名，这里和前面 host 文件中的保持一致，不然会出错 配置以上两个就可以，重启 Apache 就可以使用你配置的虚拟域名 1234567&lt;VirtualHost *:80&gt; # ServerAdmin webmaster@dummy-host2.example.com DocumentRoot &quot;/Applications/XAMPP/xamppfiles/htdocs/zerg/public&quot; ServerName zerg.cn ErrorLog &quot;logs/dummy-host2.example.com-error_log&quot; CustomLog &quot;logs/dummy-host2.example.com-access_log&quot; common&lt;/VirtualHost&gt; 最终结果（本地/自定义） 域名 本地 localhost 重定向 我们定义完后地址访问路径也会被改变，在多项目的情况下就无法查看其他的项目 解决的方法就是我们给他做一个重定向，然后重启服务器 这样我们就可以看到项目目录了 后记 完整的 XAMPP 配置虚拟域名,遇到问题欢迎添加微信 qq 一起学习交流 欢迎进入我的博客：https://yhf7.github.io/ 这只是本人的一些解决做法，个人笔记，如果有什么侵权的话，请及时添加小编微信以及qq也可以来告诉小编（905477376微信qq通用），谢谢！]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPStorm配置 xdebug断点调试]]></title>
    <url>%2F2018%2F12%2F31%2FPHPStorm%E9%85%8D%E7%BD%AE%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言 继上一节我们说了 ThinkPHP 安装 xdebug 这个断点调试的插件，但是没有说着么去结合我们的软件去使用这么的一个插件，按我们就来说一下把 所需工具/资料/ mac 10.13.3 Xampp （小编使用的是集成开发的,开启状态） PHPStorm (https://www.jetbrains.com/phpstorm/download/download-thanks.html，没有的就去官网下载，破解什么的我就不说了如果需要直接联系我) 已经安装及配置好了 xdebug 开始配置（有个提醒软件在配置前不要汉化不然打不开 preferences,亲自躺坑） 打开 phpstorm 进行配置 command+,打开 PhpStorm 的配置列表。 1. 首先，打开 Language&amp;Framework 下的 Debug,然后如图配置，这里的端口要和 php.ini 里的 xdebug.remote_port 保持一致。 2. 接下来配置 DBGp Proxy, port 要和你的 Apache 端口一致。 3. 然后是 servers 的配置，没有的同学可以点击+号创建一个，Host 和 Port 根据你的实际情况来设置，我这里用的本地环境，大家也可以用测试环境。 4. 接下来在调试页创建一个 web application 5. 配置断点开启调试 6. 成功开启调试 后记 完整的 php 断点安装配置已经完成，有什么疑问请直接添加小编微信，欢迎有更多的技术交流 这只是本人的一些解决做法，如有侵权请通知删除]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP xdebug安装以及报错处理]]></title>
    <url>%2F2018%2F12%2F30%2FThinkPHP%E5%AE%89%E8%A3%85xdebug%2F</url>
    <content type="text"><![CDATA[前言 在我们开发的过程中我们肯定是会有一定的错误，当我们去查错的时候有很多的方法 可以使用断点的方法运行查看错误，也可也使用输出来一点点缩小范围 但是在 ThinkPHP 中并不可以直接就插入断点来查错，所以很多的 php 工程师觉得麻烦就不去安装使用 xdebug 的插件 在这里我们就一起来安装以及配置 所需工具/资料 mac 10.13.3 （自带 php 所以会出现一定的问题） Xampp （小编使用的是集成开发的） ThinkPHP 5.0.7（版本自己喜欢都可以的） VS code 用来改文件 https://xdebug.org/wizard.php xdebug 下载网址 开启 xdebug 之旅1. 开启服务 开启 xampp 在 ThinkPHP 中 public/下新建 info.php 在里面加 phpinfo(); http://localhost/zerg/public/info.php （zerg 是我项目名，查看 phpversion） 可以搜索 xdebug 看看有没有，php 是不自带的如果不是配置来都是没有的 2. 下载 xdebug 打开官网 https://xdebug.org/wizard.php 进入来官网直接就是下图这样的下载地方了 回到 info.php 的页面右键查看源代码 （进入了界面直接 全选复制） 把复制的代码放到刚才的框内，并点击 analyse my phpinfo()的那个按钮 就会自动的监测你的 php 版本需要用什么版本的 sdebug 就会得到下面图所显示的页面，点击红色框的部分下载包 3. 配置 xdebug 当我们下载好了后找到自己下载的位置 会有 xdebug-2.6.1.tgz 的压缩包 然后我们就跟着他给的步骤做，是什么步骤看上面下包的图 第一步：解压包 在终端进入到 文件的目录 sudo tar -xvzf xdebug-2.6.1.tgz 就可以解压 第二步：进入文件目录 cd xdebug-2.6.1 第三步：执行 phpize （一般没有安装 brew 和 autoconf 的都会出现下面的错误） - 有错我们只好修复这个错误（是因为没有安装 autoconf 引发的）那我们就安装一下 - 安装 autoconf 需要用 brew 所以先安装 brew - ruby -e “\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; -（使用上面的命令就可以安装了，如果不行就去http://brew.sh/官网看看吧） 安装好我们安装 autoconf - brew install autoconf 第四步：继续执行 phpize 一般都是直接 sudo phpize （mac 系统这样做肯定报错如图，为什么呢因为多端 php，系统自带一个 xampp 带一个 brew 也会补一个,而且系统默认是抓取本地的 php 所以无论你着么配最后都没有效果） 面对这个坑我们不怕直接全路径安装就好 sudo /Applications/XAMPP/xamppfiles/bin/phpize 这样就可以了 第五步：执行 confoigure 吃了上一次的亏这一次不可以再吃了 sudo ./configure –with-php-config=/Applications/XAMPP/xamppfiles/bin/php-config 第六步：这里按照图片的操作也可以，当然我是直接复制粘贴的，因为我被命令行伤透了心，找到当前目录下的 modules 文件夹，找到该文件夹下的 xdebug.so(想说爱你不容易啊)，狠狠的复制。 第七步：把复制的粘贴（如果按照图片的做跳过这一步） /Applications/XAMPP/xamppfiles/lib/php/extensions/no-debug-non-zts-20151012/xdebug.so xdebug.so 探寻结束，开始配置 php.ini 到/Applications/XAMPP/xamppfiles/etc/php.ini 目录中找到 php.ini 然后打开，在最后面添加如下 12345678910[xdebug]zend_extension = /Applications/XAMPP/xamppfiles/lib/php/extensions/no-debug-non-zts-20151012/xdebug.soxdebug.remote_autostart=onxdebug.remote_enable=onxdebug.remote_mode=&quot;req&quot;xdebug.remote_host=localhostxdebug.remote_port=9000xdebug.remote_handler=&quot;dbgp&quot;xdebug.idekey=&quot;PhpStorm&quot;xdebug.profiler_enable = Off 最后保存，然后重启 Apache 服务，重新输出 phpinfo()信息，然后搜索一下，发现如下内容即告成功。 4. 最后效果 后记 这只是本人的一些解决做法，如有侵权请通知删除]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动web期末大作业]]></title>
    <url>%2F2018%2F12%2F11%2F%E7%A7%BB%E5%8A%A8web%E6%9C%9F%E6%9C%AB%2F</url>
    <content type="text"><![CDATA[前言 这是一个移动web的环保登陆页设计 是我们学校的期末考试大作业来的 主要是用来检测，css，表单的使用 技术/插件 js jquery.min.js bootstrap.min.js css animate.css 初始化页面 bootstrap.min.css font-awesome 字体处理 style.css 布局处理 项目地址传送效果图]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node 后端服务器开发插件]]></title>
    <url>%2F2018%2F12%2F07%2Fnode%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[插件目录 插件官网 ES2015（es6） express node 的前端模板 nodemon node 改变监听 config-lite 1.5.0 文件的遍历 chalk 粉笔插件变色 mongoose mongodb 使用插件 body-parser 配置解析表单 POST 请求体插件 ES2015 都是用来处理 es6 的兼容的直接放 json 文件里面安装就好想装新版本也可以一个一个装 12345678910"babel": "^6.23.0","babel-cli": "^6.26.0","babel-core": "^6.24.0","babel-preset-es2015": "^6.24.1","babel-preset-stage-3": "^6.22.1","babel-register": "^6.24.0","babel-plugin-transform-async-to-generator": "^6.24.1","babel-plugin-transform-es2015-classes": "^6.24.1","babel-plugin-transform-es2015-modules-commonjs": "^6.24.1","babel-plugin-transform-export-extensions": "^6.22.0" .babelrc 配置 es6 12345678&#123; "presets": ["stage-3"], "plugins": [ "transform-async-to-generator", "transform-es2015-modules-commonjs", "transform-export-extensions" ]&#125; index.js （默认启动文件） 12require("babel-core/register");require("./app.js"); // 被调用的入口文件 express node 的前端开发模板 安装 1$ sudo cnpm i express -S 使用 12345678910111213141516171819202122232425import Express from "express"; //引入const app = Express(); //定义app.all("/*", (req, res, next) =&gt; &#123; //设置跨域请求报文头 //设置允许跨域响应报文头 //设置跨域 // 启用 Node 服务器端的 cors 跨域 res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "X-Requested-With"); res.header("Access-Control-Allow-Methods", "*"); res.setHeader("Content-Type", "application/json;charset=utf-8"); next();&#125;);app.get("/", (req, res) =&gt; &#123; // 路由判断 res.send(`hello world!`);&#125;);app.listen(5000, () =&gt; &#123; //开启服务 console.log("server running http://localhost:" + 5000);&#125;); nodemon nodemon 是 node 的改变监听 ，只要改变就会重新编译，就不需要每次改变都手动改变 （也可以作为全局安装） 安装 12$ sudo cnpm i nodemon -S 本地安装$ sudo cnpm i nodemon -g 全局安装 使用 本地安装使用 在 package.json 定义 123"scripts": &#123; "start": "nodemon index.js"&#125; 终端 sudo npm run start 调用 全局方法 直接在终端 sudo nodemon index.js config-lite 1.5.0 这是一个用了遍历查找文件的插件，其实简单的来说就是用来定义一些公共的参数，调用的时候方便一点 安装 1$ sudo cnpm i config-lite@1.5 -S 配置 默认是查找 config 下的 default.js 文件（为了用起来方便我们就不改变直接定义） 在项目目录新建 config 文件夹 在里面建立 default.js 文件 然后定义一些公共的元素或者是可变的元素 123456789101112131415"use strict";module.exports = &#123; port: 5000, url: "mongodb://localhost/myelm", session: &#123; name: "SID", secret: "SID", cookie: &#123; httpOnly: true, secure: false, maxAge: 365 * 24 * 60 * 60 * 1000 &#125; &#125;&#125;; 调用 调用就比较简单 123import config from "config-lite"; //引入config.url; //好像用对象那样使用，不过要你返回的是个对象才可以 chalk 这个插件主要是用了改变输出的颜色，在不同的情况定义输出的字体颜色 安装 1$ sudo cnpm i chalk -S 使用 12import chalk from "chalk"; //引入chalk.yellow("连接数据库成功"); // 直接 chalk.颜色(变色内容) mongoose 官方 数据库就自己装这里不说，直接安装全局的 这是一个 mongodb 数据库的开发插件 安装 1$ sudo cnpm i mongoose -S 使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445import mongoose from "mongoose"; //引入mongoose.connect( "mongodb://localhost/myelm", &#123; //连接数据库 useNewUrlParser: true &#125;);const db = mongoose.connection;db.once("open", () =&gt; &#123; console.log(chalk.yellow("连接数据库成功"));&#125;);db.on("error", function(error) &#123; console.error( chalk.red("Error in MongoDb connection: " + error + " 数据库有问题") ); mongoose.disconnect();&#125;);db.on("close", function() &#123; console.log(chalk.red("数据库断开，重新连接数据库")); mongoose.connect( config.url, &#123; server: &#123; auto_reconnect: true &#125; &#125; );&#125;);const Schema = mongoose.Schema;const ObjectId = Schema.ObjectId;const BlogPost = new Schema(&#123; //定义数据库 author: ObjectId, title: String, body: String, date: Date&#125;); body-parser 这个是解析表单 post 请求体的插件 安装 1$ sudo cnpm i body-parser -S 配置 12345678910// 在主页定义 一定要在路由判断之前才能生效// 配置解析表单 POST 请求体插件 （注意：一定要在 app.use(router) 之前）// parse application/x-www-form-urlencoded 解析applicationapp.use( bodyParser.urlencoded(&#123; extended: false &#125;));// parse application/json 解析app.use(bodyParser.json()); 调用 调用就很简单不用引入，传过来的数据解析在 req.body 里面 123app.post("/api/ts", (req, res) =&gt; &#123; console.log(req.body);&#125;);]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YHF 管理系统（javaweb）]]></title>
    <url>%2F2018%2F12%2F01%2FJavaWeb1%2F</url>
    <content type="text"><![CDATA[前言 这是一个期末考试项目 老师出的一个题目 要求有 数据库、css、js、等特效 至少 3 个页面以上 所有做了这么等一个小项目 项目所用技术 页面 架构主要都是 javaweb （主页是 bootcss 的页面） 部分用到了 js 数据库 mysql 插件 js jq echarts 图表插件 css bootcss 项目源码地址项目效果图登录页 注册页 主页 用户图表页 修改用户信息页 数据库结构]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mpvue搭建初始小程序]]></title>
    <url>%2F2018%2F11%2F24%2F%E6%90%AD%E5%BB%BA%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[前言前段时间，美团开源了 mpvue 这个项目，使得我们又多了一种用来开发小程序的框架选项。由于 mpvue 框架是完全基于 Vue 框架的（重写了其 runtime 和 compiler），因此在用法上面是高度和 Vue 一致的（某些功能由于受限于小程序环境本身的原因而不能使用），这给使用过 Vue 开发 Web 应用的前端开发者提供了极低的切换门槛来开发小程序。 没学过 vue 的想去学一下先 开始1. 开发环境 系统自己喜欢 （本人 OS 10.0） node.js npm (最好切换为国内镜像 npm set registry https://registry.npm.taobao.org/) vue-cli （npm install vue-cli -g） 微信开发者工具 https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html 开发软件 vscode （个人喜欢） 软件内部插件 Vetur （vue语法高亮） 2. 架构第一个 mpvue 的小程序 vue init mpvue/mpvue-quickstart firstapp （在命令行运行，firstapp项目名自己定） 然后就会看到这个 （如果自己代码不是很规范的话eslint那里请选n） 12345678910111213141516171819? Project name firstapp? wxmp appid touristappid? Project description A Mpvue project? Author kevinzhang 邮箱? Vue build runtime? Use Vuex? Yes? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? 小程序测试，敬请关注最新微信开发者工具的“测试报告”功能vue-cli · Generated "firstapp".To get started: cd firstapp npm install npm run devDocumentation can be found at http://mpvue.com 安装好后 cd firstapp npm install (这一步是安装要用的插件和依赖) 执行命令让这个代码运行起来，进入开发模式 npm run dev 成功运行后，这个项目代码就进入开发模式，一旦有源代码发生修改，就会触发自动编译。因为mpvue使用的是Vue + HTML Web的开发方式开发小程序，它最终还是需要被转换成小程序的代码才可以在小程序环境运行，所以这里的自动编译的目的就是要把Web代码编译成小程序代码。编译后的代码会在dist目录下： 3. 部署到微信开发者工具 打开微信开发者工具，选择新增项目 项目目录选择指向firstapp目录： 点击“确定”按钮，进入小程序开发主界面，在左边的小程序模拟器中就能看到firstapp小程序的执行结果了： 【提醒】记得在微信开发者工具的菜单》设置 》编辑设置 中，将“保存时自动编译小程序”勾选上，这样当mpvue的代码自动编译完成后，模拟器才会自动刷新界面。 小结 本文简要介绍使用 mpvue 开发小程序的前期准备，后面还会继续学习再介绍其他功能]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部署线上node/vue项目]]></title>
    <url>%2F2018%2F11%2F23%2F%E9%83%A8%E7%BD%B2%E7%BA%BF%E4%B8%8Anode%2F</url>
    <content type="text"><![CDATA[当你写了node项目的时候就想抛到网上去 前面有教 外网映射 也是一个好方法 但是用起来开启服务就好，但是关闭主机就不能用了 那我们就来使用网上的服务器 服务器 阿里云、腾讯云 复杂贵买不起 新浪云 （这个还不错不过也是要钱还是挺方便，服务器与数据库基本齐全） Heroku 不过要vpn (支持的语言多但是没有mysql数据库) openshift 也是外网服务器不过不用vpn （没用过，不过好像是试用也是要收费） 部署检查配置 node git npm Heroku 上到官网 登录/注册 https://devcenter.heroku.com/ 选择自己要的语言 （回跳到开发文档） 我选的是node 选择安装homebrew cli 我是os系统 我选的是苹果 （下载后安装） 登录 homebrew 终端 heroku login (苹果加 sudo) 在一个你想放项目的地方新建项目文件夹 用终端进入到文件夹 执行 git clone https://github.com/heroku/node-js-getting-started.git （这个命令是用来克隆应用源代码的） 克隆好 cd node-js-getting-started 进入文件夹 创建应用程序 （虽然下载了但是是空的架构要自己安装） heroku create （生成项目的时候项目名是随机生成的） 部署到 网上 （前面已经登录了现在直接上传就好） 刚创的应用直接push就好 sudo git push heroku master 上传完 heroku open查看 有个绿色页面就是成功了 好前面都是说配置现在来说部署 1.把vue项目打包出来 2.把打包好的html文件拷贝到 node-js-getting-started/views/pages/ 我们考到这里面然后把里面index.ejs文件删掉 把我们的文件改为ejs 3.打包出来的static 直接放到public里面就好 部署好我们就上传 git add . git commit -m “” git push heroku master 上传三部曲不多说 heroku open 查看有自己喜欢的效果就是对了 查错 如果出现 application err就是错了 heroku logs –tail 使用这个命令查看错在哪里 一些自定义的文件啥的在项目根目录传文件放 在 index.js文件中引入配置就好 新浪云 新浪云还是比较简单 登录 进入控制台 创建应用 选择自己要的服务器 设计域名和应用名称 然后里面有git代码说明 就是把git克隆下来再来写代码就好了 git push三部曲 数据库那些也是这样差不多自己研究]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli开启的服务内部写 node 接口]]></title>
    <url>%2F2018%2F11%2F23%2Fvue-node%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[在我们的开发中很多时候都是前后端分离，但是在一些个别的案例中也不需要开启两个 node 服务（这里也有一个问题就是开启两个端口会有跨域的问问） 跨域问题在前面获取数据的 axio 说过就不说了 那么我们能不能把 node 后台服务也写到 vue-cli 开启的服务中呢？ 能 那我们就来吧 在 vue-cli 中我也不知道他有没有 expore 这个包 那就自己装一下吧有没有都好 在项目文件夹内 创建一个名为 server 的文件夹 在里面新建 router.js 文件 (文件夹名和位置自己喜欢着么来就着么来) 在 router 文件里面写接口和业务逻辑 12345678910// 这里我就简单的写一个接口这些学过node都懂不多说const express = require('express')const router = express.Router()router.get('/yhf/abc', (req, res) =&gt; &#123; res.send('欢迎访问 Node 服务器数据 API 接口！')&#125;)module.exports = router 如何调用 router 呢？（我们找到 build/webpack.dev.conf.js）（说一下为什么是这个文件，在旧版本呢就是在 build/sev-server.js 中配置的，在新版本中去除了这个配置文件改为了前面的那个 webpack 配置文件） 1.找到了这个文件后 第一步肯定是引包啦 要加在 const portfinder = require(‘portfinder’) 的后面 123const express = require('express') express包const app = express.Router() 开启服务 这个自己喜欢吧const router = require('../server/router') 你自己的接口包 2.第二步当然就是配置啦 （找到 devServer 大约在 25 行左右那里） 123456789// 加入这一段代码 本来是没有before的要自己加before(app) &#123; // 这个方法是直接在这里自己写接口 app.get('/api/getDiscList',(req,res) =&gt; &#123; res.send("欢迎来的node服务") &#125;) // 这个是外部引入 app.use(router) &#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仿写 vue2-vuex 案例]]></title>
    <url>%2F2018%2F11%2F21%2F2018-11-21%2F</url>
    <content type="text"><![CDATA[案例心得 在分析完那个vuex的小案例后，我觉得自己好像真的明白了vuex是着么写的 但是在我重新去仿照这个案例写的时候，还是发现了自己有很多的不足 那也只可以一点点的去查一点点的去写 在仿写的过程中，也有向源码学习 从中知道和学到了很多之前自己不会的方法和技巧 仿写源码vue2-vuex案例分析]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue2-vuex 案例分析]]></title>
    <url>%2F2018%2F11%2F17%2Fvue2-vuex%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[这个是我在github看到的一个vue的案例感觉好像挺有用的就下下来看，然后就写了这个分析，vue-vuex都全了很好项目地址目录分析 build 配置/打包目录 config 端口控制 happyfri 静态资源 node_modules 插件库 src 业务逻辑 components 公共组件 itemcontainer 页面 config 这个我不太懂应该是 ajax 交互用的 ajax.js rem.js 这个是一个 手机屏幕自适应判断的一个文件，用来在不同的屏幕时改变页面内的 html font-size的大小 而改变页面的效果 images 图片 page 业务逻辑组件 home 主页面 index.vue item 答题页面 index.vue score 最后的分数页面 index.vue router 路由 router.js store vuex 的业务逻辑 index.js 创建与实例数据与方法 actioin.js 主要是负责对接外部方法 mutatoions.js 主要是复杂编写内部方法供 actionin.js 内的方法调用 style less common.less 控制页面的样式 App.vue 主组件 main.js 配置文件 index.html 主页面 其他的一下配置文件 走进 vue2 项目页面 首先这个是用 vue-cli 脚手架开启的一个 vue 项目 （作者是把原本的 8080 短端口改为了 8088） sudo cnpm dev run 开启服务 看开启无误 通过http://localhost:8088/#/ 访问主页面 开启到了服务了我们就来看结构 页面很简单看起来就几个部分 头部-内容-按钮-背景图 业务逻辑代码 进入到页面了 我们就看看 主页面 是着么得到的 当我们开启了服务的时候 就会执行 build/dev-server.js 文件 然后就会找到我们的 src 文件夹 文件夹内有个 main.js 的配置文件 在 main.js 文件中 所有的 插件与静态资源 与 vue 实例都会在里面 但是因为这样都写在一起 不仅会使得代码很乱也会很多所以分开了很多的页面去写 所以看到 main.js 其实没什么东西 ，都分到了不同的组件中 好到了我们的 main.js 就激活 vue 实例 这里 vue 就会进行内部的路由判断 我们打开了 8088 端口时默认是 / 在 router/router.js 文件就会判断并执行到相应到页面 也就是主页 router.js 在这个路由页面中我们会看到 返回到是 App 这个 主组建 children 这个是用来设置子组件的 （子组建分为了三个） “” 默认为空的话 就是去到 ../page/home 这个主页面中 “item” 答题页 “score” 结算页 component: r =&gt; require.ensure([], () =&gt; r(require(‘../page/home’)), ‘home’) 这个获取地址的方法 已经不建议如此获取 跟着路由判断 我们来到了 默认的主页面 src/page/home/index.vue template 组件 我们看到是一个类名 home_container 的 div 包着一个 外部引用组件 通过 father-component 给这个组件传一个值 ，这是用来给组件判断是主页面还是答题页面，输出不同的效果 script js import itemcontainer from ‘../../components/itemcontainer’ 引用外部的组件 name 这个就不用说了 components 挂载组件 style less 看完了 子主页面 我们顺藤摸瓜 去看看他所引用的外部组件 src/components/itemcontainer.vue template （分了两个部分，同时也分了两个页面 home/item） 头部 header 通过 刚才我们看到的 father-component 传过来的值 判断是 home 还是 item 显示不同的头部 第几周/第几题 内容 div 也是通过 father-component 判断显示那个 那么我们就分开说 home 一个 div 放着一些内容 router-link 控制的一个按钮 跳转地址是 item item div 包着的 内容 通过 itemDetail.length 来判断是否还有题目//其实是多余的 有就 继续执行 内容 header ul&gt;li 最后又两个 span 通过 itemNum &lt; itemDetail.length 来判断是下一题还是执行结算函数 script 在这里面我们可能一开始是没有注意到的 props 父子组件传值就不说了 把目光投射到代码靠后一点点 created 这个生命周期函数身上 当我们一进入这个页面时 就会马上判断是否是 home 页面 如果是 那就执行 this.initializeData(); 这是定义在 vuex 的函数 不急跳过去先看看 itemcontainer 内的 vuex 我们会看到 页面是用了 按需导入的方法 import { mapState, mapActions } from “vuex”; 在我们的使用中为了避免多次的编写 this.\$store….这样的代码 我们是用来 mapState，mapActions 这两个方法 mapState 获取 vuex 的 state 也就是 data 使用比较简单 computed: mapState([接收名:’vuexdata 名’]) computed 用来监控自己定义的变量 mapActions 获取 vuex 的函数 methods: {…mapActions([“函数名”, “函数名”])} // 将 this.方法名() 映射为 this.$store.dispatch(&#39;方法名&#39;) 用在异步操作 知道了这些我们继续回头看项目 判断是 home 就执行方法 和设置背景 style 样式这些基本工的我就不说自己摸索 既然说到了 vuex 那就顺着去看看 vuex src/store/index 进来了后我们看到的是 一些引入的插件和自定义的函数方法 在这里注册了 vuex state 就是一些定义的数据 在下面我们会看到一个 抛出的 创建 vuex 实例 state 是数据 actions 异步调用自定义的方法 mutations 同步自定义方法 了解了 vuex store 的架构后我们再继续看这个 刚才调用的方法的执行 但调用这个方法的时候 第一时间方法是找到了 src/store/index.vue 的 stroe 实例 通过前面我们知道是异步调用方法是 在 actions 这个中，这个方法来自于 当前文件夹下的 actions.vue 中 那我们进入到这个页面 终于看到了这个方法了 原来是用来初始化信息的 这个方法需要传入一个值 （但我们使用 vuex 的时候默认第一个要输入的是 vuex 的参数） 当我们看到 commit 的时候应该想到的是 vuex 同步方法调用 那么我们知道同步方法都是放在 mutations 里面 那我们就进去看看 在文件中 我们找到了 刚才调用的 INITIALIZE_DATA 方法 state 是 vuex 必须导入的 然后我们就看了了很多个 state.什么的数据 看到 state 那肯定就是 vuex 内部都数据啦 这时候返回到 index.js 对照着看 就会知道是把数据进行赋值初始化，这步是为了不要产生数据的出错，当你答完题又回去 home 的时候再次答题数据就会出错了 好我们看完了 App/home 这样的 主子组建的搭配和数据初始化后，我们在页面点击开始 点击开始就是等于 点击了 itemcontainer 内的 router-link 就会跳到 item 路由判断就会根据 /item 判断 我们就会去到 crc/page/item/index.vue 这个结构我们就不说了和 home 一样 我们说一下 created 这是生命周期函数，表示进入界面已经加载完 dom 时执行 好我们也跟着 再一次回到了 itemcontainer 页面 template 判断得到是 item 执行显示出来头部和内容 header 显示第几题 div 这个就详细说一下重点就是在这里 那我们就来重点解说一下这个 div 因为数据已经导入进来前面说过了直奔内容 先看类名为 item_list_container 这里就是 item 的内容 用来判断是否还有题目 遍历数据 header 获取 vuex 内的 itemDetail 数组中的 第 0 个对象中的 topic_name （itemNum 是用来判断是第几题的，为什么是 itemNum-1 不用我说了把） ul li 遍历出选项 在 li 绑定了点击保存答案 id 的方法 做了一个 点击按钮绑定的样式 也做了一个 abcd 的遍历，定义方法通过不同的数值表示不同的字母 获取内容 最后两个 span 是用来判断下一题还是执行结算 最后的几个 vuex 问题都在这里了 先说 li 的保存答案 li 绑定了自定义的一个函数 choosed 有两个参数值 li 遍历的第几个 和 vuex 数据中的答案 id 看到 choosed 方法 当我们选择答案的时候 就会在记录在 choosedNum 和 choosedId 中 选择了答案的选项 当然就会击下一题 触发 自定义函数 nextItem 这个函数首先判断的是 通过choosedNum判断是否有选择答案，没有就弹框 有就把choosedNum清空 这是步骤是为了检测是否真的有输入（为什么不用输入的ID做呢，因为这里执行的是异步操作，用户可以继续做题，通过是否为空去判断，id传走执行其他操作，下一次传值覆盖掉就好了） 这里通过异步调用 方法 addNum 并传入答案id 前面说过位置在哪里这里就直接看执行方法 先同步执行了 ‘REMBER_ANSWER’ 这里是把答案添加到了 vuex 内的state中的answerid数组中 然后再判断题目还有没有，有就 执行’ADD_ITEMNUM’方法 加一题 一直如此到了最后一题的时候点击 itemNum就会比itemDetail长 哪就执行submitAnswe 还是判断有没有选择题目 执行添加最后一题答案 关闭定时器 路由添加score 跳转到score页面 好终于到了最后的页面了 src/page/score/index 这个页面也是分了两部分的不过前面说了那么多你们应该看得懂这个页面的所以就不多说 直接关心数据 还是用按需导入法 获取到了answerid 就是那个答案数组然后进行答案的计算 进入页面执行 computedScore和getScoreTip函数 好了这么一个 vue2 vuex 的小案例就分析完毕了 别看这个案例好像很小但是我们也说了很多了 本人才疏学浅花了几个小时才完全弄懂 麻雀虽小五脏俱全]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[各数据库的开启与服务器的开启]]></title>
    <url>%2F2018%2F11%2F15%2Fsql-fuq%2F</url>
    <content type="text"><![CDATA[本人记性不好写起来方便可以开启关闭 使用就不说了很简单自己摸索吧 数据库 本人才疏学浅只会mysql和mongod、sqlserver但是没装mysql 开启：sudo /usr/local/mysql/bin/mysqld_safe –skip-grant-tables 关闭：sudo /usr/local/mysql/bin/mysqladmin -u root -proot shutdown mysql 建议装 Navicat for mysql 图形化界面工具（虽说代码才是王道倒是也可以提高效率是真，而且本人太记得sql语句很适合） mongod mongod 开启相对比较简单 开启 sudo mongod 关闭 直接结束命令行就可以12345678910111213链接(默认链接本地服务)mongo退出exit基本命令:1. show dbs 查看显示所以数据库2. db 查看当前链接打数据库3. use 数据库名称 切换到指定打数据库（如果没有会新建）4. 插入数据5. show collections 查看数据集合 6. db.students.find() 查看库中所以的数据 服务器 xamp / mamp / apache 基本什么都可以用 但是用jsp就不太可以 (个人比较爱前两个，还有很多好用的服务器但是，本人用的是mac不是什么软件都能找到) apache-tomcat 就是用了使用javaweb（jsp）xampp 这个比较简单 界面开启就好 留一个 数据库的地址老是忘记 http://localhost/phpmyadmin/ MAMP 这个也是界面不说 Apache Mac电脑自带 开启 sudo apachectl start 关闭 sudo apachectl stop 重启 sudo apachectl restar 留几个配置网址以后好找 https://www.cnblogs.com/wanxudong/p/5846907.html https://jingyan.baidu.com/article/922554467d763b851648f4dc.html https://www.linuxidc.com/Linux/2016-03/129524.htm https://www.jianshu.com/p/f56815569234 apache-tomcat 开启 进入 服务器文件夹 找到 bin文件夹 在终端打开 执行 sudo sh startup.sh 关闭 同上 sudo sh shutdown.sh 不行就看网址 https://www.cnblogs.com/xingxingLove/p/5304390.html IntelliJ IDEA 写java，javaweb装这个软件 会自动检测本地得 apache-tomcat 基本不需要自己开启 软件自动调用开启服务，如果同时自己开了得话会起冲突的，自己记清楚 node 这个不用说自己写代码自己运行 sudo node app.js (有nodemon就最好啦)]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>数据库/服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决jsp给mysql传中文乱码]]></title>
    <url>%2F2018%2F11%2F15%2F2018-11-15%2F</url>
    <content type="text"><![CDATA[今天上课的时候做一个javaweb案例 用到了数据库 在我插入中文的时候发现了问题在我的数据库中发现，中文变成了问号 遇到这个问题第一时间肯定是检查 数据库-页面代码-服务器 问题肯定就在这三个里面 1. 我第一时间是看数据库 在数据库中设置了 utf-8 的字符集 但是在软件中设置 utf-8 保存后是看不见的 然后就去修改数据，当发现数据修改后可以成功的时候我知道数据库是没有问题的 2. 我再去看页面代码 首先检查发送数据的表单页设置utf8没 再检查 业务逻辑处理页面的utf8设置了没1&lt;%@ page contentType="text/html;charset=UTF-8" import="java.util.*,java.sql.*" language="java" pageEncoding="UTF-8" %&gt; 1&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; 发现加了还是没有效果 3. 我再去看 服务器 是否乱码 jsp 我用的是 apache tomcat 服务器 检测 服务器文件-&gt;conf-&gt;server.xml 文件 大概在 68 行左右的位置 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8"/&gt; 找到这句 看看 是否有设置 URIEncoding=”UTF-8” 但是做到了这里还是没有效果 4. 按道理做完前面的应该可以了啊 我再去看 业务逻辑代码 想起在链接数据库的时候加一个utf8的字符集可不可以 1conn=DriverManager.getConnection("jdbc:mysql://localhost:3306/book?useUnicode=true&amp;characterEncoding=UTF-8","root",""); 在数据库链接加入 ?useUnicode=true&amp;characterEncoding=UTF-8 来设置字符集 这样就成功显示了中文了]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
      <tags>
        <tag>JavaWeb笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue通过请求获取api接口数据/代理跨域]]></title>
    <url>%2F2018%2F11%2F10%2F2018-11-10%2F</url>
    <content type="text"><![CDATA[我知道也用过的有两种 vue-resource （已不维护了） axios （越来越多人用） vue代理跨域（补充） 那我们就来说是着么用吧1. vue-resource 引入的方法有 3 种 引入 1 直接使用网络的引用地址 （速度会慢一点） 引入 2 把包下载下来本地引用 引入 3 在项目中 用 npm 下载引用 在main.js文件内配置 下载 npm i vue-resource -S 有cnpm最好用cnpm安装快123456// 引入 包import VueResource from 'vue-resource';// 安装包Vue.use(VueResource);// 设置请求的根路径Vue.http.options.root = 'http://127.0.0.1:5000'; // 我们访问后台的路径大多相同所以直接设置根路径就不用每次都全部打了 使用方法 1234567&lt;!-- body中的代码 --&gt;&lt;div id="app"&gt; &lt;!-- 引用 --&gt; &lt;input type="button" value="get请求" @click="getInfo" /&gt; &lt;input type="button" value="post请求" @click="postInfo" /&gt; &lt;input type="button" value="jsonp请求" @click="jsonpInfo" /&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: '#app', data: &#123; &#125;, methods: &#123; getInfo() &#123; // 发起get请求 // 当发起get请求之后， 通过 .then 来设置成功的回调函数 this.$http.get('http://nodecms.applinzi.com/api/getcs').then(function (result) &#123; // 通过 result.body 拿到服务器返回的成功的数据 console.log(result.body) &#125;) &#125;, postInfo() &#123; // 发起 post 请求 application/x-wwww-form-urlencoded // 手动发起的 Post 请求，默认没有表单格式，所以，有的服务器处理不了 // 通过 post 方法的第三个参数， &#123; emulateJSON: true &#125; 设置 提交的内容类型 为 普通表单数据格式 this.$http.post('http://nodecms.applinzi.com/api/getpost', &#123;&#125;, &#123; emulateJSON: true &#125;).then(result =&gt; &#123; console.log(result.body) &#125;) &#125;, jsonpInfo() &#123; // 发起JSONP 请求 this.$http.jsonp('http://vue.studyit.io/api/jsonp').then(result =&gt; &#123; console.log(result.body) &#125;) &#125; &#125;&#125;); 2.axios 引入方法 方法1 项目安装 npm i axios -S (npm,cnpm,bower喜欢那个用那个) 方法2 用法和vue-resource差不多 main.js 配置 12345// 配置axiosimport Axios from 'axios'// 配置公共urlAxios.defaults.baseURL = 'http://127.0.0.1:5000/api/'Vue.prototype.$axios = Axios 使用 1234567this.$axios .get("getlunbo") .then(res =&gt; &#123; // res.data.message = [&#123;img: '图片地址'&#125;] this.imgs = res.data.message; &#125;) .catch(err =&gt; console.log("轮播图获取异常")); 3.代理跨域 虽然上面的方法都挺好但是面对跨域问题，如果后端不去设置的话就会出现跨域获取出错的问题 这里只是说 vue-cli 开启的项目设置代理跨域因为其他的我不太会 现在流行前后台分离开发，就是前端先前端的页面，后端写后端的接口。但是，当两者的工作合并的时候，要么前端自己搭建一个服务器，要么后端开启跨域让前端访问接口，我一般在开发的时候采用的是后者。但是这个是很坑的，经常出现无法跨域的错误。 Vue-cli中自带了代理，当你配置了这个代理之后，你访问他人电脑的接口的时候，就像访问自己本机的接口一样，避免了跨域的问题。 cli2 首先找到，config下面的index.js，然后，打开，关键代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748dev: &#123; // Paths assetsSubDirectory: 'static', assetsPublicPath: '/', proxyTable: &#123; '/Home' : &#123; target: 'https://lit-plains-29389.herokuapp.com', changeOrigin: true, &#125;, "/api":&#123; target: 'https://lit-plains-29389.herokuapp.com', changeOrigin: true, pathRewrite: &#123; '^/api': '/' &#125; &#125; &#125;, // Various Dev Server settings host: 'localhost', // can be overwritten by process.env.HOST port: 8080, // can be overwritten by process.env.PORT, if port is in use, a free one will be determined autoOpenBrowser: false, errorOverlay: true, notifyOnErrors: true, poll: false, // https://webpack.js.org/configuration/dev-server/#devserver-watchoptions- // Use Eslint Loader? // If true, your code will be linted during bundling and // linting errors and warnings will be shown in the console. useEslint: false, // If true, eslint errors and warnings will also be shown in the error overlay // in the browser. showEslintErrorsInOverlay: false, /** * Source Maps */ // https://webpack.js.org/configuration/devtool/#development devtool: 'cheap-module-eval-source-map', // If you have problems debugging vue-files in devtools, // set this to false - it *may* help // https://vue-loader.vuejs.org/en/options.html#cachebusting cacheBusting: true, cssSourceMap: true&#125; target就是要代理到的目标地址，changeOrigin的意思相比不必多说了。至于pathRewrite，就是在这个例子中，比如/Home/Index就会映射到https://lit-plains-29389.herokuapp.com/Home/Index,而如果开启了这个选项，比如第二个，假设/api/Home/Index,则会映射到https://lit-plains-29389.herokuapp.com/Home/Index。 简单点说就是做一个替换 说明：我的vue-cli所在的端口是localhos:8080 cli3 cli3 和cli2 有一定的区别，就是cli3没有了配置文件，那么我们需要自己去配置 在根目录新建 vue.config.js 这个文件作为配置文件 写入配置代码12345678910111213141516module.exports = &#123; // 修改的配置 // 将baseUrl: '/api',改为baseUrl: '/', baseUrl: '/', devServer: &#123; proxy: &#123; // 代理跨域 '/api': &#123; // 代理url关键字 target: 'http://localhost:5000', // 需要代理的地址 changeOrigin: true, // 是否跨域 pathRewrite: &#123; // 用来做字节更换，比如接口没有api的，那我们前端调用接口用api开头，在这里就把api替换为空，那就和后端结合了，如果不需要那就不加这个 '^/api': '' &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 装修地址]]></title>
    <url>%2F2018%2F11%2F09%2F2018-11-09(2)%2F</url>
    <content type="text"><![CDATA[知乎 hexonext 主题添加页面 3d 动画xiao’sblog 优化添加主题音乐主题添加分类主题不显示全文添加侧边栏小图标hester 博客优化]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo装修</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ngrok 外网映射 （解决测试时外部无法访问本地网站的）]]></title>
    <url>%2F2018%2F11%2F09%2F2018-11-09%2F</url>
    <content type="text"><![CDATA[日常开发坑 在我们做开发的同学们很多时候开发好了一个项目之后发现只是可以再电脑内部去查看或者是通过本地端口设置同一网络下查看业务 那么我们肯定会想上到线上项目不需要在同一网络下也可以去访问 那么第一时间我们肯定是会想到 云端服务器 阿里云/新浪云/腾讯云等很多的网上服务器 对的我也想到了，当是首先 网上服务器要钱买 网上服务器要配置 再想想我就想丢上去看看而已替换成外网测试一下看看行不行 买服务器不是买一天两天想着应该用不完 那么我就发现了一个好用的东西 ngrok 外网映射 ngrok 并不是真的就把项目就挂载到了网上 是通过 映射端口 把本地端口映射到了外网 所以当我们吧 ngrok 关闭 或者是 本地的服务关闭了后就会断开 在使用之前要有 apache 服务器 （mac 是自带的 win 自己安装 配置这里我就不说虽然 mac 自带但是我弄了好久现在不想再去说了 ） （也不一定非要用 apache 服务器的因为是映射端口有开启服务就好） 把项目部署到了 apache 服务器 开启服务 本地查看是否可以运行 说了那么多废话现在开始走进 ngrok 的世界 ngrok 下载官网 不急着下载因为后面的步骤需要用到全局配置 所有先注册一个账号 有 github 的可以直接登录 然后点击 download 那个下载就好啦 把安装包下载下来之后手动解压就可以了 然后打开终端 在解压出 ngrok 的文件夹下执行配置 ./ngrok authtoken 3fW4eXHdUN3ziCBXcahZ_3tnDdaTyLw8tKzJtKZkLp 3 开头这一段每个人都不同的根据登录的账号会有提示的 最后一步就是 映射端口 根据你本地开启的端口而定 ./ngrok http 80 （开启的是 80 端口就用 80 端口，默认 apache 是 80 端口） 前面那么多字懒得看看不懂的还是来看图解把]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>外网映射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue-cli安装/使用]]></title>
    <url>%2F2018%2F11%2F07%2Fvue-cli%2F</url>
    <content type="text"><![CDATA[vue-cli(vue 脚手架) 在开发得时候用 vue 做开发但是写多了感觉能不能一开始就有现成得不用去配置拿来就能用 真的有 vue-cli vue 脚手架 不说那么多直接开干 确保电脑有安装 node/npm （不多说不懂去标签 node 找 node 安装）地址 使用 vue-cli 是以来 webpack 使用得所以安装 webpack 先 以往用 webpack 直接安装就行 webpack 4.x 开始要以来 webpack-cli 依赖 全局安装 webpack 和 webpack-cli sudo npm install webpack webpack-cli -g 安装完 webpack -v 看看安装到了没有 千新万苦终于搞完前面现在安装 vue-cli sudo npm install –global vue-cli 安装完 vue -v 查看版本 不多说装完直接使用 进入到你要开发的磁盘位置 先去那里就去那里 sudo vue init webpack baoge (这个 baoge 就是项目的名字自己定) 然后就到了后面的配置项了 Project name (baoge)： —–项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错 Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。 Project description (A Vue.js project)： —-项目描述，也可直接点击回车，使用默认名字 Author ()： —-作者，输入你的大名 接下来会让用户选择： Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了 Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y/n) 是否安装 vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y/n) 是否使用 ESLint 管理代码，ESLint 是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。 接下来也是选择题 Pick an ESLint preset (Use arrow keys) 选择一个 ESLint 预设，编写 vue 项目时的代码风格，直接 y 回车 Setup unit tests with Karma + Mocha? (Y/n) 是否安装单元测试，我选择安装 y 回车 Setup e2e tests with Nightwatch(Y/n)? 是否安装 e2e 测试 ，我选择安装 y 回车 不想死的 UseESLint to lint your code 必须输入 n 不然标准模式下会让你痛不欲生（觉得自己代码很他妈规范的就用吧） 不过即使一开始的时候没有注意到点击了确定开启了 eslint 也不用怕，教你如何关闭 ESLint 在项目中找到 config 文件夹，进入文件夹 找到 index.js 文件 在大概 26 行左右的位置 useEslint:true 会有这么一句命令 改为 false 就好啦 useEslint:false 记住这个东西是用 webpack 执行的如果是开启服务的时候修改请重启一下服务 还有一个方法可以不用关掉这个 eslint 就是安装插件让它自动的帮你检查格式化 使用的编程软件是 vs code 微软出的 安装什么插件我就不详细说了，点下面链接自己琢磨 插件地址 vue-cli3 开启项目方法 开启项目(my-project自定义) 1$ vue create my-project 选择模式 （一般选择第二个） default (babel, eslint) 默认套餐，提供 babel 和 eslint 支持。 Manually select features 自己去选择需要的功能，提供更多的特性选择。比如如果想要支持 TypeScript ，就应该选择这一项。 选择配置（可以多选：使用方向键在特性选项之间切换，使用空格键选中当前特性，使用 a 键切换选择所有，使用 i 键翻转选项。） TypeScript 支持使用 TypeScript 书写源码。 Progressive Web App (PWA) Support PWA 支持。 Router 支持 vue-router 。 Vuex 支持 vuex 。 CSS Pre-processors 支持 CSS 预处理器。 Linter / Formatter 支持代码风格检查和格式化。 Unit Testing 支持单元测试。 E2E Testing 支持 E2E 测试。 一路按照需求选 启动项目 cd my-project npm run serve]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>vue插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node/php使用心得]]></title>
    <url>%2F2018%2F11%2F07%2F2018-11-07%2F</url>
    <content type="text"><![CDATA[今天有个师弟让我写一个用户注册权限的后端服务，第一个想法是用node，但是他的服务端没有node，只有php，可能是我很久没有写php的代码所以写起来还是很不习惯，写node的时候只是关心，接口，业务逻辑，操作数据库分开三步写很顺手，但是用php写，顿时脑子是比较空白的，长时间不去使用一个语言突然就要去写真的就会想不起来这么写好，只能看着以前写过的服务一点一点的拿起来，虽然是写出来了但是感觉用起来还是觉得node比php好用，虽然用起来都是比较简单 node 判断路由-&gt;业务逻辑-&gt;数据库操作php 业务逻辑-&gt;数据库操作]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[完成YHF-Vue项目心得]]></title>
    <url>%2F2018%2F11%2F04%2F2018-11-04%2F</url>
    <content type="text"><![CDATA[完成了vue项目的时候，内心是很开心的，终于做成了一个小项目了，从当初的只是一个界面到，后面要去写后端，但是一开始不会写后端接口，那个时候真的很烦躁，后来发现了一个别人写好的跨域交互的案例，就打开来看学着别人的去写，那时候发现噢原来我自己也是可以用node去写后端的接口的喔，那时候就用node去写接口，顺着别人的思路和骨架去写，后面发现不单止要写后端接口还要去操作数据库，虽然我会一点点数据库操作，但是我对数据库的设计并不是非常的了解，只可以边写前端的页面需要用到什么的时候，看着教程的项目接口自己去设计和操作数据库，一开始也是很多碰壁的，设计好数据库图片数据用什么方式存呢也想了很久，后面就是操作数据库查询，也是一点一点的写上网查询慢慢的去改进，解决了后端的事情还是继续去写前端，就是一次又一次的写前端页面-&gt;接口-&gt;操作数据-&gt;获取返回数据，在这个时候我发现其实做后端开发也是不容易虽然说是分好路由、业务逻辑、操作数据库，但是还是挺苦的，慢慢端熟悉了其实也觉得没什么吧，在写前端页面的时候虽然是跟着教程做但是也是出现了很多的bug，也是让我很苦恼，这只是一个小小的项目就让我心态都要奔溃了，这个购物商场也还是没有写完的呢还有很多的功能可以完善，其实我很想说项目写到了后面前面的好像又忘记了，我的天啊这样着么在it界混下去呢；很多的技术好像都学过但是到了用的时候发现自己脑子里面好像什么都没有，好像自己从来都没有接触过一样，一步一步慢慢的走吧！准备写一个博客的小项目]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day10]]></title>
    <url>%2F2018%2F11%2F04%2FVue-day10%2F</url>
    <content type="text"><![CDATA[开启Apache的gzip压缩要让apache支持gzip功能，要用到deflate_Module和headers_Module。打开apache的配置文件httpd.conf，大约在105行左右，找到以下两行内容：（这两行不是连续在一起的）12#LoadModule deflate_module modules/mod_deflate.so#LoadModule headers_module modules/mod_headers.so 然后将其前面的“#”注释删掉，表示开启gzip压缩功能。开启以后还需要进行相关配置。在httpd.conf文件的最后添加以下内容即可：12345&lt;IfModule deflate_module&gt; #必须的，就像一个开关一样，告诉apache对传输到浏览器的内容进行压缩 SetOutputFilter DEFLATE DeflateCompressionLevel 9&lt;/IfModule&gt; 最少需要加上以上内容，才可以生gzip功能生效。由于没有做其它的额外配置，所以其它相关的配置均使用Apache的默认设置。这里说一下参数“DeflateCompressionLevel”，它表示压缩级别，值从1到9，值越大表示压缩的越厉害。 使用ngrok将本机映射为一个外网的Web服务器注意：由于默认使用的美国的服务器进行中间转接，所以访问速度炒鸡慢，访问时可启用FQ软件，提高网页打开速度！]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YHF-Vue 前后端交互 购物城项目]]></title>
    <url>%2F2018%2F11%2F04%2Fyhf-vue%2F</url>
    <content type="text"><![CDATA[案例分布 前端 (2.vue-cms) webpack vue 后端 (node_server) node 数据库 (VueUser.sql) mysql 后端接口api 插件安装配置 完整项目下载Github 码云前端地址 码云后端地址 更多vue学习请看 vue1-vue11笔记 YHF·Vue 项目 说明 初始化项目 搭建基础架构 安装依赖 测试架构能否执行 搭建项目主页 主页头部 Header,使用 MintUI 的 Header 组件 主页底部 Tabbar,使用 MUI 的 Tabbar.html 在制作 购物车 小图标的时候，操作会相对多一些： 先把 扩展图标的 css 样式，拷贝到 项目中 拷贝 扩展字体库 ttf 文件，到项目中 为 购物车 小图标 ，添加 如下样式 mui-icon mui-icon-extra mui-icon-extra-cart 要在 中间区域放一个 router-view 来展示路由匹配到的区域 改造 tabbar 为 router-link 实现路由切换高亮 linkActiveClass: ‘mui-active’ // 覆盖默认的路由高亮的类 点击 tabbar 中的路由链接，展示对应的路由组件 导入对应的组件 配置路由 在 app.vue 插入 router-view 添加轮播图 加载首页轮播图数据 获取数据， 如何获取呢， 使用 vue-resource 使用 vue-resource 的 this.$http.get 获取数据 获取到的数据，要保存到 data 身上 使用 v-for 循环渲染 每个 item 项 改造 九宫格 区域的样式 改造 新闻资讯 路由链接 新闻资讯 页面 制作 绘制界面， 使用 MUI 中的 media-list.html 使用 vue-resource 获取数据 渲染真实数据 实现 新闻资讯列表 点击跳转到新闻详情 把列表中的每一项改造为 router-link,同时，在跳转的时候应该提供唯一的 Id 标识符 创建新闻详情的组件页面 NewsInfo.vue 在 路由模块中，将 新闻详情的 路由地址 和 组件页面对应起来 实现 新闻详情 的 页面布局 和数据渲染 单独封装一个 comment.vue 评论子组件 先创建一个 单独的 comment.vue 组件模板 在需要使用 comment 组件的 页面中，先手动 导入 comment 组件 import comment from &#39;./comment.vue&#39; 在父组件中，使用 components 属性，将刚才导入 comment 组件，注册为自己的 子组件 将注册子组件时候的，注册名称，以 标签形式，在页面中 引用即可 获取所有的评论数据显示到页面中 实现点击加载更多评论的功能 为加载更多按钮，绑定点击事件，在事件中，请求 下一页数据 点击加载更多，让 pageIndex++ , 然后重新调用 this.getComments() 方法重新获取最新一页的数据 为了防止 新数据 覆盖老数据的情况，我们在 点击加载更多的时候，每当获取到新数据，应该让 老数据 调用 数组的 concat 方法，拼接上新数组 发表评论 把文本框做双向数据绑定 为发表按钮绑定一个事件 校验评论内容是否为空，如果为空，则 Toast 提示用户 评论内容不能为空 通过 vue-resource 发送一个请求，把评论内容提交给 服务器 当发表评论 OK 后，重新刷新列表，以查看最新的评论 如果调用 getComments 方法重新刷新评论列表的话，可能只能得到 最后一页的评论，前几页的评论获取不到 换一种思路： 当评论成功后，在客户端，手动拼接出一个 最新的评论对象，然后 调用 数组的 unshift 方法， 把最新的评论，追加到 data 中 comments 的开头；这样，就能 完美实现刷新评论列表的需求； 改造图片分析 按钮为 路由的链接并显示对应的组件页面 绘制 图片列表 组件页面结构并美化样式 制作 顶部的滑动条 制作 底部的图片列表 制作顶部滑动条的坑们： 需要借助于 MUI 中的 tab-top-webview-main.html 需要把 slider 区域的 mui-fullscreen 类去掉 滑动条无法正常触发滑动，通过检查官方文档，发现这是 JS 组件，需要被初始化一下： 导入 mui.js 调用官方提供的 方式 去初始化：123mui(&apos;.mui-scroll-wrapper&apos;).scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006&#125;); 我们在初始化 滑动条 的时候，导入的 mui.js ，但是，控制台报错： Uncaught TypeError: &#39;caller&#39;, &#39;callee&#39;, and &#39;arguments&#39; properties may not be accessed on strict mode 经过我们合理的推测，觉得，可能是 mui.js 中用到了 ‘caller’, ‘callee’, and ‘arguments’ 东西，但是， webpack 打包好的 bundle.js 中，默认是启用严格模式的，所以，这两者冲突了； 解决方案： 1. 把 mui.js 中的 非严格 模式的代码改掉；但是不现实； 2. 把 webpack 打包时候的严格模式禁用掉； 最终，我们选择了 plan B 移除严格模式： 使用这个插件 babel-plugin-transform-remove-strict-mode 刚进入 图片分享页面的时候， 滑动条无法正常工作， 经过我们认真的分析，发现， 如果要初始化 滑动条，必须要等 DOM 元素加载完毕，所以，我们把 初始化 滑动条 的代码，搬到了 mounted 生命周期函数中； 当 滑动条 调试 OK 后，发现， tabbar 无法正常工作了，这时候，我们需要把 每个 tabbar 按钮的 样式中 mui-tab-item 重新改一下名字； 获取所有分类，并渲染 分类列表； 制作图片列表区域 图片列表需要使用懒加载技术，我们可以使用 Mint-UI 提供的现成的 组件 lazy-load 根据lazy-load的使用文档，尝试使用 渲染图片列表数据 实现了 图片列表的 懒加载改造和 样式美化 实现了 点击图片 跳转到 图片详情页面 在改造 li 成 router-link 的时候，需要使用 tag 属性指定要渲染为 哪种元素 实现 详情页面的布局和美化，同时获取数据渲染页面 实现 图片详情中 缩略图的功能 使用 插件 vue-preview 这个缩略图插件 获取到所有的图片列表，然后使用 v-for 指令渲染数据 注意： img 标签上的 class 不能去掉 注意： 每个 图片数据对象中，必须有 w 和 h 属性 绘制 商品列表 页面基本结构并美化 尝试在手机上 去进行项目的预览和测试 要保证自己的手机可以正常运行； 要保证 手机 和 开发项目的电脑 处于同一个 WIFI 环境中，也就是说 手机 可以 访问到 电脑的 IP 打开自己的 项目中 package.json 文件，在 dev 脚本中，添加一个 –host 指令， 把 当前 电脑的 WIFI IP 地址， 设置为 –host 的指令值； 如何查看自己电脑所处 WIFI 的 IP 呢， 在 cmd 终端中运行 ipconfig ， 查看 无线网的 ip 地址 把项目 git 远端存储库 开源协议 廖雪峰教 git 初始化 git sudo git init sudo git status sudo git add . sudo git commit -m “add init” sudo git remote add origin https://github.com/YHF7/YHF7.github.io.git sudo git push -u origin master 案例效果图]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue/node 前后台交互演练]]></title>
    <url>%2F2018%2F10%2F26%2FVue-interactive%2F</url>
    <content type="text"><![CDATA[前后台交互 在我们做项目的时候，会分为前端和后端 前端：前端负责界面 后端：后端负责数据处理 前端会有很多的框架和交互的方式 在我们做数据交互的时候 会碰到跨域的问题 当你使用 vue 作为页面框架的时候 就会开启前端的 vue 的 npm 服务 当你使用 node 作为页面后端的服务器的时候 就会开启后端 的 node 服务 那么问题就来了 当你开启 npm 服务 和 node 服务的时候 分别都有两个端口 vue的 npm端口 去获取 node得服务得时候 就会出现在两个不同得服务处在不同得域内 这样就出现了跨域问题了 既然出现了跨域问题，那么着么去解决这个跨域得问题呢 方法一：在后端服务中设置请求报文头 方法二：在 vue 的 webpack 中的配置文件中设置代理跨域 （不会暂时不写） 后台服务设置跨域(设置请求报文头就可以)123456789101112//2.0 将所有api的请求响应content-type设置为application/jsonapp.all('/api/*', (req, res, next) =&gt; &#123; //设置允许跨域响应报文头 //设置跨域 // 启用 Node 服务器端的 cors 跨域 res.header("Access-Control-Allow-Origin", "*"); res.header("Access-Control-Allow-Headers", "X-Requested-With"); res.header("Access-Control-Allow-Methods", "*"); res.setHeader('Content-Type', 'application/json;charset=utf-8'); next();&#125;); 项目演练 项目地址 Vue与Node交互项目演练 使用项目 把地址里面都 vue-jh 这个包下载下来（用迅雷可以直接下载） 项目分布 vue-tepmlate 是 vue 的前端案例 index.html 是渲染的主页（留坑） App.vue 是主页 vue 模块 main.js 是业务逻辑 router.js 路由 webpack.config.js 是 vue webpack 的配置文件 node_server 是 node 的后端服务 app.js 是node 服务 controller.js 业务逻辑 model.js 操作数据库 router.js 路由 分别打开这两个文件在终端安装依赖 suco cnpm i (安装依赖包) 分别开启服务 vue-tepmlate sudo npm run dev node_server sudo node app.js (或) sudo nodemon app.js 还有个最重要的是配置数据库 在 node_serve 中的model.js 文件中配置本地的mysql数据库]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>交互</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[心态蹦]]></title>
    <url>%2F2018%2F10%2F24%2F2018-10-24%2F</url>
    <content type="text"><![CDATA[颓废了好几天的我今天终于下定决心要走出颓废的日子，我告诉自己在这样下去真的点就输了一辈子了，不想在这样颓废下去，遇到一点点的问题，就颓废这是作为一个十几岁的青年该有的的吗，为什么要这样下去后端开发是啥 我要学过后台开发啊，为啥我就写不出来呢，接口？交互？ 这些我好像都学过啊， 但是 vue 与 node php 如何交互呢？ 作为主攻前端的 是应该花时间系统的去学习后端吗 ， node 刚学完啊， 为什么不去 用 node 呢有想用 node 也有想用 php 但是着么写呢 这个交互的过程着么去做呢 就因为做个练习没有后台接口 颓废了好几天？ 虽然我还没有解决这个问题 但是我不想在这样下去了，我会输掉自己的 继续努力]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day8/9]]></title>
    <url>%2F2018%2F10%2F24%2FVue-day8%609%2F</url>
    <content type="text"><![CDATA[PromisePromise 概念 Promise 是一个 构造函数，既然是构造函数， 那么，我们就可以 new Promise() 得到一个 Promise 的实例； 在 Promise 上，有两个函数，分别叫做 resolve（成功之后的回调函数） 和 reject（失败之后的回调函数） 在 Promise 构造函数的 Prototype 属性上，有一个 .then() 方法，也就说，只要是 Promise 构造函数创建的实例，都可以访问到 .then() 方法 Promise 表示一个 异步操作；每当我们 new 一个 Promise 的实例，这个实例，就表示一个具体的异步操作； 既然 Promise 创建的实例，是一个异步操作，那么，这个 异步操作的结果，只能有两种状态： 状态1： 异步执行成功了，需要在内部调用 成功的回调函数 resolve 把结果返回给调用者； 状态2： 异步执行失败了，需要在内部调用 失败的回调函数 reject 把结果返回给调用者； 由于 Promise 的实例，是一个异步操作，所以，内部拿到 操作的结果后，无法使用 return 把操作的结果返回给调用者； 这时候，只能使用回调函数的形式，来把 成功 或 失败的结果，返回给调用者； 我们可以在 new 出来的 Promise 实例上，调用 .then() 方法，【预先】 为 这个 Promise 异步操作，指定 成功（resolve） 和 失败（reject） 回调函数； 注意：这里 new 出来的 promise， 只是代表 【形式上】的一个异步操作； 什么是形式上的异步操作：就是说，我们只知道它是一个异步操作，但是做什么具体的异步事情，目前还不清楚 var promise = new Promise() 每当 new 一个 Promise 实例的时候，就会立即 执行这个 异步操作中的代码 也就是说，new 的时候，除了能够得到 一个 promise 实例之外，还会立即调用 我们为 Promise 构造函数传递的那个 function，执行这个 function 中的 异步操作代码； Promise 使用1234567891011121314151617181920212223const fs = require('fs')const path = require('path')// 定义一个promise// 初衷： 给路径，返回读取到的内容function getFileByPath(fpath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fpath, 'utf-8', (err, dataStr) =&gt; &#123; if (err) return reject(err) resolve(dataStr) &#125;) &#125;)&#125;getFileByPath(path.join(__dirname, './files/1.txt') .then(function (data) &#123; // .then 成功时调用 console.log(data + '-------') &#125;, function (err) &#123; // 第二个函数 失败时调用 console.log(err.message) &#125;) Promise 使用回调地狱123456789101112131415161718192021222324252627282930313233const fs = require('fs')const path = require('path')function getFileByPath(fpath) &#123; return new Promise(function (resolve, reject) &#123; fs.readFile(fpath, 'utf-8', (err, dataStr) =&gt; &#123; if (err) return reject(err) resolve(dataStr) &#125;) &#125;)&#125;getFileByPath('./files/1.txt') .then(function (data) &#123; console.log(data) // 读取文件2 return getFileByPath('./files/2.txt') &#125;) .then(function (data) &#123; console.log(data) return getFileByPath('./files/3.txt') &#125;) .then(function (data) &#123; console.log(data) &#125;) .catch(function (err) &#123; // catch 的作用： 如果前面有任何的 Promise 执行失败，则立即终止所有 promise 的执行，并 马上进入 catch 去处理 Promise中 抛出的异常； console.log('这是自己的处理方式：' + err.message) &#125;) 使用mui的tab-top-webview-main完成分类滑动栏兼容问题 和 App.vue 中的 router-link 身上的类名 mui-tab-item 存在兼容性问题，导致tab栏失效，可以把mui-tab-item改名为mui-tab-item1，并复制相关的类样式，来解决这个问题； 123456789101112131415161718192021222324252627282930.mui-bar-tab .mui-tab-item1.mui-active &#123; color: #007aff;&#125;.mui-bar-tab .mui-tab-item1 &#123; display: table-cell; overflow: hidden; width: 1%; height: 50px; text-align: center; vertical-align: middle; white-space: nowrap; text-overflow: ellipsis; color: #929292;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon &#123; top: 3px; width: 24px; height: 24px; padding-top: 0; padding-bottom: 0;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon~.mui-tab-label &#123; font-size: 11px; display: block; overflow: hidden; text-overflow: ellipsis;&#125; tab-top-webview-main组件第一次显示到页面中的时候，无法被滑动的解决方案： 先导入 mui 的JS文件: 1import mui from &apos;../../../lib/mui/js/mui.min.js&apos; 在 组件的 mounted 事件钩子中，注册 mui 的滚动事件： 123456mounted() &#123; // 需要在组件的 mounted 事件钩子中，注册 mui 的 scroll 滚动事件 mui(&apos;.mui-scroll-wrapper&apos;).scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006 &#125;);true&#125; 滑动的时候报警告：Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080 1解决方法，可以加上* &#123; touch-action: none; &#125; 这句样式去掉。 原因：（是chrome为了提高页面的滑动流畅度而新折腾出来的一个东西） http://www.cnblogs.com/pearl07/p/6589114.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action 移除严格模式babel-plugin-transform-remove-strict-mode vue-preview一个Vue集成PhotoSwipe图片预览插件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day7]]></title>
    <url>%2F2018%2F10%2F20%2FVue-day7%2F</url>
    <content type="text"><![CDATA[使用 饿了么的 MintUI 组件Github 仓储地址 Mint-UI官方文档 导入所有MintUI组件： 12import MintUI from &apos;mint-ui&apos; 导入样式表： 12import &apos;mint-ui/lib/style.css&apos; 在 vue 中使用 MintUI中的Button按钮和Toast弹框提示： 12Vue.use(MintUI) 使用的例子： 12&lt;mt-button type=&quot;primary&quot; size=&quot;large&quot;&gt;primary&lt;/mt-button&gt; Mint-UI中按需导入的配置方式 修改 .babelrc 1234567891011&#123; &quot;presets&quot;: [ [&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;] ], &quot;plugins&quot;: [[&quot;component&quot;, [ &#123; &quot;libraryName&quot;: &quot;mint-ui&quot;, &quot;style&quot;: true &#125; ]]]&#125; 导入所有babel-plugin-componen组件： 12import &#123; Button, Cell &#125; from &apos;mint-ui&apos; 引入部分组件 12345678Vue.component(Button.name, Button)// Button.name 是可以自定义的 例如 Vue.component(&quot;mybtn&quot;, Button)Vue.component(Cell.name, Cell)/* 或写为 * Vue.use(Button) * Vue.use(Cell) */ 使用的例子： 123&lt;mt-button type=&quot;primary&quot; size=&quot;large&quot;&gt;primary&lt;/mt-button&gt;// 假如改变了 名字 那就要用自定义的组件名称 &lt;mybtn&gt;1233&lt;/mybtn&gt; Mint-UI中按需导入的配置方式使用 MUI 代码片段 注意： MUI 不同于 Mint-UI，MUI只是开发出来的一套好用的代码片段，里面提供了配套的样式、配套的HTML代码段，类似于 Bootstrap； 而 Mint-UI，是真正的组件库，是使用 Vue 技术封装出来的 成套的组件，可以无缝的和 VUE项目进行集成开发；因此，从体验上来说， Mint-UI体验更好，因为这是别人帮我们开发好的现成的Vue组件；从体验上来说， MUI和Bootstrap类似；理论上，任何项目都可以使用 MUI 或 Bootstrap，但是，MInt-UI只适用于Vue项目； 注意： MUI 并不能使用 npm 去下载，需要自己手动从 github 上，下载现成的包，自己解压出来，然后手动拷贝到项目中使用； 官网首页 文档地址 导入 MUI 的样式表： 12import &apos;../lib/mui/css/mui.min.css&apos; 在webpack.config.js中添加新的loader规则： 12&#123; test: /\.(png|jpg|gif|ttf)$/, use: &apos;url-loader&apos; &#125; 根据官方提供的文档和example，尝试使用相关的组件 将项目源码托管到oschina中 点击头像 -&gt; 修改资料 -&gt; SSH公钥 如何生成SSH公钥 创建自己的空仓储，使用 git config --global user.name &quot;用户名&quot; 和 git config --global user.email ***@**.com 来全局配置提交时用户的名称和邮箱 使用 git init 在本地初始化项目 使用 touch README.md 和 touch .gitignore 来创建项目的说明文件和忽略文件； 使用 git add . 将所有文件托管到 git 中 使用 git commit -m &quot;init project&quot; 将项目进行本地提交 使用 git remote add origin 仓储地址将本地项目和远程仓储连接，并使用origin最为远程仓储的别名 使用 git push -u origin master 将本地代码push到仓储中 App.vue 组件的基本设置 头部的固定导航栏使用 Mint-UI 的 Header 组件； 底部的页签使用 mui 的 tabbar; 购物车的图标，使用 icons-extra 中的 mui-icon-extra mui-icon-extra-cart，同时，应该把其依赖的字体图标文件 mui-icons-extra.ttf，复制到 fonts 目录下！ 将底部的页签，改造成 router-link 来实现单页面的切换； Tab Bar 路由激活时候设置高亮的两种方式： 全局设置样式如下： 123456.router-link-active&#123; color:#007aff !important; &#125; 或者在 new VueRouter 的时候，通过 linkActiveClass 来指定高亮的类： 1234567891011121314// 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/home&apos; &#125; ], linkActiveClass: &apos;mui-active&apos; &#125;); 实现 tabbar 页签不同组件页面的切换 将 tabbar 改造成 router-link 形式，并指定每个连接的 to 属性； 在入口文件中导入需要展示的组件，并创建路由对象： 12345678910111213141516171819202122232425262728293031323334// 导入需要展示的组件import Home from &apos;./components/home/home.vue&apos;import Member from &apos;./components/member/member.vue&apos;import Shopcar from &apos;./components/shopcar/shopcar.vue&apos;import Search from &apos;./components/search/search.vue&apos;// 创建路由对象var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/home&apos; &#125;, &#123; path: &apos;/home&apos;, component: Home &#125;, &#123; path: &apos;/member&apos;, component: Member &#125;, &#123; path: &apos;/shopcar&apos;, component: Shopcar &#125;, &#123; path: &apos;/search&apos;, component: Search &#125; ], linkActiveClass: &apos;mui-active&apos;&#125;); 使用 mt-swipe 轮播图组件 假数据： 12345678910lunbo: [ &apos;http://www.itcast.cn/images/slidead/BEIJING/2017440109442800.jpg&apos;, &apos;http://www.itcast.cn/images/slidead/BEIJING/2017511009514700.jpg&apos;, &apos;http://www.itcast.cn/images/slidead/BEIJING/2017421414422600.jpg&apos; ] 引入轮播图组件： 123456789101112131415161718&lt;!-- Mint-UI 轮播图组件 --&gt; &lt;div class=&quot;home-swipe&quot;&gt; &lt;mt-swipe :auto=&quot;4000&quot;&gt; &lt;mt-swipe-item v-for=&quot;(item, i) in lunbo&quot; :key=&quot;i&quot;&gt; &lt;img :src=&quot;item&quot; alt=&quot;&quot;&gt; &lt;/mt-swipe-item&gt; &lt;/mt-swipe&gt; &lt;/div&gt; &lt;/div&gt; 在.vue组件中使用vue-resource获取数据 运行cnpm i vue-resource -S安装模块 导入 vue-resource 组件 12import VueResource from &apos;vue-resource&apos; 在vue中使用 vue-resource 组件 12Vue.use(VueResource); 使用mui的tab-top-webview-main完成分类滑动栏兼容问题 和 App.vue 中的 router-link 身上的类名 mui-tab-item 存在兼容性问题，导致tab栏失效，可以把mui-tab-item改名为mui-tab-item1，并复制相关的类样式，来解决这个问题； 123456789101112131415161718192021222324252627282930.mui-bar-tab .mui-tab-item1.mui-active &#123; color: #007aff;&#125;.mui-bar-tab .mui-tab-item1 &#123; display: table-cell; overflow: hidden; width: 1%; height: 50px; text-align: center; vertical-align: middle; white-space: nowrap; text-overflow: ellipsis; color: #929292;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon &#123; top: 3px; width: 24px; height: 24px; padding-top: 0; padding-bottom: 0;&#125;.mui-bar-tab .mui-tab-item1 .mui-icon~.mui-tab-label &#123; font-size: 11px; display: block; overflow: hidden; text-overflow: ellipsis;&#125; tab-top-webview-main组件第一次显示到页面中的时候，无法被滑动的解决方案： 先导入 mui 的JS文件: 1import mui from &apos;../../../lib/mui/js/mui.min.js&apos; 在 组件的 mounted 事件钩子中，注册 mui 的滚动事件： 123456mounted() &#123; // 需要在组件的 mounted 事件钩子中，注册 mui 的 scroll 滚动事件 mui(&apos;.mui-scroll-wrapper&apos;).scroll(&#123; deceleration: 0.0005 //flick 减速系数，系数越大，滚动速度越慢，滚动距离越小，默认值0.0006 &#125;);true&#125; 滑动的时候报警告：Unable to preventDefault inside passive event listener due to target being treated as passive. See https://www.chromestatus.com/features/5093566007214080 1解决方法，可以加上* &#123; touch-action: none; &#125; 这句样式去掉。 原因：（是chrome为了提高页面的滑动流畅度而新折腾出来的一个东西） http://www.cnblogs.com/pearl07/p/6589114.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/CSS/touch-action 移除严格模式babel-plugin-transform-remove-strict-mode vue-preview一个Vue集成PhotoSwipe图片预览插件]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day6 案例]]></title>
    <url>%2F2018%2F10%2F19%2F2018-10-19%2F</url>
    <content type="text"><![CDATA[案例分布 webpack-vue (webpack中使用vue) webpack-vue-router webpack-路由嵌套 抽离路由 一、webpack-vue重点 webpack 中使用vue 安装 vue 包 导入组件 安装 vue 打包插件 render 渲染页面 export default 和 export 向外暴露成员 注意： export default 向外暴露的成员，可以使用任意的变量来接收 注意： 在一个模块中，export default 只允许向外暴露1次 注意： 在一个模块中，可以同时使用 export default 和 export 向外暴露成员 import 接收成员 小案例(前往github)webpack-vue 二、webpack-vue-router重点 在webpack 中使用路由 安装 vue-router 手动安装vuerouter 创建路由 挂载路由 router-view 显示路由小案例(前往github)webpack-vue-router 三、webpack-路由嵌套 抽离路由重点 嵌套路由 定义子组件 配置路由小案例(前往github)webpack-vue-路由嵌套]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day6]]></title>
    <url>%2F2018%2F10%2F19%2FVue-day6%2F</url>
    <content type="text"><![CDATA[注意：有时候使用npm i node-sass -D装不上，这时候，就必须使用 cnpm i node-sass -D 在普通页面中使用render函数渲染组件render 在webpack中配置.vue组件页面的解析 运行cnpm i vue -S将vue安装为运行依赖； 运行cnpm i vue-loader vue-template-compiler -D将解析转换vue的包安装为开发依赖； 运行cnpm i style-loader css-loader -D将解析转换CSS的包安装为开发依赖，因为.vue文件中会写CSS样式； 在webpack.config.js中，添加如下module规则： 123456789101112module: &#123; rules: [ &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;, &#123; test: /\.vue$/, use: &apos;vue-loader&apos; &#125; ] &#125; 创建App.js组件页面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;template&gt; &lt;!-- 注意：在 .vue 的组件中，template 中必须有且只有唯一的根元素进行包裹，一般都用 div 当作唯一的根元素 --&gt; &lt;div&gt; &lt;h1&gt;这是APP组件 - &#123;&#123;msg&#125;&#125;&lt;/h1&gt; &lt;h3&gt;我是h3&lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;// 注意：在 .vue 的组件中，通过 script 标签来定义组件的行为，需要使用 ES6 中提供的 export default 方式，导出一个vue实例对象export default &#123; data() &#123; return &#123; msg: &apos;OK&apos; &#125; &#125;&#125;&lt;/script&gt;&lt;style scoped&gt;h1 &#123; color: red;&#125;&lt;/style&gt; 创建main.js入口文件： 12345678910111213141516171819202122// 导入 Vue 组件import Vue from &apos;vue&apos;// 导入 App组件import App from &apos;./components/App.vue&apos;// 创建一个 Vue 实例，使用 render 函数，渲染指定的组件var vm = new Vue(&#123; el: &apos;#app&apos;, render: c =&gt; c(App)&#125;); 在使用webpack构建的Vue项目中使用模板对象？ 在webpack.config.js中添加resolve属性：12345resolve: &#123; alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos; &#125; &#125; ES6中语法使用总结 使用 export default 和 export 导出模块中的成员; 对应ES5中的 module.exports 和 export 使用 import ** from ** 和 import &#39;路径&#39; 还有 import {a, b} from &#39;模块标识&#39; 导入其他模块 使用箭头函数：(a, b)=&gt; { return a-b; } 在vue组件页面中，集成vue-router路由模块vue-router官网 导入路由模块： 12import VueRouter from &apos;vue-router&apos; 安装路由模块： 12Vue.use(VueRouter); 导入需要展示的组件: 1234import login from &apos;./components/account/login.vue&apos;import register from &apos;./components/account/register.vue&apos; 创建路由对象: 1234567891011121314var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/login&apos; &#125;, &#123; path: &apos;/login&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125; ]&#125;); 将路由对象，挂载到 Vue 实例上: 12345678910111213141516var vm = new Vue(&#123; el: &apos;#app&apos;, // render: c =&gt; &#123; return c(App) &#125; render(c) &#123; return c(App); &#125;, router // 将路由对象，挂载到 Vue 实例上&#125;); 改造App.vue组件，在 template 中，添加router-link和router-view： 12345678&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;router-view&gt;&lt;/router-view&gt; 组件中的css作用域问题1234&lt;style lang=&quot;scss&quot; scoped&gt;/* 普通的 style 标签只支持 普通的 样式，如果想要启用 scss 或 less ，需要为 style 元素，设置 lang 属性 */// 只要 咱们的 style 标签， 是在 .vue 组件中定义的，那么，推荐都为 style 开启 scoped 属性&lt;style&gt; 抽离路由为单独的模块抽离小案例]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm/cnpm 第三方模块/插件安装使用]]></title>
    <url>%2F2018%2F10%2F17%2Fnpm-Plug-in%2F</url>
    <content type="text"><![CDATA[模块/插件 express 前端 web 模块 path 路径核心模块 art-template 模版引擎（express-art-template 的依赖所以必须安装） express-art-template 模版引擎 (视觉效果模板 子模板 模板继承) body-parser 中间件(解析表单 post 请求体) mongoose 数据库链接 bootstrap@3 css 页面开发场景 jquery js 框架 blueimp-md5 密码加密 npm install express-session vue 常用 1-6 使用点看 vue-day5 7 使用点看 vue-day6 8 使用点看 vue-day7 （在 vue 中安装插件尽量使用 cnpm） 1.webpack@3.12.0 项目构建工具 2.webpack-dev-server@2.9.3 自动打包 3.html-webpack-plugin 把 html 打包在内存 4.样式文件打包 css style-loader css-loader less style-loader css-loader less-loader less // 不需要显示出来 sass style-loader css-loader sass-loader node-sass // 不需要显示出来 5.url 处理 （图片） url-loader file-loader 6.babel Es6 语法 babel-core babel-loader@7 babel-plugin-transform-runtime babel-preset-env babel-preset-stage-0 7.vue (webpack vue) vue vue 依赖 vue-loader 转换 vue 包依赖 vue-template-compiler 8.Mint-UI vue 的 ui 组件 Mint-ui 官网 mint-ui 组件 babel-plugin-component mint-ui 按需导入 9.vue-resource 发送数据请求 10.babel-plugin-transform-remove-strict-mode 去除严格模式 11.vue2-preview 缩略图打包 12.moment 时间处理插件 模块安装与应用express 前端开发框架 安装 12$ npm init -y //添加json初始化文件$ npm install express --save//安装express 引包 1const express = require('express'); 创建服务 1const app = express(); 使用 123app.get('/', function (req, res) &#123; req.send('index.html')&#125;) art-template 模版引擎 (配置在 express 中)js 使用 安装 12$ npm install --save art-template//express-art-templat依赖了art-template所以可以不用记载但是要安装$ npm install --save express-art-template 配置 1app.engine('art',require('express-art-template'))//art 可以替换成其他的标示 html 等 使用 1234567app.get('/',function (req,res) &#123; // 在 Express 中使用模板引擎有更好的方式：res.render('文件名， &#123;模板对象&#125;) // 可以自己尝试去看 art-template 官方文档：如何让 art-template 结合 Express 来使用 res.render('index.html',&#123; title: 'hello world' &#125;);&#125;); 如果希望修改默认的 views 视图渲染存储目录， 可以如下修改 12// 第一个参数 views 不能写错app.set('views', 目录路径) 视图页面输出 views 安装模版引擎 art-template express-art-template 编写布局页面 layout.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="/node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;!-- 留坑给页面添加css样式等链接 --&gt; &#123;&#123; block 'head' &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!-- body-固定头部-头部重用 --&gt; &#123;&#123; include './header.html' &#125;&#125; &lt;!-- body-内容模块-可修改 --&gt; &#123;&#123; block 'content' &#125;&#125; &lt;h1&gt;默认内容&lt;/h1&gt; &#123;&#123; /block &#125;&#125; &lt;!-- body-固定底部-底部重用 --&gt; &#123;&#123; include './footer.html' &#125;&#125;&lt;/body&gt;&lt;script src="../node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt;&lt;script src="../node_modules/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;!-- 留坑给页面添加js等 --&gt;&#123;&#123; block 'script' &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/html&gt; 调用布局模块 编写页面 12345678910111213141516171819202122232425262728&lt;!-- 继承布局模块页 --&gt;&#123;&#123;extend './layout.html'&#125;&#125;&lt;!-- 添加css样式-通过坑 head --&gt;&#123;&#123;block 'head'&#125;&#125;&lt;style&gt; body &#123; background-color: skyblue; &#125; h1 &#123; color: red; &#125;&lt;/style&gt;&#123;&#123;/block&#125;&#125;&lt;!-- 修改页面内容 --&gt;&#123;&#123;block 'content'&#125;&#125;&lt;div&gt; &lt;h1&gt;index.html填坑&lt;/h1&gt;&lt;/div&gt;&#123;&#123;/block&#125;&#125;&lt;!-- 添加js 通过script --&gt;&#123;&#123;block 'script'&#125;&#125;&lt;script&gt; window.alert('index 页面自己的js 脚本')&lt;/script&gt;&#123;&#123;/block&#125;&#125; 留坑内容 中带‘’号的内容的自定义的名，最好是取一看就明白的 坑不止可以留一个，可以留很多个 body-parser 中间件(解析表单 post 请求体) 安装 1$ npm install --save body-parser 引包 1const bodyParser = require('body-parser'); 配置 1234// parse application/x-www-form-urlencoded 解析applicationapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));// parse application/json 解析app.use(bodyParser.json()); 使用 12345678910app.post('/post',function (req,res) &#123; var myDate = new Date(); var year = myDate.getFullYear(); //获取完整的年份(4位,1970-????) var month = myDate.getMonth() + 1; //获取当前月份(0-11,0代表1月) var date = myDate.getDate(); //获取当前日(1-31) let comment = req.body; comment.dateTime = year + "-" + month + "-" + date; comments.unshift(comment); res.redirect('/');&#125;) mongoose （mongodb 数据库链接插件） 安装 1$ npm i -S mongoose 引包 1const mongoose = require('mongoose'); 配置 12// 连接数据库mongoose.connect('mongodb://localhost/test'); 使用 1234567891011121314// 创建一个模型// 就是在设计数据库// MongoDB 是动态的，非常灵活，只需要在代码中设计你的数据库就可以了// mongoose 这个包就可以让你的设计编写过程变的非常的简单const Cat = mongoose.model('Cat', &#123; name: String&#125;);// 实例化一个 catconst kitty = new Cat(&#123; name: 'yhf'&#125;);// 持久化保存 kitty 实例kitty.save().then(() =&gt; console.log('meow')); bootstrap css 样式前端架构 安装 （3 版居多） 1$ npm install bootstrap@3 使用 （在视图的布局页面引入就好）css： js： jquery js 框架 安装 1$ npm i jquery 使用 (在视图的布局页面引入就好) blueimp-md5 密码加密 安装 1$ npm install blueimp-md5 引包 1const md5 = require('blueimp-md5'); 调用 12// md() 在里面填充数据就好 多加几个是多重加密，三个为三重加密body.password = md5(md5(md5(body.password))) express-session 数据存储 安装 1$ npm install express-session 配置 12345678910111213141516171819// 引包const session = require('express-session')// 在 Express 这个框架中，默认不支持 Session 和 Cookie// 但是我们可以使用第三方中间件：express-session 来解决// 1. npm install express-session// 2. 配置 (一定要在 app.use(router) 之前)// 3. 使用// 当把这个插件配置好之后，我们就可以通过 req.session 来发访问和设置 Session 成员了// 添加 Session 数据：req.session.foo = 'bar'// 访问 Session 数据：req.session.fooapp.use(session(&#123; // 配置加密字符串，它会在原有加密基础之上和这个字符串拼起来去加密 // 目的是为了增加安全性，防止客户端恶意伪造 secret: 'itcast', resave: false, saveUninitialized: false // 无论你是否使用 Session ，我都默认直接给你分配一把钥匙&#125;)) 使用 12345// 用户存在，登录成功，通过 Session 记录登录状态req.session.user = user;// 用户退出，退出成功，通过 Session 清除登录状态req.session.user = null; webpack@3.12.0 安装 12$ sudo cnpm install webpack@3.12.0 -g //全局安装webpack 3.12.0 版本$ sudo cnpm install webpack@3.12.0 -D //项目本地安装webpack 3.12.0 版本 使用看 Vue day5 webpack-dev-server 安装 1sudo cnpm i webpack-dev-server@2.6.0 --save-dev 使用看 Vue day5 html-webpack-plugin 把 html 打包在内存 安装 1$ sudo cnpm i html-webpack-plugin --save-dev webpack css (webpack 不会处理 js 以为的文件需要用其他的插件辅助) 安装 style-loader 1$ sudo cnpm i style-loader --save-dev 安装 css-loader 1$ sudo cnpm i css-loader --save-dev less 安装 less-loader 1$ sudo cnpm i less-loader -D 安装 less 1$ sudo cnpm i less -D sass 安装 sass-loader 1$ sudo cnpm i sass-loader -D 安装 node-sass 1$ sudo cnpm i node-sass -D url-loader 与 file-loader1$ sudo cnpm i url-loader file-loader -D //都是两个一起用可以一起安装 babel12$ sudo cnpm i babel-core babel-loader@7 babel-plugin-transform-runtime -D$ sudo cnpm i babel-preset-env babel-preset-stage-0 -D Vue1$ sudo cnpm i vue -S vue-loader vue-template-compiler1$ sudo cnpm i vue-loader vue-template-compiler -D Mint-UI1$ sudo cnpm i mint-ui -S babel-plugin-componen1$ sudo npm install babel-plugin-component -D vue-resource1$ sudo cnpm i vue-resource -S babel-plugin-transform-remove-strict-mode 安装 1$ sudo cnpm i babel-plugin-transform-remove-strict-mode -D 配置 .babelrc 文件 没有就在根目录创建 123&#123; "plugins": ["transform-remove-strict-mode"]&#125; 使用 123456 // 以mui为例 // 在vue里面，因为这个mui.js 写法比较旧所以编译时会报错，所以我们去除严格模式 &lt;script&gt; // 1. 导入 mui 的js文件 import mui from "../../lib/mui/js/mui.js";&lt;/script&gt; 清理报错/报警 加入这个样式就可以了 123* &#123; touch-action: pan-y;&#125; vue2-preview123https://www.npmjs.com/package/vue2-preview$ sudo cnpm i vue2-preview -Shttp://www.mamicode.com/info-detail-2462808.html moment 安装 1$ sudo cnpm i moment -S 使用 1234567// 在main.js里面全局配置// 导入时间插件import moment from 'moment'// 定义全局的过滤器 dateFormat 是调用方法名 dataStr 是传入参数 patter 是格式Vue.filter('dateFormat', function (dataStr, pattern = 'YYYY-MM-DD HH:mm:ss') &#123; return moment(dataStr).format(pattern)&#125;)]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm/cnpm 安装使用]]></title>
    <url>%2F2018%2F10%2F16%2Fnpm%2F</url>
    <content type="text"><![CDATA[配置向导 node/npm 在开发中很多时候都会用到到第三方插件 来使得开发更加到便捷 在这个时候就会想到 npm 来下载第三方插件，但是使用 npm 到前提就就要先安装 node （在安装node的时候会自动安装npm） 虽然自动安装 npm 但是，npm比Node.js更频繁地更新，因此请确保您拥有最新版本 nrm npm镜像地址控制 作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址； 什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 注意： nrm 只是单纯的提供了几个常用的 下载包的 URL地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是 npm cnpm （注意：这里的cnpm 和 nrm内调整的cnpm地址完全不是一个东西） 有时候即使用 nrm 切换为国内的镜像地址仍然觉得很慢就会想到 cnpm 使用和 npm 是一样的 cnpm和npm一样都是用来安装第三方包的 1.node/npm安装 node Node下载官网 安装比较简单不详细说 按照自己的电脑配置下载包解压安装就可以 安装完后 node -v 出来版本号就是安装成功了 npm -v 查看npm的版本 如果发现版本不是最新的请执行下面的操作 （如果是最新直接跳过看后面nrm的安装） 更新 npm 使用 安装指令 12345 $ sudo npm install npm@latest -g // 全局安装 -g ``` 2. 如果你想用抢先版 ``` bash $ sudo npm install npm@next -g 安装完就说一下使用 在我们开发前要做一个初始化的json文件来记录加载我们的第三方包（执行命令后会出来一个json文件） 1$ sudo npm init -y //init初始化 -y 直接跳过配置 正式使用 npm 安装第三方插件 例如安装一个jquery 1$ sudo npm i jquery -S 例如安装指定版本的 webpack 第三方插件 12$ sudo cnpm install webpack@3.12.0 -g //全局安装webpack 3.12.0 版本 $ sudo cnpm install webpack@3.12.0 -D //项目本地安装webpack 3.12.0 版本 i 安装 ==== -S 添加到配置文件 ==== -g 全局安装 ==== -D 本地安装（只是安装在项目文件夹） 2.nrm 运行npm i nrm -g全局安装nrm包； 1$ sudo npm i nrm -g 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 1$ sudo npm ls 使用nrm use npm或nrm use taobao切换不同的镜像源地址；(国内一般都是用 cnpm 和 taobao) 1$ sudo npm use taobao 3.cnpm 运行npm i cnpm -g全局安装nrm包； 1$ sudo npm i cnpm -g cnpm 的版本查看与使用方法和npm完全一样 只是 npm 和 cnpm 之间一个c的区别其他完全一样]]></content>
      <categories>
        <category>插件/配置</category>
      </categories>
      <tags>
        <tag>npm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day5]]></title>
    <url>%2F2018%2F10%2F16%2FVue-day5%2F</url>
    <content type="text"><![CDATA[复习 父子组件直接传值 案例代码看 vue-day5 案例 路由基础使用 案例代码看 vue-day5 案例 watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos;, fullName: &apos;jack - chen&apos; &#125;, methods: &#123;&#125;, watch: &#123; &apos;firstName&apos;: function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + &apos; - &apos; + this.lastName; &#125;, &apos;lastName&apos;: function (newVal, oldVal) &#123; this.fullName = this.firstName + &apos; - &apos; + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; &#125;); var register = Vue.extend(&#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: &quot;/login&quot;, component: login &#125;, &#123; path: &quot;/register&quot;, component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; &apos;$route&apos;: function (newVal, oldVal) &#123; if (newVal.path === &apos;/login&apos;) &#123; console.log(&apos;这是登录组件&apos;); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos; &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + &apos; - &apos; + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos; &#125;, methods: &#123; changeName() &#123; this.fullName = &apos;TOM - chen2&apos;; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + &apos; - &apos; + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(&apos; - &apos;); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的 NPM 包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的 NPM 服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的 NPM 服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 注意： nrm 只是单纯的提供了几个常用的 下载包的 URL 地址，并能够让我们在 这几个 地址之间，很方便的进行切换，但是，我们每次装包的时候，使用的 装包工具，都是 npm 在网页中会引用哪些常见的静态资源？ JS .js .jsx .coffee .ts（TypeScript 类 C# 语言） CSS .css .less .sass .scss Images .jpg .png .gif .bmp .svg 字体文件（Fonts） .svg .ttf .eot .woff .woff2 模板文件 .ejs .jade .vue【这是在 webpack 中定义组件的方式，推荐这么用】 网页中引入的静态资源多了以后有什么问题？？？ 网页加载速度慢， 因为 我们要发起很多的二次请求； 要处理错综复杂的依赖关系 如何解决上述两个问题 合并、压缩、精灵图、图片的 Base64 编码 可以使用之前学过的 requireJS、也可以使用 webpack 可以解决各个包之间的复杂依赖关系； 什么是 webpack?webpack 是前端的一个项目构建工具，它是基于 Node.js 开发出来的一个前端工具； 如何完美实现上述的 2 种解决方案 使用 Gulp， 是基于 task 任务的； 使用 Webpack， 是基于整个项目进行构建的； 借助于 webpack 这个前端自动化构建工具，可以完美实现资源的合并、打包、压缩、混淆等诸多功能。 根据官网的图片介绍 webpack 打包的过程 webpack 官网 webpack 安装的两种方式 运行npm i webpack -g全局安装 webpack，这样就能在全局使用 webpack 的命令 在项目根目录中运行npm i webpack --save-dev安装到项目依赖中 初步使用 webpack 打包构建列表隔行变色案例 运行npm init初始化项目，使用 npm 管理项目中的依赖包 创建项目基本的目录结构 使用cnpm i jquery --save安装 jquery 类库 创建main.js并书写各行变色的代码逻辑： 1234567// 导入jquery类库 import $ from &apos;jquery&apos; // 设置偶数行背景色，索引从0开始，0是偶数 $(&apos;#list li:even&apos;).css(&apos;backgroundColor&apos;,&apos;lightblue&apos;); // 设置奇数行背景色 $(&apos;#list li:odd&apos;).css(&apos;backgroundColor&apos;,&apos;pink&apos;); 直接在页面上引用main.js会报错，因为浏览器不认识import这种高级的 JS 语法，需要使用 webpack 进行处理，webpack 默认会把这种高级的语法转换为低级的浏览器能识别的语法； 运行webpack 入口文件路径 输出文件路径对main.js进行处理： 1webpack src/js/main.js dist/bundle.js 使用 webpack 的配置文件简化打包时候的命令 在项目根目录中创建webpack.config.js 由于运行 webpack 命令的时候，webpack 需要指定入口文件和输出文件的路径，所以，我们需要在webpack.config.js中配置这两个路径： 1234567891011// 导入处理路径的模块var path = require(&apos;path&apos;);// 导出一个配置对象，将来webpack在启动的时候，会默认来查找webpack.config.js，并读取这个文件中导出的配置对象，来进行打包处理module.exports = &#123; entry: path.resolve(__dirname, &apos;src/js/main.js&apos;), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, &apos;dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 &#125;&#125; 实现 webpack 的实时打包构建 由于每次重新修改代码之后，都需要手动运行 webpack 打包的命令，比较麻烦，所以使用webpack-dev-server来实现代码实时打包编译，当修改代码之后，会自动进行打包构建。 运行cnpm i webpack-dev-server --save-dev安装到开发依赖 安装完成之后，在命令行直接运行webpack-dev-server来进行打包，发现报错，此时需要借助于package.json文件中的指令，来进行运行webpack-dev-server命令，在scripts节点下新增&quot;dev&quot;: &quot;webpack-dev-server&quot;指令，发现可以进行实时打包，但是 dist 目录下并没有生成bundle.js文件，这是因为webpack-dev-server将打包好的文件放在了内存中 把bundle.js放在内存中的好处是：由于需要实时打包编译，所以放在内存中速度会非常快 这个时候访问 webpack-dev-server 启动的http://localhost:8080/网站，发现是一个文件夹的面板，需要点击到 src 目录下，才能打开我们的 index 首页，此时引用不到 bundle.js 文件，需要修改 index.html 中 script 的 src 属性为:&lt;script src=&quot;../bundle.js&quot;&gt;&lt;/script&gt; 为了能在访问http://localhost:8080/的时候直接访问到 index 首页，可以使用--contentBase src指令来修改 dev 指令，指定启动的根目录： 1&quot;dev&quot;: &quot;webpack-dev-server --contentBase src&quot; 同时修改 index 页面中 script 的 src 属性为&lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; 使用html-webpack-plugin插件配置启动页面由于使用--contentBase指令的过程比较繁琐，需要指定启动的目录，同时还需要修改 index.html 中 script 标签的 src 属性，所以推荐大家使用html-webpack-plugin插件配置启动页面. 运行cnpm i html-webpack-plugin --save-dev安装到开发依赖 修改webpack.config.js配置文件如下： 123456789101112131415161718// 导入处理路径的模块var path = require(&apos;path&apos;);// 导入自动生成HTMl文件的插件var htmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);module.exports = &#123; entry: path.resolve(__dirname, &apos;src/js/main.js&apos;), // 项目入口文件 output: &#123; // 配置输出选项 path: path.resolve(__dirname, &apos;dist&apos;), // 配置输出的路径 filename: &apos;bundle.js&apos; // 配置输出的文件名 &#125;, plugins:[ // 添加plugins节点配置插件 new htmlWebpackPlugin(&#123; template:path.resolve(__dirname, &apos;src/index.html&apos;),//模板路径 filename:&apos;index.html&apos;//自动生成的HTML文件的名称 &#125;) ]&#125; 修改package.json中script节点中的 dev 指令如下： 1&quot;dev&quot;: &quot;webpack-dev-server&quot; 将 index.html 中 script 标签注释掉，因为html-webpack-plugin插件会自动把 bundle.js 注入到 index.html 页面中！ 实现自动打开浏览器、热更新和配置浏览器的默认端口号注意：热更新在 JS 中表现的不明显，可以从一会儿要讲到的 CSS 身上进行介绍说明！ 方式 1： 修改package.json的 script 节点如下，其中--open表示自动打开浏览器，--port 4321表示打开的端口号为 4321，--hot表示启用浏览器热更新： 1&quot;dev&quot;: &quot;webpack-dev-server --hot --port 4321 --open&quot; 方式 2： 修改webpack.config.js文件，新增devServer节点如下： 12345devServer:&#123; hot:true, open:true, port:4321 &#125; 在头部引入webpack模块： 1var webpack = require(&apos;webpack&apos;); 在plugins节点下新增： 1new webpack.HotModuleReplacementPlugin() 使用 webpack 打包 css 文件 运行cnpm i style-loader css-loader --save-dev 修改webpack.config.js这个配置文件： 12345module: &#123; // 用来配置第三方loader模块的 rules: [ // 文件的匹配规则 &#123; test: /\.css$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;] &#125;//处理css文件的规则 ] &#125; 注意：use表示使用哪些模块来处理test所匹配到的文件；use中相关 loader 模块的调用顺序是从后向前调用的； 使用 webpack 打包 less 文件 运行cnpm i less-loader less -D 修改webpack.config.js这个配置文件： 1&#123; test: /\.less$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;less-loader&apos;] &#125;, 使用 webpack 打包 sass 文件 运行cnpm i sass-loader node-sass --save-dev 在webpack.config.js中添加处理 sass 文件的 loader 模块： 1&#123; test: /\.scss$/, use: [&apos;style-loader&apos;, &apos;css-loader&apos;, &apos;sass-loader&apos;] &#125; 使用 webpack 处理 css 中的路径 运行cnpm i url-loader file-loader --save-dev 在webpack.config.js中添加处理 url 路径的 loader 模块： 1&#123; test: /\.(png|jpg|gif)$/, use: &apos;url-loader&apos; &#125; 可以通过limit指定进行 base64 编码的图片大小；只有小于指定字节（byte）的图片才会进行 base64 编码： 1&#123; test: /\.(png|jpg|gif)$/, use: &apos;url-loader?limit=43960&amp;name=[hash:8]-[name].[ext]&apos; &#125;, 使用 babel 处理高级 JS 语法在 webpack 中，默认只能处理 一部分 ES6 的新语法，一些更高级的ES6语法或者 ES7 语法，webpack 是处理不了的；这时候，就需要 借助于第三方的 loader，来帮助webpack 处理这些高级的语法，当第三方loader 把 高级语法转为 低级的语法之后，会把结果交给 webpack 去打包到 bundle.js 中通过 Babel ，可以帮我们将 高级的语法转换为 低级的语法 在 webpack 中，可以运行如下两套 命令，安装两套包，去安装 Babel 相关的loader功能：1.1 第一套包： cnpm i babel-core babel-loader@7 babel-plugin-transform-runtime -D1.2 第二套包： cnpm i babel-preset-env babel-preset-stage-0 -D 打开 webpack 的配置文件，在 module 节点下的 rules 数组中，添加一个 新的 匹配规则：2.1 1&#123; test:/\.js$/, use: &apos;babel-loader&apos;, exclude:/node_modules/ &#125; 2.2 注意： 在配置 babel 的 loader规则的时候，必须 把 node_modules 目录，通过 exclude 选项排除掉：原因有俩：2.2.1 如果 不排除 node_modules， 则Babel 会把 node_modules 中所有的 第三方 JS 文件，都打包编译，这样，会非常消耗CPU，同时，打包速度非常慢；2.2.2 哪怕，最终，Babel 把 所有 node_modules 中的JS转换完毕了，但是，项目也无法正常运行！ 在项目的 根目录中，新建一个 叫做 .babelrc 的Babel 配置文件，这个配置文件，属于JSON格式，所以，在写 .babelrc 配置的时候，必须符合JSON语法规范： 不能写注释，字符串必须用双引号3.1 在 .babelrc 写如下的配置： 大家可以把 preset 翻译成 【语法】 的意思 1234&#123; &quot;presets&quot;: [&quot;env&quot;, &quot;stage-0&quot;], &quot;plugins&quot;: [&quot;transform-runtime&quot;]&#125; 了解： 目前，我们安装的 babel-preset-env, 是比较新的ES语法， 之前， 我们安装的是 babel-preset-es2015, 现在，出了一个更新的 语法插件，叫做 babel-preset-env ，它包含了 所有的 和 es***相关的语法 注意：语法插件babel-preset-es2015可以更新为babel-preset-env，它包含了所有的 ES 相关的语法； 相关文章babel-preset-env：你需要的唯一 Babel 插件Runtime transform 运行时编译 es6URL 中的 hash（井号）]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day5 案例]]></title>
    <url>%2F2018%2F10%2F16%2F2018-10-16%2F</url>
    <content type="text"><![CDATA[案例分布 父子组件直接传值 路由基础使用 webpack-study 一、 父子组件直接传值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1.引包 --&gt; &lt;script src="./lib/vue-2.5.17.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 4.调用 --&gt; &lt;!-- 6.: 绑定数据--&gt; &lt;!-- 11. @添加点击事件绑定函数--&gt; &lt;msg :yf="yhf" @cl="getData"&gt;&lt;/msg&gt; &lt;/div&gt; &lt;!-- 外部板块 --&gt; &lt;template id="tmp"&gt; &lt;div&gt; &lt;!-- 8.在模板调用 --&gt; &lt;h1&gt;这是一个子组件---&#123;&#123;yf&#125;&#125;&lt;/h1&gt; &lt;!-- 13.创建一个按钮用来调用传值函数 --&gt; &lt;input type="button" value="点击给父组件传值" @click="setData"&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; // 2.创建子组件 let msg = &#123; template: '#tmp', // 7.定义父组件拿过来的数据 props: ['yf'], // 9.定义子组件的数据 data() &#123; return &#123; msgData: '这是子组件传给父组建的，我是儿子' &#125; &#125;, methods: &#123; // 14.定义函数用来给父组件传值 setData()&#123; this.$emit('cl',this.msgData) &#125; &#125; &#125; // 创建 Vue 实例,得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123; // 5.定义父级数据 yhf: '这个父组建，我是你爸爸', // 10.定义一个空字符串接收数据 msData: '' &#125;, methods: &#123; // 12.定义函数接收子组件的数据 data 是传过来的数据 getData(data)&#123; this.msData = data console.log(this.msData); &#125; &#125;, components: &#123; // 3.添加组件 msg &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 二、路由基础使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.5.17.js"&gt;&lt;/script&gt; &lt;!-- 1. 引 vue-router 包 --&gt; &lt;script src="./lib/vue-router-3.0.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;!-- 5.调用路由 --&gt; &lt;!-- 渲染路由标签 --&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/register"&gt;注册&lt;/router-link&gt; &lt;!-- 渲染路由容器 --&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 2.创建组件 登录和注册组件 let login = &#123; template: "&lt;h1&gt;这是登录组件，点击登录&lt;/h1&gt;" &#125; let register = &#123; template: "&lt;h1&gt;这是注册组件，点击注册&lt;/h1&gt;" &#125; // 3.创建路由 let router = new VueRouter(&#123; routes: [&#123; //设置路由主页重定向 path: '/', redirect: '/login' &#125;, &#123; path: '/login', component: login &#125;, &#123; path: '/register', component: register &#125; ] &#125;) // 创建 Vue 实例,得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router //4.挂载路由 &#125;)&lt;/script&gt;&lt;/html&gt; 三、webpack-study1.案例说明 学习 webpack 安装 基础使用 打包 学习 webpack 的webpack-dev-server 安装 自动打包 配置 学习 webpack 的html css等打包配置 2.第三方插件 jquery webpack@3.12.0 webpack-dev-server@2.6.0 html-webpack-plugin css style-loader css-loader less less-loader less sass sass-loader node-sass 3.项目地址]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day4 案例]]></title>
    <url>%2F2018%2F10%2F13%2F2018-10-13%2F</url>
    <content type="text"><![CDATA[案例分布1. 组件案例练习 2. 路由嵌套 3. 命名视图案例 一、组件案例练习重点 vue @(v-on) v-for :key v-model localStorage 本地存储 子组件 data methods 方法 JSON created 生命周期 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.5.17.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;tmp-box @add="addBox"&gt;&lt;/tmp-box&gt; &lt;ul class="list-group"&gt; &lt;li class="list-group-item" v-for="item in list" :key="item.id"&gt; &lt;span class="badge"&gt;评论人：&#123;&#123;item.name&#125;&#125;&lt;/span&gt; &#123;&#123;item.con&#125;&#125; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;template id="tmp"&gt; &lt;div&gt; &lt;div class="form-group"&gt; &lt;label&gt;姓名：&lt;/label&gt; &lt;input type="text" class="form-control" v-model="name"&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;label&gt;评论：&lt;/label&gt; &lt;textarea class="form-control" rows="3" v-model="con"&gt;&lt;/textarea&gt; &lt;/div&gt; &lt;div class="form-group"&gt; &lt;button type="button" class="btn btn-success" @click='add'&gt;提交&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; let tmpBox = &#123; template: '#tmp', data() &#123; return &#123; id: Date.now(), name: '', con: '' &#125; &#125;, methods: &#123; add() &#123; let addCon = &#123; id: Date.now(), name: this.name, con: this.con &#125;; if (addCon.name!==''&amp;&amp;addCon.con!=='') &#123; let list = JSON.parse(localStorage.getItem('yhf') || '[]'); list.unshift(addCon); localStorage.setItem('yhf', JSON.stringify(list)); this.name = this.con = ''; this.$emit('add'); &#125;else &#123; alert('请输入姓名') &#125; &#125; &#125; &#125; var vm = new Vue(&#123; el: '#app', data: &#123; list: [&#123; id: 1, name: 'yhf', con: 'djifjeifefefefe' &#125;, &#123; id: 2, name: 'yhf2', con: 'djifjeifeefeffefefe' &#125;, &#123; id: 3, name: 'yhf3', con: 'djifjeifefeefefefefe' &#125;, ] &#125;, created: function () &#123; this.addBox() &#125;, methods: &#123; addBox() &#123; let list = JSON.parse(localStorage.getItem('yhf') || '[]'); this.list = list; &#125; &#125;, components: &#123; tmpBox &#125; &#125;)&lt;/script&gt;&lt;/html&gt; 二、路由嵌套重点 vue children 属性 子路由的设置 带/ 和不带/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.5.17.js"&gt;&lt;/script&gt; &lt;script src="./lib/vue-router-3.0.1.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;router-link to="/account"&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;template id="tmp1"&gt; &lt;div&gt; &lt;h1&gt;这是 Account 组件&lt;/h1&gt; &lt;router-link to="/login"&gt;登录&lt;/router-link&gt; &lt;router-link to="/account/register"&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/template&gt;&lt;/body&gt;&lt;script&gt; var account = &#123; template: '#tmp1' &#125; var login = &#123; template: '&lt;h3&gt;登录&lt;/h3&gt;' &#125; var register = &#123; template: '&lt;h3&gt;注册&lt;/h3&gt;' &#125; var router = new VueRouter(&#123; routes: [&#123; path: '/account', component: account, // 使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址 children: [&#123; path: '/login', component: login &#125;, &#123; path: 'register', component: register &#125; ] &#125; ] &#125;) // 创建 Vue 实例,得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;)&lt;/script&gt;&lt;/html&gt; 三、命名视图案例重点 vue 属性名 name components 多地址设置 css 设置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 &lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.5.17.js"&gt;&lt;/script&gt; &lt;script src="./lib/vue-router-3.0.1.js"&gt;&lt;/script&gt; &lt;style&gt; * &#123; margin: 0; padding: 0; font-size: 16px; &#125; .header &#123; background-color: orange; height: 80px; &#125; .container &#123; display: flex; height: 600px; &#125; .left &#123; background-color: lightgreen; flex: 2; &#125; .main &#123; background-color: lightpink; flex: 8; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class="container"&gt; &lt;router-view name="left"&gt;&lt;/router-view&gt; &lt;router-view name="main"&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var header = &#123; template: '&lt;h1 class="header"&gt;header&lt;/h1&gt;' &#125; var leftBox = &#123; template: '&lt;h1 class="left"&gt;leftBox&lt;/h1&gt;' &#125; var mainBox = &#123; template: '&lt;h1 class="main"&gt;mainBox&lt;/h1&gt;' &#125; var router = new VueRouter(&#123; routes: [&#123; path: '/', components: &#123; 'default': header, 'left': leftBox, 'main': mainBox &#125; &#125;] &#125;) // 创建 Vue 实例,得到 ViewModel var vm = new Vue(&#123; el: '#app', data: &#123;&#125;, methods: &#123;&#125;, router &#125;)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day4]]></title>
    <url>%2F2018%2F10%2F13%2FVue-day4%2F</url>
    <content type="text"><![CDATA[复习 实现小球 @click 控制小球的显示隐藏 @before-enter=”beforeEnter” @enter=”enter” @after-enter=”afterEnter” 钩子动画函数 定义组件 12345678910111213141516171819202122232425&lt;script&gt; // 定义组件的时候，如果要定义全局的组件， Vue.component(&apos;组件的名称&apos;, &#123;&#125;) // 通过 对象 字面量的形式， 定义了一个 组件模板对象 var login = &#123; template: &apos;&lt;h1&gt;1234&lt;/h1&gt;&apos; &#125; // 通过 Vue.component 把 组件模板对象，注册为一个全局的Vue 组件，同时，为这个组件起了一个名称，可以让我们 通过 标签形式，在页面中直接引入这个组件 // Vue.component(&apos;mylogin&apos;, login) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // &apos;组件的名称&apos;: 组件的模板对象 // &apos;mylogin&apos;: login login &#125; &#125;);&lt;/script&gt; 父组件向子组件传值 组件实例定义方式，注意：一定要使用props属性来定义父组件传递过来的数据 123456789101112131415&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; msg: &apos;这是父组件中的消息&apos; &#125;, components: &#123; son: &#123; template: &apos;&lt;h1&gt;这是子组件 --- &#123;&#123;finfo&#125;&#125;&lt;/h1&gt;&apos;, props: [&apos;finfo&apos;] &#125; &#125; &#125;); &lt;/script&gt; 使用v-bind或简化指令，将数据传递到子组件中： 123&lt;div id=&quot;app&quot;&gt; &lt;son :finfo=&quot;msg&quot;&gt;&lt;/son&gt; &lt;/div&gt; 子组件向父组件传值 原理：父组件将方法的引用，传递到子组件内部，子组件在内部调用父组件传递过来的方法，同时把要发送给父组件的数据，在调用方法的时候当作参数传递进去； 父组件将方法的引用传递给子组件，其中，getMsg是父组件中methods中定义的方法名称，func是子组件调用传递过来方法时候的方法名称 1&lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; 子组件内部通过this.$emit(&#39;方法名&#39;, 要传递的数据)方式，来调用父组件中的方法，同时把数据传递给父组件使用 12345678910111213141516171819202122232425262728293031323334&lt;div id=&quot;app&quot;&gt; &lt;!-- 引用父组件 --&gt; &lt;son @func=&quot;getMsg&quot;&gt;&lt;/son&gt; &lt;!-- 组件模板定义 --&gt; &lt;script type=&quot;x-template&quot; id=&quot;son&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;向父组件传值&quot; @click=&quot;sendMsg&quot; /&gt; &lt;/div&gt; &lt;/script&gt; &lt;/div&gt; &lt;script&gt; // 子组件的定义方式 Vue.component(&apos;son&apos;, &#123; template: &apos;#son&apos;, // 组件模板Id methods: &#123; sendMsg() &#123; // 按钮的点击事件 this.$emit(&apos;func&apos;, &apos;OK&apos;); // 调用父组件传递过来的方法，同时把数据传递出去 &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123; getMsg(val)&#123; // 子组件中，通过 this.$emit() 实际调用的方法，在此进行定义 alert(val); &#125; &#125; &#125;); &lt;/script&gt; 组件中data和props的区别评论列表案例目标：主要练习父子组件之间传值 使用 this.$refs 来获取元素和组件123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;div&gt; &lt;input type=&quot;button&quot; value=&quot;获取元素内容&quot; @click=&quot;getElement&quot; /&gt; &lt;!-- 使用 ref 获取元素 --&gt; &lt;h1 ref=&quot;myh1&quot;&gt;这是一个大大的H1&lt;/h1&gt; &lt;hr&gt; &lt;!-- 使用 ref 获取子组件 --&gt; &lt;my-com ref=&quot;mycom&quot;&gt;&lt;/my-com&gt; &lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component(&apos;my-com&apos;, &#123; template: &apos;&lt;h5&gt;这是一个子组件&lt;/h5&gt;&apos;, data() &#123; return &#123; name: &apos;子组件&apos; &#125; &#125; &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123; getElement() &#123; // 通过 this.$refs 来获取元素 console.log(this.$refs.myh1.innerText); // 通过 this.$refs 来获取组件 console.log(this.$refs.mycom.name); &#125; &#125; &#125;);&lt;/script&gt; 什么是路由 后端路由：对于普通的网站，所有的超链接都是URL地址，所有的URL地址都对应服务器上对应的资源； 前端路由：对于单页面应用程序来说，主要通过URL中的hash(#号)来实现不同页面之间的切换，同时，hash有一个特点：HTTP请求中不会包含hash相关的内容；所以，单页面程序中的页面跳转主要用hash实现； 在单页面应用程序中，这种通过hash改变来切换页面的方式，称作前端路由（区别于后端路由）； 在 vue 中使用 vue-router 导入 vue-router 组件类库： 12&lt;!-- 1. 导入 vue-router 组件类库 --&gt; &lt;script src=&quot;./lib/vue-router-2.7.0.js&quot;&gt;&lt;/script&gt; 使用 router-link 组件来导航 123&lt;!-- 2. 使用 router-link 组件来导航 --&gt;&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; 使用 router-view 组件来显示匹配到的组件 12&lt;!-- 3. 使用 router-view 组件来显示匹配到的组件 --&gt;&lt;router-view&gt;&lt;/router-view&gt; 创建使用Vue.extend创建组件 123456789// 4.1 使用 Vue.extend 来创建登录组件var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos;&#125;);// 4.2 使用 Vue.extend 来创建注册组件var register = Vue.extend(&#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos;&#125;); 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 1234567// 5. 创建一个路由 router 实例，通过 routers 属性来定义路由匹配规则 var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/login&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125; ] &#125;); 使用 router 属性来使用路由规则 12345// 6. 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, router: router // 使用 router 属性来使用路由规则 &#125;); 使用tag属性指定router-link渲染的标签类型设置路由重定向设置路由高亮设置路由切换动效在路由规则中定义参数 在规则中定义参数： 1&#123; path: &apos;/register/:id&apos;, component: register &#125; 通过 this.$route.params来获取路由中的参数： 123var register = Vue.extend(&#123; template: &apos;&lt;h1&gt;注册组件 --- &#123;&#123;this.$route.params.id&#125;&#125;&lt;/h1&gt;&apos; &#125;); 使用 children 属性实现路由嵌套1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/account&quot;&gt;Account&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt;&lt;script&gt; // 父路由中的组件 const account = Vue.extend(&#123; template: `&lt;div&gt; 这是account组件 &lt;router-link to=&quot;/account/login&quot;&gt;login&lt;/router-link&gt; | &lt;router-link to=&quot;/account/register&quot;&gt;register&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;` &#125;); // 子路由中的 login 组件 const login = Vue.extend(&#123; template: &apos;&lt;div&gt;登录组件&lt;/div&gt;&apos; &#125;); // 子路由中的 register 组件 const register = Vue.extend(&#123; template: &apos;&lt;div&gt;注册组件&lt;/div&gt;&apos; &#125;); // 路由实例 var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, redirect: &apos;/account/login&apos; &#125;, // 使用 redirect 实现路由重定向 &#123; path: &apos;/account&apos;, component: account, children: [ // 通过 children 数组属性，来实现路由的嵌套 &#123; path: &apos;login&apos;, component: login &#125;, // 注意，子路由的开头位置，不要加 / 路径符 &#123; path: &apos;register&apos;, component: register &#125; ] &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; account &#125;, router: router &#125;);&lt;/script&gt; 命名视图实现经典布局 标签代码结构： 1234567&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;div class=&quot;content&quot;&gt; &lt;router-view name=&quot;a&quot;&gt;&lt;/router-view&gt; &lt;router-view name=&quot;b&quot;&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;/div&gt; JS代码： 12345678910111213141516171819202122232425262728293031323334&lt;script&gt; var header = Vue.component(&apos;header&apos;, &#123; template: &apos;&lt;div class=&quot;header&quot;&gt;header&lt;/div&gt;&apos; &#125;); var sidebar = Vue.component(&apos;sidebar&apos;, &#123; template: &apos;&lt;div class=&quot;sidebar&quot;&gt;sidebar&lt;/div&gt;&apos; &#125;); var mainbox = Vue.component(&apos;mainbox&apos;, &#123; template: &apos;&lt;div class=&quot;mainbox&quot;&gt;mainbox&lt;/div&gt;&apos; &#125;); // 创建路由对象 var router = new VueRouter(&#123; routes: [ &#123; path: &apos;/&apos;, components: &#123; default: header, a: sidebar, b: mainbox &#125; &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router &#125;); &lt;/script&gt; CSS 样式： 12345678910111213141516171819&lt;style&gt; .header &#123; border: 1px solid red; &#125; .content&#123; display: flex; &#125; .sidebar &#123; flex: 2; border: 1px solid green; height: 500px; &#125; .mainbox&#123; flex: 8; border: 1px solid blue; height: 500px; &#125;&lt;/style&gt; watch属性的使用考虑一个问题：想要实现 名 和 姓 两个文本框的内容改变，则全名的文本框中的值也跟着改变；（用以前的知识如何实现？？？） 监听data中属性的改变： 1234567891011121314151617181920212223242526&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos;, fullName: &apos;jack - chen&apos; &#125;, methods: &#123;&#125;, watch: &#123; &apos;firstName&apos;: function (newVal, oldVal) &#123; // 第一个参数是新数据，第二个参数是旧数据 this.fullName = newVal + &apos; - &apos; + this.lastName; &#125;, &apos;lastName&apos;: function (newVal, oldVal) &#123; this.fullName = this.firstName + &apos; - &apos; + newVal; &#125; &#125; &#125;); &lt;/script&gt; 监听路由对象的改变： 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt; &lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; &lt;script&gt; var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录组件&lt;/h1&gt;&apos; &#125;); var register = Vue.extend(&#123; template: &apos;&lt;h1&gt;注册组件&lt;/h1&gt;&apos; &#125;); var router = new VueRouter(&#123; routes: [ &#123; path: &quot;/login&quot;, component: login &#125;, &#123; path: &quot;/register&quot;, component: register &#125; ] &#125;); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, router: router, watch: &#123; &apos;$route&apos;: function (newVal, oldVal) &#123; if (newVal.path === &apos;/login&apos;) &#123; console.log(&apos;这是登录组件&apos;); &#125; &#125; &#125; &#125;); &lt;/script&gt; computed计算属性的使用 默认只有getter的计算属性： 12345678910111213141516171819202122&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; + &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; = &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos; &#125;, methods: &#123;&#125;, computed: &#123; // 计算属性； 特点：当计算属性中所以来的任何一个 data 属性改变之后，都会重新触发 本计算属性 的重新计算，从而更新 fullName 的值 fullName() &#123; return this.firstName + &apos; - &apos; + this.lastName; &#125; &#125; &#125;); &lt;/script&gt; 定义有getter和setter的计算属性： 123456789101112131415161718192021222324252627282930313233343536&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;firstName&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;lastName&quot;&gt; &lt;!-- 点击按钮重新为 计算属性 fullName 赋值 --&gt; &lt;input type=&quot;button&quot; value=&quot;修改fullName&quot; @click=&quot;changeName&quot;&gt; &lt;span&gt;&#123;&#123;fullName&#125;&#125;&lt;/span&gt; &lt;/div&gt; &lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; firstName: &apos;jack&apos;, lastName: &apos;chen&apos; &#125;, methods: &#123; changeName() &#123; this.fullName = &apos;TOM - chen2&apos;; &#125; &#125;, computed: &#123; fullName: &#123; get: function () &#123; return this.firstName + &apos; - &apos; + this.lastName; &#125;, set: function (newVal) &#123; var parts = newVal.split(&apos; - &apos;); this.firstName = parts[0]; this.lastName = parts[1]; &#125; &#125; &#125; &#125;); &lt;/script&gt; watch、computed和methods之间的对比 computed属性的结果会被缓存，除非依赖的响应式属性变化才会重新计算。主要当作属性来使用； methods方法表示一个具体的操作，主要书写业务逻辑； watch一个对象，键是需要观察的表达式，值是对应回调函数。主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作；可以看作是computed和methods的结合体； nrm的安装使用作用：提供了一些最常用的NPM包镜像地址，能够让我们快速的切换安装包时候的服务器地址；什么是镜像：原来包刚一开始是只存在于国外的NPM服务器，但是由于网络原因，经常访问不到，这时候，我们可以在国内，创建一个和官网完全一样的NPM服务器，只不过，数据都是从人家那里拿过来的，除此之外，使用方式完全一样； 运行npm i nrm -g全局安装nrm包； 使用nrm ls查看当前所有可用的镜像源地址以及当前所使用的镜像源地址； 使用nrm use npm或nrm use taobao切换不同的镜像源地址； 相关文件 URL中的hash（井号）]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue 重点]]></title>
    <url>%2F2018%2F10%2F13%2FVue-Akey%2F</url>
    <content type="text"><![CDATA[day1 MVC 和 MVVM 的区别 学习了 Vue 中最基本代码的结构 插值表达式 v-cloak v-text v-html v-bind（缩写是:） v-on（缩写是@） v-model v-for v-if v-show 事件修饰符 ： .stop .prevent .capture .self .once el 指定要控制的区域 data 是个对象，指定了控制的区域内要用到的数据 methods 虽然带个 s 后缀，但是是个对象，这里可以自定义了方法 在 VM 实例中，如果要访问 data 上的数据，或者要访问 methods 中的方法， 必须带 this 在 v-for 要会使用 key 属性 （只接受 string / number） v-model 只能应用于表单元素 在 vue 中绑定样式两种方式 v-bind:class v-bind:style day2 filter 过滤器 生命周期 beofreCreate 实例被创建前 created （data created）初始化完成 beforeMount 模版内存编译完成 未渲染 mounted 内存模板已经挂载到页面 beforeUpdate 数据以更新未同步到页面 updated 数据与页面以同步 vue-resource 数据获取 getInfo get 发起请求 postInfo post 发起请求 jsonpInfo jsonp 发起请求 模拟客户端获取 jsonp 数据 （node） 通过调用并执行本地的回调函数（端口，路由，数据判断，函数） nodejs 开启端口为 3000 的服务 使用前端模板引擎 express app.get 判断路由 /index 通过 url 获取到传过来的数据（query） 使用数据模板拼接 var scriptStr = ${query.callback}(${JSON.stringify(data)})(query.callback 是 url 获取过来的数据于后台服务的数据拼接) res.end(data)把数据返回 在页面中就可以用函数接收传过来的数据（showInfor123 就是页面自定义函数名） day3 动画 1 控制语句 通过@click 和 v-if 、 data 判断数据的显示隐藏 动画 2 transition css 控制 transition vue 官方控制用在 需要被动画控制滴元素，包裹起来 css 控制 v-enter [这是一个时间点] 是进入前，元素的起始状态，此时还没有进入 v-leave-to 【】是动画离开之后，离开的终止状态，此时元素动画已经结束 v-enter-active 【入场动画的时间段 v-leave-active 【离场动画的时间段 动画 修改 v-前缀(在定义多个不同动画的时候，用来解决动画重复问题) 在 transition 包裹的时候给它一个 name css 控制的时候 就可以把 v-enter 改为 my-enter （这个就可以同时定义多个不同的动画效果） 动画 3 使用第三方类 animate 第三方类 引入 入场使用 bounceIn 离场使用 bounceOut （不固定去官网看效果喜欢那个用那个） enter-active-class=”bounceIn” leave-active-class=”bounceOut” 使用 :duration=”{ enter: 200, leave: 400 }” 来分别设置 入场的时长 和 离场的时长 用法简单添加在 transition 里面就可以 动画 4 钩子函数 使用 transition 元素，把 需要被动画控制滴元素，包裹起来 绑定钩子方法 @before-enter=”beforeEnter” @enter=”enter” @after-enter=”afterEnter” 在 methods 实现方法 beforeEnter: function(el){//动画钩子函数的第一个参数：el，表示 要执行动画的那个 DOM 元素，是个原生的 JS DOM 对象}// 函数开始前 enter: function (el,done) {// done 其实就是 afterEnter 这个函数，也就是说：done 是 afterEnter 函数的引用}// 函数执行动画 afterEnter: function(el){// 动画完成后} 动画 5 动画列表 在实现列表过度的时候，如果需要过渡元素，是通过 v-for 循环渲染出来的，不能使用 transition 包裹，需要使用 transitionGroup 如果要为 v-for 循环创建的元素设置动画，必须给每一个元素 设置 :key 属性 给 ransition-group 添加 appear 属性，实现页面刚展示出来时候，入场时候的效果 通过 为 transition-group 元素，设置 tag 属性(指定渲染的类型 如：span 就会渲染成 span ul 就会渲染成 ul)，指定 transition-group 渲染为指定的元素，如果不指定 tag 属性，默认，渲染为 span 标签 组件 1 使用 Vue-extend 来创建全局的 Vue 组件 // Vue.component 第一个参赛:组件的名称，将来引用组件的时候，就是一个 标签形式 来引入 它的 第二个参赛：Vue.extend 创建的组件，其中 template 就是组件将来展示的 html 内容 123Vue.component(&apos;myCom1&apos;, Vue.extend(&#123; template: &apos;&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;&apos; // 通过 template 属性，指定了组件要展示的html结构&#125;)); 如果要使用组件，直接，把组件的名称，以 html 的标签形式，引入到页面中，即可 如果使用 Vue.component 定义组件的时候，组件名称使用了 驼峰命名，则在引用组件的时候，需要把 大写的驼峰改为小写的字母，同时，两个单词之间，使用 - 连接； 1&lt;my-com1&gt;&lt;/my-com1&gt; 组件 2 在组件 1 的基础上改进 Vue.component 第二个参赛直接返回一个对象1234Vue.component(&apos;mycom2&apos;, &#123; // 注意:不论是哪种方式创建出来的组件,组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素 template: &apos;&lt;div&gt;&lt;h3&gt;这是使用 Vue.extend 创建的组件&lt;/h3&gt;&lt;span&gt;123&lt;/span&gt;&lt;/div&gt;&apos; // 通过 template 属性，指定了组件要展示的html结构&#125;); 组件 3 在 被控制的 #app 外面，使用 template 元素，定义组件的 html 模板结构 123456&lt;template id=&apos;tmp1&apos;&gt; &lt;div&gt; &lt;h1&gt;这是通过 template 元素，在外部定义的组件结构，有代码的智能提示&lt;/h1&gt; &lt;h4&gt;好用 不错&lt;/h4&gt; &lt;/div&gt;&lt;/template&gt; 定义全局组件 123Vue.component(&apos;mycom3&apos;, &#123; template: &apos;#tmp1&apos;&#125;); 定义私有化 12345components: &#123; // 定义实例内部的私有组件 login: &#123; template: &apos;#tmp1&apos; &#125; &#125; 组件中的 data 组件可以有自己的 data 数据 组件的 data 和 实例的 data 有点不一样，实例中的 data 可以为一个对象，但是 组将中的 data 必须是一个方法 组件的 data 除了必须为一个方法，这个方法内部，还必须返回一个对象 组件中 的 data 数据 ，使用方法，和实例中的 data 使用方法完全一样！！！12345data: function () &#123; return &#123; msg: &apos;这是组件中data的数据&apos; &#125; &#125; 组件的切换 1 @click v-if v-else 控制 组件切换 2 通过改变 comName 这个数值改变显示组件（data 中 comName 是 login 就会显示 login 的数据 register 就会显示 register 的数据） 组件切换 3 通过 mode 属性，设置组件切换时候的 模式 （用来给组件添加动画的时候给 css 动画知道,等待动画完成再执行另一个动画） day4 父组件向子组件传值 父组件，可以在引用子组件的时候，通过 属性绑定（v-bind：）的形式，把 需要传递给 子组件的数据， 以属性绑定的形式，传递到子组件内部，供子组件使用 使用 props 把父组件传递过来的 （parentmsg）在 v-bind:parentmsg=”msg” 自定义的一个名称 msg 是父级的数据 属性，先在 props 数组中，定义一下，才能使用数据 组件中的 所有 props 中的数据，都是通过 父组件传递给子组件的 props 中的数据都是只读的，无法更新赋值 （其实是可以修改但是不符合规定会报错） 父组件向子组件传方法 父组件向子组件 传递 方法，使用的是 事件绑定机制 v-on，当我们自定义了 一个 事件属性之后，那么，子组建就能够，通过某些方法，来调用 传递过来的数据 1&lt;com2 @func=&quot;show&quot;&gt;&lt;/com2&gt;//func是自定义的名称 show 是父组件的方法 在子组件如何调用父组件方法 使用 emit 触发，调用 1this.$emit(&apos;func&apos;,this.sonmsg)//第一个是上面调用定义的方法名 第二个参数开始是向父组件传参数，可以有多个 localStorage.getItem 和 localStorage.setItem 本地存储的获取和设置 一般 getItem 是配和 JSON.parse 使用 转化为 json 数据 setItem 是配合 JSON.stringfy 使用 解析为本地存储格式 ref 获取 dom 元素和组件 在 元素中添加 ref=”login” （login 是自定义的名称） 在 父组件就可以用 this.$refs.login 获取到 dom 元素 this.$refs.login.show() 可直接获取到方法（show()是 login 子组件内的方法） router 页面路由 vue-router 是 vue 的路由第三方插件 创建一个路由对象，当 导入 vue-router 包之后，在 window 全局对象中，就有一个路由当架构函数，叫做 VueRouter linkActiveClass: ‘myactive’ // 通过 linkActiveClass 来修改样式属性名 在 vuerouter 内定义 redirect 重定向 1234567891011121314151617181920212223242526272829 // 在 new 路由对象当时候，可以为 构造函数，传递一个配置对象 var routerObj = new VueRouter(&#123; // route // 这个配置对象中的 route 表示[路由匹配规则]的意思 routes: [ // 路由匹配规则 // 每个路由规则，都是一个对象，这个规则对象，身上，有两个必须当属性： // 属性1 是 path，表示监听 那个路由链接地址 // 属性2 上 component，表示，如果 路由是前面匹配到的 path, 展示 component 属性对应的那个组件 // 注意： component 的属性值，必须是一个 组件的模版对象，不能是 组件的引用名称 // 不推荐使用 // &#123; // path:&quot;/&quot;, // component: login // &#125;, &#123; // 这里的 redirect 和 node 中的 redirect 完全啥两码事 path: &apos;/&apos;, redirect: &apos;/login&apos; &#125;, &#123; path: &apos;/login&apos;, component: login &#125;, &#123; path: &apos;/register&apos;, component: register &#125; ], linkActiveClass: &apos;myactive&apos; // 通过linkActiveClass 来修改样式属性名&#125;); 123456789101112131415161718192021222324252627282930/* vue-router 提供的类名修改样式 *//* .router-link-active &#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: pink;&#125; *//* 自定义类名修改样式 */.myactive &#123; color: red; font-weight: 800; font-style: italic; font-size: 80px; text-decoration: underline; background-color: pink;&#125;.v-enter,.v-leave-to &#123; opacity: 0; transform: translateX(140px);&#125;.v-enter-active,.v-leave-active &#123; transition: all .5s ease;&#125; vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 router-link 默认渲染为一个 a 标签 tag 指定渲染类型 1234567891011&lt;!-- router-link 默认渲染为一个 a标签 --&gt;&lt;!-- msg 指定渲染类型 --&gt;&lt;router-link to=&quot;/login&quot; tag=&quot;span&quot;&gt;登录&lt;/router-link&gt;&lt;router-link to=&quot;/register&quot;&gt;注册&lt;/router-link&gt;&lt;!-- 这是 vue-router 提供的元素，专门用来 当作占位符的，将来，路由规则，匹配到的组件，就会展示到这个 router-view 中去 --&gt;&lt;!-- 所以：我们可以把 router-view 认为是一个占位符 --&gt;&lt;!-- mode 定义过渡摸索 先out 再 in --&gt;&lt;transition mode=&apos;out-in&apos;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/transition&gt; 路由规则中定义参数 $route 方法一 query 如果在路由中，使用 查询字符串 则 不需要修改 路由规则对 path 属性（在 router-link 直接用?拼接） 1&lt;router-link to=&quot;/login?id=10&amp;name=李白&quot;&gt;登录&lt;/router-link&gt; 数据会存储在 $route 内的 query 的对象中 如何获取呢 因为是在子组件内部获取的本身就是自己 this 可写可不写 123console.log(this.$route.query);this.$route.query.id // 可获取到内部自己设置的idthis.$route.query.(设置的数据名) 方法二 params 与方法一不同的是数据名不是在 url 设置是直接在路由设置，直接写数据就可以 /数据 1&lt;router-link to=&quot;/login/12/yhf&quot;&gt;登录&lt;/router-link&gt; 设置了 url 再去设置路由判断 在路由后面以/:元素名的形式添加 1234routes: [&#123; path: &apos;/login/:id/:name&apos;, component: login &#125;] 数据还是会存在 $route 里面但是 不是在 query 里面了 而是在 $route 内的 params 里面 获取的方法和 query 一样 123console.log(this.$route.params);console.log(this.$route.params.id);console.log(this.$route.params.name); 路由中嵌套路由 在一个路由中我们会通过点击这个路由，展示路由中另一个路由的内容（只是更改路由处的数据不影响其他页面的显示） 设置路由 12&lt;router-link to=&quot;/login&quot;&gt;登录&lt;/router-link&gt;// 为继承account路由 所有在数据查找的时候会在根目录查找 （也是因为后面路由的设置而判断 后面的路由继承了account 路由就不可以这样 继承的事根路由就要这样用）&lt;router-link to=&quot;/account/register&quot;&gt;注册&lt;/router-link&gt; // 继承在account下的路由 设置路由 12345678910111213141516171819routes: [&#123; path: &apos;/account&apos;,// 设置主路由 component: account,// 路由展示的组件 children: [// 设置嵌套的 子路由 // 使用 children 属性，实现子路由，同时，子路由的 path 前面，不要带 / ，否则永远以根路径开始请求，这样不方便我们用户去理解URL地址 //这样就是设置了根为查找目录 &#123; path: &apos;/login&apos;, component: login &#125;, // 这个就是嵌套了子路有 不需要添加 / &#123; path: &apos;register&apos;, component: register &#125; ] &#125;] 命名视图 在同一个页面展示多个视图 在路由判断中就会被主路由覆盖 在路由判断中 路由地址 component 不止可以存放一个地址 在存放多个地址的时候 把 components 加个 s 接收对象就可以存放多个地址 12345678routes: [&#123; path: &apos;/&apos;, components: &#123; // 路由地址 &apos;default&apos;: header,// 设置多地址的时候 前面&apos;&apos; 号中填写的是这个路由的属性名（自定义） 后面的是路由地址 &apos;left&apos;: leftBox, &apos;main&apos;: mainBox &#125;&#125;] 如何使用多路由视图呢 123&lt;router-view&gt;&lt;/router-view&gt;// 主路由可不用写属性名&lt;router-view name=&quot;left&quot;&gt;&lt;/router-view&gt;// 但是子路由就必须写属性名 name&lt;router-view name=&quot;main&quot;&gt;&lt;/router-view&gt; day5 watch 监听 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数 123456789101112watch: &#123; // 使用这个 属性，可以监听 data 中指定数据的变化，然后触发这个 watch 中对应的 function 处理函数 // firstname 是data中定义的 在function的函数操作中会有两个默认的值 // newVal 是接收到监听 'firstname': function (newVal, oldVal) &#123; // this.fullname = this.firstname+'-'+this.lastname console.log(newVal+'----'+oldVal); this.fullname = newVal &#125;, 'lastname': function (newVal) &#123; this.fullname = this.firstname + '-' + newVal &#125;&#125; watch 监听路由地址的变化 1234567891011watch: &#123; // $route.path 监听路由路径 '$route.path': function (newVal, oldVal) &#123; // console.log(newVal + '-' + oldVal); if (newVal === '/login') &#123; console.log('登陆'); &#125; else &#123; console.log('注册'); &#125; &#125;&#125; computed 可以定义一些 属性，这些属性，叫做 【计算属性】， 计算属性的，本质，就是 一个方法，只不过，我们在使用 这些计算属性的时候，是把 它们的 名称，直接当作 属性来使用的；并不会把计算属性，当作方法去调用； 123456789computed: &#123; // 注意1： 计算属性，在引用的时候，一定不要加 () 去调用，直接把它 当作 普通 属性去使用就好了； // 注意2： 只要 计算属性，这个 function 内部，所用到的 任何 data 中的数据发送了变化，就会 立即重新计算 这个 计算属性的值 // 注意3： 计算属性的求值结果，会被缓存起来，方便下次直接使用； 如果 计算属性方法中，所以来的任何数据，都没有发生过变化，则，不会重新对 计算属性求值； 'fullname': function () &#123; console.log('ok'); return this.firstname + '-' + this.middlename + '-' + this.lastname; &#125;&#125; webpack 使用项目地址项目插件安装使用]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day3]]></title>
    <url>%2F2018%2F10%2F12%2FVue-day3%2F</url>
    <content type="text"><![CDATA[Vue 中的动画为什么要有动画：动画能够提高用户的体验，帮助用户更好的理解页面中的功能； 使用过渡类名 HTML 结构： 1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;动起来&quot; @click=&quot;myAnimate&quot;&gt; &lt;!-- 使用 transition 将需要过渡的元素包裹起来 --&gt; &lt;transition name=&quot;fade&quot;&gt; &lt;div v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; VM 实例： 123456789101112// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; isshow: false &#125;, methods: &#123; myAnimate() &#123; this.isshow = !this.isshow; &#125; &#125;&#125;); 定义两组类样式： 12345678910111213/* 定义进入和离开时候的过渡状态 */ .fade-enter-active, .fade-leave-active &#123; transition: all 0.2s ease; position: absolute; &#125; /* 定义进入过渡的开始状态 和 离开过渡的结束状态 */ .fade-enter, .fade-leave-to &#123; opacity: 0; transform: translateX(100px); &#125; 使用第三方 CSS 动画库 导入动画类库： 1&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./lib/animate.css&quot;&gt; 定义 transition 及属性： 123456&lt;transitiontrueenter-active-class=&quot;fadeInRight&quot; leave-active-class=&quot;fadeOutRight&quot; :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt; &lt;div class=&quot;animated&quot; v-show=&quot;isshow&quot;&gt;动画哦&lt;/div&gt;&lt;/transition&gt; 使用动画钩子函数 定义 transition 组件以及三个钩子函数： 123456789&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;切换动画&quot; @click=&quot;isshow = !isshow&quot;&gt; &lt;transition @before-enter=&quot;beforeEnter&quot; @enter=&quot;enter&quot; @after-enter=&quot;afterEnter&quot;&gt; &lt;div v-if=&quot;isshow&quot; class=&quot;show&quot;&gt;OK&lt;/div&gt; &lt;/transition&gt; &lt;/div&gt; 定义三个 methods 钩子方法： 12345678910111213methods: &#123; beforeEnter(el) &#123; // 动画进入之前的回调 el.style.transform = &apos;translateX(500px)&apos;; &#125;, enter(el, done) &#123; // 动画进入完成时候的回调 el.offsetWidth; el.style.transform = &apos;translateX(0px)&apos;; done(); &#125;, afterEnter(el) &#123; // 动画进入完成之后的回调 this.isshow = !this.isshow; &#125; &#125; 定义动画过渡时长和样式： 123.show&#123; transition: all 0.4s ease; &#125; v-for 的列表过渡 定义过渡样式： 123456789101112&lt;style&gt; .list-enter, .list-leave-to &#123; opacity: 0; transform: translateY(10px); &#125; .list-enter-active, .list-leave-active &#123; transition: all 0.3s ease; &#125;&lt;/style&gt; 定义 DOM 结构，其中，需要使用 transition-group 组件把 v-for 循环的列表包裹起来： 1234567&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;txt&quot; @keyup.enter=&quot;add&quot;&gt; &lt;transition-group tag=&quot;ul&quot; name=&quot;list&quot;&gt; &lt;li v-for=&quot;(item, i) in list&quot; :key=&quot;i&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt; &lt;/transition-group&gt;&lt;/div&gt; 定义 VM 中的结构： 1234567891011121314// 创建 Vue 实例，得到 ViewModelvar vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; txt: &apos;&apos;, list: [1, 2, 3, 4] &#125;, methods: &#123; add() &#123; this.list.push(this.txt); this.txt = &apos;&apos;; &#125; &#125;&#125;); 列表的排序过渡&lt;transition-group&gt; 组件还有一个特殊之处。不仅可以进入和离开动画，还可以改变定位。要使用这个新功能只需了解新增的 v-move 特性，它会在元素的改变定位的过程中应用。 v-move 和 v-leave-active 结合使用，能够让列表的过渡更加平缓柔和： 123456.v-move&#123; transition: all 0.8s ease;&#125;.v-leave-active&#123; position: absolute;&#125; 定义Vue组件什么是组件： 组件的出现，就是为了拆分Vue实例的代码量的，能够让我们以不同的组件，来划分不同的功能模块，将来我们需要什么样的功能，就可以去调用对应的组件即可；组件化和模块化的不同： 模块化： 是从代码逻辑的角度进行划分的；方便代码分层开发，保证每个功能模块的职能单一； 组件化： 是从UI界面的角度进行划分的；前端的组件化，方便UI组件的重用；全局组件定义的三种方式 使用 Vue.extend 配合 Vue.component 方法：1234var login = Vue.extend(&#123; template: &apos;&lt;h1&gt;登录&lt;/h1&gt;&apos; &#125;); Vue.component(&apos;login&apos;, login); 直接使用 Vue.component 方法： 123Vue.component(&apos;register&apos;, &#123; template: &apos;&lt;h1&gt;注册&lt;/h1&gt;&apos; &#125;); 将模板字符串，定义到script标签种： 123&lt;script id=&quot;tmpl&quot; type=&quot;x-template&quot;&gt; &lt;div&gt;&lt;a href=&quot;#&quot;&gt;登录&lt;/a&gt; | &lt;a href=&quot;#&quot;&gt;注册&lt;/a&gt;&lt;/div&gt; &lt;/script&gt; 同时，需要使用 Vue.component 来定义组件：123Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos; &#125;); 注意： 组件中的DOM结构，有且只能有唯一的根元素（Root Element）来进行包裹！ 组件中展示数据和响应事件 在组件中，data需要被定义为一个方法，例如： 12345678910111213Vue.component(&apos;account&apos;, &#123; template: &apos;#tmpl&apos;, data() &#123; return &#123; msg: &apos;大家好！&apos; &#125; &#125;, methods:&#123; login()&#123; alert(&apos;点击了登录按钮&apos;); &#125; &#125; &#125;); 在子组件中，如果将模板字符串，定义到了script标签中，那么，要访问子组件身上的data属性中的值，需要使用this来访问； 【重点】为什么组件中的data属性必须定义为一个方法并返回一个对象 通过计数器案例演示 使用components属性定义局部子组件 组件实例定义方式： 123456789101112131415161718&lt;script&gt; // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123;&#125;, methods: &#123;&#125;, components: &#123; // 定义子组件 account: &#123; // account 组件 template: &apos;&lt;div&gt;&lt;h1&gt;这是Account组件&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;login&gt;&lt;/login&gt;&lt;/div&gt;&apos;, // 在这里使用定义的子组件 components: &#123; // 定义子组件的子组件 login: &#123; // login 组件 template: &quot;&lt;h3&gt;这是登录组件&lt;/h3&gt;&quot; &#125; &#125; &#125; &#125; &#125;); &lt;/script&gt; 引用组件： 123&lt;div id=&quot;app&quot;&gt; &lt;account&gt;&lt;/account&gt; &lt;/div&gt; 使用flag标识符结合v-if和v-else切换组件 页面结构： 12345&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;toggle&quot; @click=&quot;flag=!flag&quot;&gt; &lt;my-com1 v-if=&quot;flag&quot;&gt;&lt;/my-com1&gt; &lt;my-com2 v-else=&quot;flag&quot;&gt;&lt;/my-com2&gt; &lt;/div&gt; Vue实例定义： 123456789101112131415161718&lt;script&gt; Vue.component(&apos;myCom1&apos;, &#123; template: &apos;&lt;h3&gt;奔波霸&lt;/h3&gt;&apos; &#125;) Vue.component(&apos;myCom2&apos;, &#123; template: &apos;&lt;h3&gt;霸波奔&lt;/h3&gt;&apos; &#125;) // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; flag: true &#125;, methods: &#123;&#125; &#125;); &lt;/script&gt; 使用:is属性来切换不同的子组件,并添加切换动画 组件实例定义方式： 12345678910111213141516171819202122// 登录组件 const login = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;登录组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component(&apos;login&apos;, login); // 注册组件 const register = Vue.extend(&#123; template: `&lt;div&gt; &lt;h3&gt;注册组件&lt;/h3&gt; &lt;/div&gt;` &#125;); Vue.component(&apos;register&apos;, register); // 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; comName: &apos;login&apos; &#125;, methods: &#123;&#125; &#125;); 使用component标签，来引用组件，并通过:is属性来指定要加载的组件： 12345678&lt;div id=&quot;app&quot;&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;comName=&apos;login&apos;&quot;&gt;登录&lt;/a&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;comName=&apos;register&apos;&quot;&gt;注册&lt;/a&gt; &lt;hr&gt; &lt;transition mode=&quot;out-in&quot;&gt; &lt;component :is=&quot;comName&quot;&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/div&gt; 添加切换样式： 1234567891011121314151617&lt;style&gt; .v-enter, .v-leave-to &#123; opacity: 0; transform: translateX(30px); &#125; .v-enter-active, .v-leave-active &#123; position: absolute; transition: all 0.3s ease; &#125; h3&#123; margin: 0; &#125;&lt;/style&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day1 案例]]></title>
    <url>%2F2018%2F10%2F08%2F2018-10-08(1)%2F</url>
    <content type="text"><![CDATA[案例分布 跑马灯效果 简易计算器 一、跑马灯效果重点 @click(v-on:click)点击事件 字符串的截取和赋值 定时器的控制 效果图 案例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1.倒入vue包 --&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 2.创建一个要控制的区域 --&gt; &lt;div id="app"&gt; &lt;input type="button" value="浪起来" @click="lang"&gt; &lt;input type="button" value="低调" @click="stop"&gt; &lt;h4&gt;&#123;&#123;msg&#125;&#125;&lt;/h4&gt; &lt;/div&gt;&lt;/body&gt; &lt;script&gt; //注意；在vm实例中，如果想要获取data上的数据，或者想要调用methos中的方法，必须通过this.数据名 或 this.方法名来进行访问，这里的this 就等于我们new出来的vm 实例对象 var vm = new Vue(&#123; el: '#app', data:&#123; msg: '猥琐发育，别浪～～！', intervalId:null //在data上定义 定时器Id &#125;, methods:&#123; lang() &#123; console.log(this.msg) if(this.intervalId != null) return; this.intervalId = setInterval(() =&gt; &#123; //获取到头的第一个字符 var start = this.msg.substring(0,1) // 获取到后面的所有字符 var end = this.msg.substring(1) // 重新拼接到新的字符串，并附值到 this.msg this.msg = end + start &#125;,400) //注意：vm实例，会监听自己身上的data 中所有数据的变化 ，只要数据一发生变化，就会自动把 最新的数据，从data上同步到页面中去；【好处：程序员只需要关系数据,不需要考虑重新渲染dom页面】 &#125;, stop() &#123;//停止定时器 clearInterval(this.intervalId) // 每当清楚了定时器之后，需要重新把定时器重制为null this.intervalId = null; &#125; &#125; &#125;) // 分析： // 1.给 【浪起来】 按钮，绑定一个点击事件 v-on @ // 2.在按钮灯事件处理函数中，雌鹅相关灯业务逻辑代码：拿到msg字符串，然后调用字符串灯 substring 来进行字符串灯截取操作，吧 第一个截取出来放到最后面 // 3.为了实习点击按钮，自动截取的功能，需要把2步骤放到定时器里面 &lt;/script&gt;&lt;/html&gt; 二、简易计算器重点 v-model(数据双向绑定) v-click(点击事件) 数据的判断 效果图 案例代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;input type="text" v-model="n1"&gt; &lt;select v-model="opt"&gt; &lt;option value="+"&gt;+&lt;/option&gt; &lt;option value="-"&gt;-&lt;/option&gt; &lt;option value="*"&gt;*&lt;/option&gt; &lt;option value="/"&gt;/&lt;/option&gt; &lt;/select&gt; &lt;input type="text" v-model="n2"&gt; &lt;input type="button" value="=" @click="calc"&gt; &lt;input type="text" v-model="result"&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; var vm = new Vue(&#123; el:'#app', data: &#123; n1: 0, n2: 0, result: 0, opt: '+' &#125;, methods:&#123; calc()&#123;//计算器算数的方法 //逻辑: // switch(this.opt)&#123; // case '+': // this.result = parseInt(this.n1)+parseInt(this.n2) // break; // case '-': // this.result = parseInt(this.n1)-parseInt(this.n2) // break; // case '*': // this.result = parseInt(this.n1)*parseInt(this.n2) // break; // case '/': // this.result = parseInt(this.n1)/parseInt(this.n2) // break; // &#125; //注意:这是投机取巧的方式，正式开发中尽量少用 var cideStr = 'parseInt(this.n1)'+this.opt+'parseInt(this.n2)' this.result = eval(cideStr) &#125; &#125; &#125;)&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day2 案例]]></title>
    <url>%2F2018%2F10%2F08%2F2018-10-08(2)%2F</url>
    <content type="text"><![CDATA[案例分布 品牌列表案例 一、品牌列表案例重点 vue 指令 v-model(数据双向绑定) v-on(点击事件) v-focus(光标定位) 自定义 v-color(颜色改变) 自定义 @keyup(键盘抬起) vue 添加方法 new Vue({}) add()添加方法 del(id)删除方法 search 检索 关键字 Vue.filter 全局过滤器(过滤时间) filters 私有化过滤器(局部) padStart(填充完毕后的总数, 在前面填充的元素) 字符串新特性 Vue.directive 全局自定义方法 自定义获取焦点 directives 私有化自定义方法 Vue.config.keyCodes.f2 = 113 自定义全局按键修饰符 （Vue.config 配置） 效果图 案例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="./lib/bootstrap-3.3.7.css"&gt; &lt;!-- 需要用到jquery吗？ --&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="app"&gt; &lt;div class="panel panel-primary"&gt; &lt;div class="panel-heading"&gt; &lt;h3 class="panel-title"&gt; 添加品牌 &lt;/h3&gt; &lt;/div&gt; &lt;div class="panel-body form-inline"&gt; &lt;label&gt; Id: &lt;input type="text" class="form-control" v-model="id"&gt; &lt;/label&gt; &lt;label&gt; Name: &lt;input type="text" class="form-control" v-model="name" @keyup.f2="add"&gt; &lt;/label&gt; &lt;!-- 在 vue中，使用事件绑定机制，为元素制定处理函数都时候，如果加了小括号，就可以为函数传参 --&gt; &lt;input type="button" value="添加" class="btn btn-primary" @click="add"&gt; &lt;label&gt; 搜索名称关键字: &lt;!-- vue中所有的指令，在调用的时候，都以v-开头 --&gt; &lt;input type="text" class="form-control" v-model="keywords" id="search" v-focus v-color="'pink'"&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;table class="table table-bordered table-hover table-striped"&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Id&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;th&gt;Ctime&lt;/th&gt; &lt;th&gt;Operation&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;thead&gt; &lt;!-- 之前，v-for 中的数据 都是直接从data 上的list中直接渲染过来的 --&gt; &lt;!-- 现在， 我们自定义的一个 search 方法，同时，把 搜索的关键字，通过传参的形式，传递给了search 方法 --&gt; &lt;!-- 在 search 方法内部，通过 执行 for 循环，把所有符合 搜索关键字的数据，保管到 一个新数组中。返回 --&gt; &lt;tr v-for="item in search(keywords)" :key="item.id"&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td v-text="item.name"&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123; item.ctime | dateFormat() &#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href="" @click.prevent="del(item.id)"&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id="app2"&gt; &lt;h3 v-color="'red'" v-fontweight="900" v-fontsize="'50px'"&gt;&#123;&#123;dt | dateFormat&#125;&#125;&lt;/h3&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 全局的过滤器，进行时间的格式化 // 所谓的全局过滤器，就是所有的vm实例都共享的 Vue.filter('dateFormat',function (dataStr, pattern="")&#123; //根据给定的时间字符串，得到特定的时间 var dt = new Date(dataStr) var y = dt.getFullYear() var m = dt.getMonth() + 1 var d = dt.getDate() // return y + '-' + m + '-' d // return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` if(pattern.toLowerCase() === 'yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125;else &#123; var hh = dt.getHours() var mm = dt.getMinutes() var ss = dt.getSeconds() return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125;) // 自定义全局按键修饰符 Vue.config.keyCodes.f2 = 113 //使用vue.directive() 定义全局都指令 // 其中：参数1:指令的名称，注意，在定义都时候，指令都名称前面，不需要加 v- 前缀， // 但是：在调用都时候，必须 在指令都名称前面 加上 v- 前缀来进行调用 // 参数2: 是一个对象，这个对象身上，有一些指令相关都函数，这些函数可以在特定都阶段执行相关的操作 Vue.directive('focus',&#123; bind: function(el)&#123;//每当指令绑定到元素上的时候，会立即执行这个 bind 函数 ，只执行一次 // 注意： 在每个 函数中，第一个参数 el， 表示 被绑定了指令的那个元素，这个 el 参数，数一个原生的js对象 // 在元素 刚绑定了指令的时候，还没有 插入到 dom中去，这时候，调用focus 方法没有作用 // 因为，一个元素，只有插入dom之后，才能获取到焦点 // el.focus() &#125;, inserted: function(el)&#123;//表示元素 插入到dom中的时候会执行 inserted 函数 只触发一次 el.focus() // 和js行为有关的操作最好在inserted中执行，防止js行为不生效 &#125;, updated: function()&#123;//当vnode更新的时候，会执行 updated ，可能会触发多次 &#125; &#125;) //自定义一个 设置字体颜色的指令 Vue.directive('color', &#123; // 样式，只要通过指令绑定给了元素，不管这个元素有没有插入到页面中去，这个元素肯定有了一个内联的样式 // 将来元素肯定会显示到页面中，这时候，浏览器的渲染引擎必然会解析样式，应用给这个元素 bind: function(el,binding)&#123; // el.style.color = 'red' // 和样式相关的操作，一般都可以在bind中执行 el.style.color = binding.value &#125; &#125;) var vm = new Vue(&#123; el:'#app', data: &#123; id:'', name:'', keywords: '', //搜索关键字 list:[ &#123;id: 1 , name: '奔驰' , ctime: new Date() &#125;, &#123;id: 2 , name: '宝马' , ctime: new Date() &#125; ] &#125;, methods:&#123; add()&#123;//添加的方法 // 分析： // 1.获取到 id 和 name，直接从data上获取 // 2.组织出一个对象 // 3.把对象调用数组都相关方法，添加到当前data上的list中 // 4.注意：在vue中已经实现数据都双向绑定，每当我们修改了data中的数据vue会默认监听到数据的改动，自动更新数据应用到页面上 // 5.当我们意识到上面的第四步的时候，就证明打击已经入门vue了，我们更多的是在进行vm中model数据的操作，同时在操作model数据的时候，指定的业务逻辑操作 var car = &#123; id:this.id , name: this.name , ctime: new Date()&#125; this.list.push(car) this.id = this.name = '' &#125;, del(id)&#123;//根据id删数据 // 分析： // 1.如何根据id找到要删除对象的索引 // 2.如果找到索引了，直接调用 数组的splice方法 // this.list.some((item,i)=&gt;&#123; // if(item.id == id)&#123; // this.list.splice(i,1) // // 在数组的some方法中，如果return true，就会立即终止这个数组的后续循环 // return true; // &#125; // &#125;) var index = this.list.findIndex(item =&gt; &#123; if(item.id == id)&#123; return true; &#125; &#125;) this.list.splice(index,1) &#125;, search(keywords)&#123;//根据关键字，进行数据的搜索 // var newList = [] // this.list.forEach(item=&gt;&#123; // if(item.name.indexOf(keywords) != -1)&#123; // newList.push(item) // &#125; // &#125;) // return newList; // 注意： forEach some filter findIndex 这些都是属于数组的新方法 // 都会对数组中的每一项，进行遍历，执行相关的操作 return this.list.filter(item =&gt; &#123; // if(item.name.indexOf(keywords) != -1) // 注意：ES6中，为字符窜提供了一个新方法，叫做 String.prototype.includes(‘要包含的字符串’) // 如果包含，则返回 true ，否则返回 false // contains if(item.name.includes(keywords))&#123; return item &#125; &#125;) &#125; &#125; &#125;); // 如何自定义一个私有的过滤器（局部） var vm2 = new Vue(&#123; el: '#app2', data: &#123; dt: new Date() &#125;, methods: &#123;&#125;, filters: &#123;//定义私有过滤器 过滤器又两个条件 【过滤器名称 和 处理函数】 //过滤器调用的时候，采用的是就近原则，如果私有过滤器和全局过滤器名称一直，会优先调用私有的过滤器 dateFormat: function (dataStr, pattern="")&#123; //根据给定的时间字符串，得到特定的时间 var dt = new Date(dataStr) var y = dt.getFullYear() var m = (dt.getMonth() + 1).toString().padStart(2,'0') var d = dt.getDate().toString().padStart(2,'0') // return y + '-' + m + '-' d // return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` if(pattern.toLowerCase() === 'yyyy-mm-dd')&#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;` &#125;else &#123; var hh = dt.getHours().toString().padStart(2,'0') var mm = dt.getMinutes().toString().padStart(2,'0') var ss = dt.getSeconds().toString().padStart(2,'0') return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;` &#125; &#125; &#125;, directives: &#123; //自定义私有指令 'fontweight': &#123;//设置字体粗细 bind: function (el, binding)&#123; el.style.fontWeight = binding.value &#125; &#125;, 'fontsize': function (el, binding)&#123;//注意：这个是 function 等同于 把 代码写到 bind 和 update中去 el.style.fontSize = parseInt(binding.value) + 'px' &#125; &#125; &#125;) //过滤器的定于语法 // Vue.filter('过滤器的名称',function()&#123;&#125;) // 过滤器中的function，第一个参数 ，已经背规定死，永远都是，过滤器 管道符前面 传过了的数据 // Vue.filter('过滤器的名称',function (data) &#123; // return data +'123' // &#125;) // document.getElementById('search').focus()&lt;/script&gt;&lt;/html&gt;&lt;!-- 过滤器调用时候的格式 &#123;&#123;name | 过滤器的名称&#125;&#125; --&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue 案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day2]]></title>
    <url>%2F2018%2F10%2F08%2FVue-day2%2F</url>
    <content type="text"><![CDATA[vue 生命周期表 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的 filterBy 指令，在 2.x 中已经被废除： filterBy - 指令 123456789101112131415&lt;tr v-for=&quot;item in list | filterBy searchName in &apos;name&apos;&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在 2.x 版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 123&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的 methods 方法，同时，把过滤条件searchName传递进去： 12345678910111213141516171819&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 123456789search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue 调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML 元素： 1&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) &#123; // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用 ES6 中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器1234567891011121314151617181920212223242526272829303132333435363738394041// 定义一个全局过滤器Vue.filter(&apos;dataFormat&apos;, function (input, pattern = &apos;&apos;) &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x 中自定义键盘修饰符【了解即可】1Vue.directive(&apos;on&apos;).keyCodes.f2 = 113; 2.x 中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 1Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 1&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; 自定义指令 自定义全局和局部的 自定义指令： 1234567891011121314151617181920212223242526272829303132333435// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive(&apos;focus&apos;, &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, &apos;font-weight&apos;: function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 1&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&apos;red&apos;&quot; v-font-weight=&quot;900&quot;&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective(&apos;red-color&apos;, &#123; bind: function () &#123; this.el.style.color = &apos;red&apos;; &#125;&#125;); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; vue 实例的生命周期 什么是生命周期：从 Vue 实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件，统称为生命周期！ 生命周期钩子：就是生命周期事件的别名而已； 生命周期钩子 = 生命周期函数 = 生命周期事件 主要的生命周期函数分类： 创建期间的生命周期函数： + beforeCreate：实例刚在内存中被创建出来，此时，还没有初始化好 data 和 methods 属性 + created：实例已经在内存中创建 OK，此时 data 和 methods 已经创建 OK，此时还没有开始 编译模板 + beforeMount：此时已经完成了模板的编译，但是还没有挂载到页面中 + mounted：此时，已经将编译好的模板，挂载到了页面指定的容器中显示 运行期间的生命周期函数： + beforeUpdate：状态更新之前执行此函数， 此时 data 中的状态值是最新的，但是界面上显示的 数据还是旧的，因为此时还没有开始重新渲染 DOM 节点 + updated：实例更新完毕之后调用此函数，此时 data 中的状态值 和 界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了！ 销毁期间的生命周期函数： + beforeDestroy：实例销毁之前调用。在这一步，实例仍然完全可用。 + destroyed：Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 vue-resource 实现 get, post, jsonp 请求除了 vue-resource 之外，还可以使用 axios 的第三方包实现实现数据的请求 之前的学习中，如何发起数据请求？ 常见的数据请求类型？ get post jsonp 测试的 URL 请求资源地址： get 请求地址： http://vue.studyit.io/api/getlunbo post 请求地址：http://vue.studyit.io/api/post jsonp 请求地址：http://vue.studyit.io/api/jsonp JSONP 的实现原理 由于浏览器的安全性限制，不允许 AJAX 访问 协议不同、域名不同、端口号不同的 数据接口，浏览器认为这种访问不安全； 可以通过动态创建 script 标签的形式，把 script 标签的 src 属性，指向数据接口的地址，因为 script 标签不存在跨域限制，这种数据获取方式，称作 JSONP（注意：根据 JSONP 的实现原理，知晓，JSONP 只支持 Get 请求）； 具体实现过程： - 先在客户端定义一个回调方法，预定义对数据的操作； - 再把这个回调方法的名称，通过 URL 传参的形式，提交到服务器的数据接口； - 服务器数据接口组织好要发送给客户端的数据，再拿着客户端传递过来的回调方法名称，拼接出一个调用这个方法的字符串，发送给客户端去解析执行； - 客户端拿到服务器返回的字符串之后，当作 Script 脚本去解析执行，这样就能够拿到 JSONP 的数据了； 带大家通过 Node.js ，来手动实现一个 JSONP 的请求例子； 1234567891011121314151617181920212223242526272829303132333435const http = require(&apos;http&apos;);// 导入解析 URL 地址的核心模块const urlModule = require(&apos;url&apos;);const server = http.createServer();// 监听 服务器的 request 请求事件，处理每个请求server.on(&apos;request&apos;, (req, res) =&gt; &#123; const url = req.url; // 解析客户端请求的URL地址 var info = urlModule.parse(url, true); // 如果请求的 URL 地址是 /getjsonp ，则表示要获取JSONP类型的数据 if (info.pathname === &apos;/getjsonp&apos;) &#123; // 获取客户端指定的回调函数的名称 var cbName = info.query.callback; // 手动拼接要返回给客户端的数据对象 var data = &#123; name: &apos;zs&apos;, age: 22, gender: &apos;男&apos;, hobby: [&apos;吃饭&apos;, &apos;睡觉&apos;, &apos;运动&apos;] &#125; // 拼接出一个方法的调用，在调用这个方法的时候，把要发送给客户端的数据，序列化为字符串，作为参数传递给这个调用的方法： var result = `$&#123;cbName&#125;($&#123;JSON.stringify(data)&#125;)`; // 将拼接好的方法的调用，返回给客户端去解析执行 res.end(result); &#125; else &#123; res.end(&apos;404&apos;); &#125;&#125;);server.listen(3000, () =&gt; &#123; console.log(&apos;server running at http://127.0.0.1:3000&apos;);&#125;); vue-resource 的配置步骤： 直接在页面中，通过script标签，引入 vue-resource 的脚本文件； 注意：引用的先后顺序是：先引用 Vue 的脚本文件，再引用 vue-resource 的脚本文件； 发送 get 请求： 12345getInfo() &#123; // get 方式获取数据 this.$http.get(&apos;http://127.0.0.1:8899/api/getlunbo&apos;).then(res =&gt; &#123; console.log(res.body); &#125;)&#125; 发送 post 请求： 12345678910postInfo() &#123; var url = &apos;http://127.0.0.1:8899/api/post&apos;; // post 方法接收三个参数： // 参数1： 要请求的URL地址 // 参数2： 要发送的数据对象 // 参数3： 指定post提交的编码类型为 application/x-www-form-urlencoded this.$http.post(url, &#123; name: &apos;zs&apos; &#125;, &#123; emulateJSON: true &#125;).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 发送 JSONP 请求获取数据： 123456jsonpInfo() &#123; // JSONP形式从服务器获取数据 var url = &apos;http://127.0.0.1:8899/api/jsonp&apos;; this.$http.jsonp(url).then(res =&gt; &#123; console.log(res.body); &#125;);&#125; 配置本地数据库和数据接口 API 先解压安装 PHPStudy; 解压安装 Navicat 这个数据库可视化工具，并激活； 打开 Navicat 工具，新建空白数据库，名为 dtcmsdb4; 双击新建的数据库，连接上这个空白数据库，在新建的数据库上右键 -&gt; 运行SQL文件，选择并执行 dtcmsdb4.sql 这个数据库脚本文件；如果执行不报错，则数据库导入完成； 进入文件夹 vuecms3_nodejsapi 内部，执行 npm i 安装所有的依赖项； 先确保本机安装了 nodemon, 没有安装，则运行 npm i nodemon -g 进行全局安装，安装完毕后，进入到 vuecms3_nodejsapi目录 -&gt; src目录 -&gt; 双击运行 start.bat 如果 API 启动失败，请检查 PHPStudy 是否正常开启，同时，检查 app.js 中第 14行 中数据库连接配置字符串是否正确；PHPStudy 中默认的 用户名是 root，默认的密码也是 root 品牌管理改造展示品牌列表添加品牌数据删除品牌数据相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 pagekit/vue-resource navicat 如何导入 sql 文件和导出 sql 文件 贝塞尔在线生成器]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue day1]]></title>
    <url>%2F2018%2F10%2F08%2FVue-day1%2F</url>
    <content type="text"><![CDATA[day1 总结 MVC 和 MVVM 的区别 学习了Vue中最基本代码的结构 插值表达式 v-cloak v-text v-html v-bind（缩写是:） v-on（缩写是@） v-model v-for v-if v-show 事件修饰符 ： .stop .prevent .capture .self .once el 指定要控制的区域 data 是个对象，指定了控制的区域内要用到的数据 methods 虽然带个s后缀，但是是个对象，这里可以自定义了方法 在 VM 实例中，如果要访问 data 上的数据，或者要访问 methods 中的方法， 必须带 this 在 v-for 要会使用 key 属性 （只接受 string / number） v-model 只能应用于表单元素 在vue中绑定样式两种方式 v-bind:class v-bind:style 什么是 Vue.js Vue.js 是目前最火的一个前端框架，React 是最流行的一个前端框架（React 除了开发网站，还可以开发手机 App， Vue 语法也是可以用于进行手机 App 开发的，需要借助于 Weex） Vue.js 是前端的主流框架之一，和 Angular.js、React.js 一起，并成为前端三大主流框架！ Vue.js 是一套构建用户界面的框架，只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。（Vue 有配套的第三方类库，可以整合起来做大型项目的开发） 前端的主要工作？主要负责 MVC 中的 V 这一层；主要工作就是和界面打交道，来制作前端页面效果； 为什么要学习流行框架 企业为了提高开发效率：在企业中，时间就是效率，效率就是金钱； 企业中，使用框架，能够提高开发的效率； 提高开发效率的发展历程：原生 JS -&gt; Jquery 之类的类库 -&gt; 前端模板引擎 -&gt; Angular.js / Vue.js（能够帮助我们减少不必要的 DOM 操作；提高渲染效率；双向数据绑定的概念【通过框架提供的指令，我们前端程序员只需要关心数据的业务逻辑，不再关心 DOM 是如何渲染的了】） 在 Vue 中，一个核心的概念，就是让用户不再操作 DOM 元素，解放了用户的双手，让程序员可以更多的时间去关注业务逻辑； 增强自己就业时候的竞争力 人无我有，人有我优 你平时不忙的时候，都在干嘛？ 框架和库的区别 框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。 node 中的 express； 库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。 从 Jquery 切换到 Zepto 从 EJS 切换到 art-template Node（后端）中的 MVC 与 前端中的 MVVM 之间的区别 MVC 是后端的分层开发概念； MVVM 是前端视图层的概念，主要关注于 视图层分离，也就是说：MVVM 把前端的视图层，分为了 三部分 Model, View , VM ViewModel 为什么有了 MVC 还要有 MVVM Vue.js 基本的代码结构和插值表达式 和 MVVM 之间的对应关系1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;!-- 1.导入vue的包 --&gt; &lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 将来new的vue实例，会控制这个元素中的所有内容 --&gt; &lt;!-- vue 实例所控制的这个元素区域，就是我们的 v--&gt; &lt;div id="app"&gt; &lt;p&gt;&#123;&#123;msg&#125;&#125;&lt;/p&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; // 2.创建个vue的实例 // 当我们导入包在浏览器中多了vue构造函数 // 注意我们new出来的这个vm对象就是我们mvvm中的 vm调度者 var vm = new Vue(&#123; el:'#app', //表示当前我们new的这个vue实例要控制表面上的那区域 // 这里了的data 就是mvvm中的m，专门用俩保存每个页面的数据 data: &#123; //data属性中，存放的是el中的实例 msg: '欢迎学习vue' //通过vue提供的指令很方便的渲染到页面上，程序员不再需要手动操作dom元素 &#125; &#125;) &lt;/script&gt;&lt;/html&gt; Vue 之 - v-cloak12 &lt;!-- 使用 v-cloak 能解决 插值表达式闪烁问题 --&gt;&lt;p v-cloak&gt;======&#123;&#123;msg&#125;&#125;-------&lt;/p&gt; Vue 指令之v-text和v-html12345678&lt;h4 v-text="msg"&gt;&lt;/h4&gt;&lt;!-- 默认v-text 是没有闪烁问题的 --&gt;&lt;!-- v-text 会覆盖元素用原本的内容，但是 插入值表达式 只会替换自己的这个占位符，不会整个元素的内容清空 --&gt;&lt;div&gt;&#123;&#123;msg2&#125;&#125;&lt;/div&gt;&lt;div v-text="msg2"&gt;&lt;/div&gt;&lt;div v-html="msg2"&gt;&lt;/div&gt;&lt;!-- html 插入html的效果表达式 --&gt; 12345678910111213141516&lt;script src="./lib/vue-2.4.0.js"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#id', data: &#123; msg: '我是你爸爸', msg2: '&lt;h1&gt;哈哈，我是你爸爸，我很骄傲&lt;/h1&gt;', mytitle: '这是一个自己定义的title' &#125;, methods: &#123; //这个methos属性中定义当前vue实例所有可用的方法 show: function () &#123; alert("我是你爸爸") &#125; &#125; &#125;)&lt;/script&gt; Vue 指令之v-bind的三种用法 直接使用指令v-bind 使用简化指令: 在绑定的时候，拼接绑定内容：:title=&quot;btnTitle + &#39;, 这是追加的内容&#39;&quot; 123456&lt;!-- v-bind: 是 vue中 用来绑定属性的指令 --&gt;&lt;input type="button" value="按钮" v-bind:title="mytitle + '123'"&gt;&lt;!-- 注意： v-bind： 指令可以被简写位:要绑定的属性 --&gt;&lt;!-- v-bind中，可以写合法的js表达式 --&gt;&lt;!-- js 代码看v-text v-html处 --&gt; Vue 指令之v-on和跑马灯效果v-on 直接使用指令v-on 使用简化指令@ 12345678&lt;!-- vue 中提供了 v-on ：事件绑定机制 --&gt;&lt;!-- &lt;input type="button" value="按钮" :title="mytitle + '123'"&gt; --&gt;&lt;input type="button" v-on:click="show" :value="mytitle + '123'"&gt;&lt;input type="button" value="按钮" @click="show"&gt;&lt;input type="button" value="按钮" v-on:mouseover="show"&gt;&lt;!-- js 代码看v-text v-html处 --&gt; 跑马灯效果 HTML 结构： 123456789&lt;div id=&quot;app&quot;&gt; &lt;p&gt;&#123;&#123;info&#125;&#125;&lt;/p&gt; &lt;input type=&quot;button&quot; value=&quot;开启&quot; v-on:click=&quot;go&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;停止&quot; v-on:click=&quot;stop&quot;&gt; &lt;/div&gt; Vue 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; info: &apos;猥琐发育，别浪~！&apos;, intervalId: null &#125;, methods: &#123; go() &#123; // 如果当前有定时器在运行，则直接return if (this.intervalId != null) &#123; return; &#125; // 开始定时器 this.intervalId = setInterval(() =&gt; &#123; this.info = this.info.substring(1) + this.info.substring(0, 1); &#125;, 500); &#125;, stop() &#123; clearInterval(this.intervalId); &#125; &#125; &#125;); Vue 指令之v-on的缩写和事件修饰符事件修饰符： .stop 阻止冒泡 .prevent 阻止默认事件 .capture 添加事件侦听器时使用事件捕获模式 .self 只当事件在该元素本身（比如不是子元素）触发时触发回调 .once 事件只触发一次 Vue 指令之v-model和双向数据绑定简易计算器案例 HTML 代码结构 1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;n1&quot;&gt; &lt;select v-model=&quot;opt&quot;&gt; &lt;option value=&quot;0&quot;&gt;+&lt;/option&gt; &lt;option value=&quot;1&quot;&gt;-&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;*&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;÷&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;text&quot; v-model=&quot;n2&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;=&quot; v-on:click=&quot;getResult&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;result&quot;&gt;&lt;/div&gt; Vue 实例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 创建 Vue 实例，得到 ViewModel var vm = new Vue(&#123; el: &apos;#app&apos;, data: &#123; n1: 0, n2: 0, result: 0, opt: &apos;0&apos; &#125;, methods: &#123; getResult() &#123; switch (this.opt) &#123; case &apos;0&apos;: this.result = parseInt(this.n1) + parseInt(this.n2); break; case &apos;1&apos;: this.result = parseInt(this.n1) - parseInt(this.n2); break; case &apos;2&apos;: this.result = parseInt(this.n1) * parseInt(this.n2); break; case &apos;3&apos;: this.result = parseInt(this.n1) / parseInt(this.n2); break; &#125; &#125; &#125; &#125;); 在 Vue 中使用样式使用 class 样式 数组 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中使用三元表达式 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, isactive?&apos;active&apos;:&apos;&apos;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 数组中嵌套对象 1&lt;h1 :class=&quot;[&apos;red&apos;, &apos;thin&apos;, &#123;&apos;active&apos;: isactive&#125;]&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 直接使用对象 1&lt;h1 :class=&quot;&#123;red:true, italic:true, active:true, thin:true&#125;&quot;&gt;这是一个邪恶的H1&lt;/h1&gt; 使用内联样式 直接在元素上通过 :style 的形式，书写样式对象 1&lt;h1 :style=&quot;&#123;color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;&#125;&quot;&gt;这是一个善良的H1&lt;/h1&gt; 将样式对象，定义到 data 中，并直接引用到 :style 中 在 data 上定义样式： 123data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;h1StyleObj&quot;&gt;这是一个善良的H1&lt;/h1&gt; 在 :style 中通过数组，引用多个 data 上的样式对象 在 data 上定义样式： 1234data: &#123; h1StyleObj: &#123; color: &apos;red&apos;, &apos;font-size&apos;: &apos;40px&apos;, &apos;font-weight&apos;: &apos;200&apos; &#125;, h1StyleObj2: &#123; fontStyle: &apos;italic&apos; &#125;&#125; 在元素中，通过属性绑定的形式，将样式对象应用到元素中： 1&lt;h1 :style=&quot;[h1StyleObj, h1StyleObj2]&quot;&gt;这是一个善良的H1&lt;/h1&gt; Vue 指令之v-for和key属性 迭代数组 123&lt;ul&gt; &lt;li v-for=&quot;(item, i) in list&quot;&gt;索引：&#123;&#123;i&#125;&#125; --- 姓名：&#123;&#123;item.name&#125;&#125; --- 年龄：&#123;&#123;item.age&#125;&#125;&lt;/li&gt;&lt;/ul&gt; 迭代对象中的属性 123&lt;!-- 循环遍历对象身上的属性 --&gt; &lt;div v-for=&quot;(val, key, i) in userInfo&quot;&gt;&#123;&#123;val&#125;&#125; --- &#123;&#123;key&#125;&#125; --- &#123;&#123;i&#125;&#125;&lt;/div&gt; 迭代数字 1&lt;p v-for=&quot;i in 10&quot;&gt;这是第 &#123;&#123;i&#125;&#125; 个P标签&lt;/p&gt; 2.2.0+ 的版本里，当在组件中使用 v-for 时，key 现在是必须的。 当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，Vue 将不是移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。 为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。 Vue 指令之v-if和v-show 一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。 品牌管理案例添加新品牌删除品牌根据条件筛选品牌 1.x 版本中的 filterBy 指令，在 2.x 中已经被废除： filterBy - 指令 123456789101112131415&lt;tr v-for=&quot;item in list | filterBy searchName in &apos;name&apos;&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt; 在 2.x 版本中手动实现筛选的方式： 筛选框绑定到 VM 实例中的 searchName 属性： 123&lt;hr&gt; 输入筛选名称：&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot;&gt; 在使用 v-for 指令循环每一行数据的时候，不再直接 item in list，而是 in 一个 过滤的 methods 方法，同时，把过滤条件searchName传递进去： 12345678910111213141516171819&lt;tbody&gt; &lt;tr v-for=&quot;item in search(searchName)&quot;&gt; &lt;td&gt;&#123;&#123;item.id&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.name&#125;&#125;&lt;/td&gt; &lt;td&gt;&#123;&#123;item.ctime&#125;&#125;&lt;/td&gt; &lt;td&gt; &lt;a href=&quot;#&quot; @click.prevent=&quot;del(item.id)&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; search 过滤方法中，使用 数组的 filter 方法进行过滤： 123456789search(name) &#123; return this.list.filter(x =&gt; &#123; return x.name.indexOf(name) != -1; &#125;);&#125; Vue 调试工具vue-devtools的安装步骤和使用Vue.js devtools - 翻墙安装方式 - 推荐 过滤器概念：Vue.js 允许你自定义过滤器，可被用作一些常见的文本格式化。过滤器可以用在两个地方：mustache 插值和 v-bind 表达式。过滤器应该被添加在 JavaScript 表达式的尾部，由“管道”符指示； 私有过滤器 HTML 元素： 1&lt;td&gt;&#123;&#123;item.ctime | dataFormat(&apos;yyyy-mm-dd&apos;)&#125;&#125;&lt;/td&gt; 私有 filters 定义方式： 12345678910111213141516171819202122232425262728293031323334353637383940414243filters: &#123; // 私有局部过滤器，只能在 当前 VM 对象所控制的 View 区域进行使用 dataFormat(input, pattern = &quot;&quot;) &#123; // 在参数列表中 通过 pattern=&quot;&quot; 来指定形参默认值，防止报错 var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125; &#125; &#125; 使用 ES6 中的字符串新方法 String.prototype.padStart(maxLength, fillString=’’) 或 String.prototype.padEnd(maxLength, fillString=’’)来填充字符串； 全局过滤器1234567891011121314151617181920212223242526272829303132333435363738394041// 定义一个全局过滤器Vue.filter(&apos;dataFormat&apos;, function (input, pattern = &apos;&apos;) &#123; var dt = new Date(input); // 获取年月日 var y = dt.getFullYear(); var m = (dt.getMonth() + 1).toString().padStart(2, &apos;0&apos;); var d = dt.getDate().toString().padStart(2, &apos;0&apos;); // 如果 传递进来的字符串类型，转为小写之后，等于 yyyy-mm-dd，那么就返回 年-月-日 // 否则，就返回 年-月-日 时：分：秒 if (pattern.toLowerCase() === &apos;yyyy-mm-dd&apos;) &#123; return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125;`; &#125; else &#123; // 获取时分秒 var hh = dt.getHours().toString().padStart(2, &apos;0&apos;); var mm = dt.getMinutes().toString().padStart(2, &apos;0&apos;); var ss = dt.getSeconds().toString().padStart(2, &apos;0&apos;); return `$&#123;y&#125;-$&#123;m&#125;-$&#123;d&#125; $&#123;hh&#125;:$&#123;mm&#125;:$&#123;ss&#125;`; &#125;&#125;); 注意：当有局部和全局两个名称相同的过滤器时候，会以就近原则进行调用，即：局部过滤器优先于全局过滤器被调用！ 键盘修饰符以及自定义键盘修饰符1.x 中自定义键盘修饰符【了解即可】1Vue.directive(&apos;on&apos;).keyCodes.f2 = 113; 2.x 中自定义键盘修饰符 通过Vue.config.keyCodes.名称 = 按键值来自定义案件修饰符的别名： 1Vue.config.keyCodes.f2 = 113; 使用自定义的按键修饰符： 1&lt;input type=&quot;text&quot; v-model=&quot;name&quot; @keyup.f2=&quot;add&quot;&gt; 自定义指令 自定义全局和局部的 自定义指令： 1234567891011121314151617181920212223242526272829303132333435// 自定义全局指令 v-focus，为绑定的元素自动获取焦点：Vue.directive(&apos;focus&apos;, &#123; inserted: function (el) &#123; // inserted 表示被绑定元素插入父节点时调用 el.focus(); &#125;&#125;);// 自定义局部指令 v-color 和 v-font-weight，为绑定的元素设置指定的字体颜色 和 字体粗细： directives: &#123; color: &#123; // 为元素设置指定的字体颜色 bind(el, binding) &#123; el.style.color = binding.value; &#125; &#125;, &apos;font-weight&apos;: function (el, binding2) &#123; // 自定义指令的简写形式，等同于定义了 bind 和 update 两个钩子函数 el.style.fontWeight = binding2.value; &#125; &#125; 自定义指令的使用方式： 1&lt;input type=&quot;text&quot; v-model=&quot;searchName&quot; v-focus v-color=&quot;&apos;red&apos;&quot; v-font-weight=&quot;900&quot;&gt; Vue 1.x 中 自定义元素指令【已废弃,了解即可】12345Vue.elementDirective(&apos;red-color&apos;, &#123; bind: function () &#123; this.el.style.color = &apos;red&apos;; &#125;&#125;); 使用方式： 1&lt;red-color&gt;1232&lt;/red-color&gt; 相关文章 vue.js 1.x 文档 vue.js 2.x 文档 String.prototype.padStart(maxLength, fillString) js 里面的键盘事件对应的键码 Vue.js 双向绑定的实现原理]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 多人社区登录注册案例]]></title>
    <url>%2F2018%2F10%2F06%2Fnode-blog%2F</url>
    <content type="text"><![CDATA[案例效果 项目地址node-blog 一、目录结构 app.js 入口 controllers models 数据模型存储(数据库) user.js 数据库主体 node_modules 第三方包 package.json 包描述文件 package-lock.json 第三方包版本锁定文件（npm 5 以后才有） public 公共静态资源 README.md 项目说明文件 routes 路由业务分类（如果业务比较多，代码量大，最好把路由按照业务分类存储） 未使用路由库 单独使用 router.js 简单一点把所有大路由都放在里面 页面（views 视觉存储目录） 主页 index.html 登陆页 login.html 注册页 register.html _partials 固定页面的存放 固定底部 footer.html 固定导航栏 settings-nav.html 固定头部 header.htms _layouts 模板页存放 模板布局 home.htmls settings 个人设置存放 修改密码 admin.html 个人简介 profile.html topic 博客创建与显示 创建博客 new.html 显示博客 show.html 二、模板页面 art-template 子模板 art-template 模板继承 三、路由设计 路径 方法 get 参数 post 参数 是否需要登陆权限 备注 / GET 渲染首页 /register GET 渲染注册页面 /register POST email、nickname、password 处理注册请求 /login GET 渲染登录页面 /login POST email、password 处理登录请求 /logout GET 处理退出请求 四、模型设计五、功能实现六、书写步骤 创建目录结构 整合静态页面-模板页 include block extend 设计用户登录、退出、注册的路由 用户注册 先处理好客户页面的内容（表单控件的 name、收集表单数据、发起请求） 服务端 获取客户端表单请求的数据 操作数据库 如果有错，发送 500 告诉客户端服务错了 其他的根据你的业务发送不同的响应数据 用户登录 用户退出 补充配置中间件 错误处理 七、插件安装使用 模块 express 前端 web 模块 path 路径核心模块 art-template 模版引擎（express-art-template 的依赖所以必须安装） express-art-template 模版引擎 (视觉效果模板 子模板 模板继承) body-parser 中间件(解析表单 post 请求体) mongoose 数据库链接 bootstrap css 页面开发场景 jquery js 框架 blueimp-md5 密码加密 npm install express-session 模块安装与应用express 前端开发框架 安装 12$ npm init -y //添加json初始化文件$ npm install express --save//安装express 引包 1const express = require('express'); 创建服务 1const app = express(); 使用 123app.get('/', function (req, res) &#123; req.send('index.html')&#125;) art-template 模版引擎 (配置在 express 中)js 使用 安装 12$ npm install --save art-template//express-art-templat依赖了art-template所以可以不用记载但是要安装$ npm install --save express-art-template 配置 1app.engine('art',require('express-art-template'))//art 可以替换成其他的标示 html 等 使用 1234567app.get('/',function (req,res) &#123; // 在 Express 中使用模板引擎有更好的方式：res.render('文件名， &#123;模板对象&#125;) // 可以自己尝试去看 art-template 官方文档：如何让 art-template 结合 Express 来使用 res.render('index.html',&#123; title: 'hello world' &#125;);&#125;); 如果希望修改默认的 views 视图渲染存储目录， 可以如下修改 12// 第一个参数 views 不能写错app.set('views', 目录路径) 视图页面输出 views 安装模版引擎 art-template express-art-template 编写布局页面 layout.html 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel="stylesheet" href="/node_modules/bootstrap/dist/css/bootstrap.css"&gt; &lt;!-- 留坑给页面添加css样式等链接 --&gt; &#123;&#123; block 'head' &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/head&gt;&lt;body&gt; &lt;!-- body-固定头部-头部重用 --&gt; &#123;&#123; include './header.html' &#125;&#125; &lt;!-- body-内容模块-可修改 --&gt; &#123;&#123; block 'content' &#125;&#125; &lt;h1&gt;默认内容&lt;/h1&gt; &#123;&#123; /block &#125;&#125; &lt;!-- body-固定底部-底部重用 --&gt; &#123;&#123; include './footer.html' &#125;&#125;&lt;/body&gt;&lt;script src="../node_modules/jquery/dist/jquery.js"&gt;&lt;/script&gt;&lt;script src="../node_modules/bootstrap/dist/js/bootstrap.js"&gt;&lt;/script&gt;&lt;!-- 留坑给页面添加js等 --&gt;&#123;&#123; block 'script' &#125;&#125;&#123;&#123; /block &#125;&#125;&lt;/html&gt; 调用布局模块 编写页面 12345678910111213141516171819202122232425262728&lt;!-- 继承布局模块页 --&gt;&#123;&#123;extend './layout.html'&#125;&#125;&lt;!-- 添加css样式-通过坑 head --&gt;&#123;&#123;block 'head'&#125;&#125;&lt;style&gt; body &#123; background-color: skyblue; &#125; h1 &#123; color: red; &#125;&lt;/style&gt;&#123;&#123;/block&#125;&#125;&lt;!-- 修改页面内容 --&gt;&#123;&#123;block 'content'&#125;&#125;&lt;div&gt; &lt;h1&gt;index.html填坑&lt;/h1&gt;&lt;/div&gt;&#123;&#123;/block&#125;&#125;&lt;!-- 添加js 通过script --&gt;&#123;&#123;block 'script'&#125;&#125;&lt;script&gt; window.alert('index 页面自己的js 脚本')&lt;/script&gt;&#123;&#123;/block&#125;&#125; 留坑内容 中带‘’号的内容的自定义的名，最好是取一看就明白的 坑不止可以留一个，可以留很多个 body-parser 中间件(解析表单 post 请求体) 安装 1$ npm install --save body-parser 引包 1const bodyParser = require('body-parser'); 配置 1234// parse application/x-www-form-urlencoded 解析applicationapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));// parse application/json 解析app.use(bodyParser.json()); 使用 12345678910app.post('/post',function (req,res) &#123; var myDate = new Date(); var year = myDate.getFullYear(); //获取完整的年份(4位,1970-????) var month = myDate.getMonth() + 1; //获取当前月份(0-11,0代表1月) var date = myDate.getDate(); //获取当前日(1-31) let comment = req.body; comment.dateTime = year + "-" + month + "-" + date; comments.unshift(comment); res.redirect('/');&#125;) mongoose （mongodb 数据库链接插件） 安装 1$ npm i -S mongoose 引包 1const mongoose = require('mongoose'); 配置 12// 连接数据库mongoose.connect('mongodb://localhost/test'); 使用 1234567891011121314// 创建一个模型// 就是在设计数据库// MongoDB 是动态的，非常灵活，只需要在代码中设计你的数据库就可以了// mongoose 这个包就可以让你的设计编写过程变的非常的简单const Cat = mongoose.model('Cat', &#123; name: String&#125;);// 实例化一个 catconst kitty = new Cat(&#123; name: 'yhf'&#125;);// 持久化保存 kitty 实例kitty.save().then(() =&gt; console.log('meow')); bootstrap css 样式前端架构 安装 （3 版居多） 1$ npm install bootstrap@3 使用 （在视图的布局页面引入就好）css： js： jquery js 框架 安装 1$ npm i jquery 使用 (在视图的布局页面引入就好) blueimp-md5 密码加密 安装 1$ npm install blueimp-md5 引包 1const md5 = require('blueimp-md5'); 调用 12// md() 在里面填充数据就好 多加几个是多重加密，三个为三重加密body.password = md5(md5(md5(body.password))) express-session 数据存储 安装 1$ npm install express-session 配置 12345678910111213141516171819// 引包const session = require('express-session')// 在 Express 这个框架中，默认不支持 Session 和 Cookie// 但是我们可以使用第三方中间件：express-session 来解决// 1. npm install express-session// 2. 配置 (一定要在 app.use(router) 之前)// 3. 使用// 当把这个插件配置好之后，我们就可以通过 req.session 来发访问和设置 Session 成员了// 添加 Session 数据：req.session.foo = 'bar'// 访问 Session 数据：req.session.fooapp.use(session(&#123; // 配置加密字符串，它会在原有加密基础之上和这个字符串拼起来去加密 // 目的是为了增加安全性，防止客户端恶意伪造 secret: 'itcast', resave: false, saveUninitialized: false // 无论你是否使用 Session ，我都默认直接给你分配一把钥匙&#125;)) 使用 12345// 用户存在，登录成功，通过 Session 记录登录状态req.session.user = user;// 用户退出，退出成功，通过 Session 清除登录状态req.session.user = null;]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 案例2]]></title>
    <url>%2F2018%2F10%2F04%2F2018-10-04%2F</url>
    <content type="text"><![CDATA[nodejs小案例 YHF管理系统 升级优化 实现增删改查 模块化 YHF管理系统效果图 起步 初始化 模板处理 案例说明 路由设计 请求方法 请求路径 get 参数 post 参数 备注 GET /yhf 渲染首页 GET /yhf/new 渲染添加系统成员页面 POST /yhf/new name、age、gender、hobbies、admin 处理添加系统成员请求 GET /yhf/edit _id 渲染编辑页面 POST /yhf/edit id、name、age、gender、hobbies、admin 处理编辑请求 GET /yhf/delete _id 处理删除请求 案例说明 1.页面的数据 用 mongdb 装数据 挂载路由 app.get app.post 路由 app.listen 开启服务端口 node_modules \ public 页面数据共享 2.页面显示 router.js 和 students.js 控制路由与业务逻辑(模块化) Express 为 Response 相应对象提供了一个方法：render render 方法默认是不可以使用，但是如果配置了模板引擎就可以使用了 res.render(‘html模板名’, {模板数据}) 第一个参数不能写路径，默认会去项目中的 views 目录查找该模板文件 也就是说 Express 有一个约定：开发人员把所有的视图文件都放到 views 目录中 express 模版引擎 express-art-template使用 res.render(‘文件名， {模板对象}) 3.数据传输 body-parser 中间件 解析表单 POST 请求体 req.body 得到数据 4.使用的外部插件 mongoose express express-art-template body-parse 5.项目地址 项目地址 6.开发配置 mac os 10.13.3 npm 6.4.1 node 10.10.0 Bootstrap v3 7.案例功能 添加成员 更新成员信息 删除成员 查看成员 7.案例查看/使用 sudo git clone https://github.com/YHF7/Node.git cd mypro/nodejs2/glxt node app.js 插件安装配置express 前端开发框架1.安装12npm init -y //添加json初始化文件npm install express --save//安装express 2.引包1const express = require('express'); 3.创建服务1const app = express(); 4.使用123app.get('/', function (req, res) &#123; req.send('index.html')&#125;) art-template 模版引擎 (配置在express中)安装使用1.安装12npm install --save art-template//express-art-templat依赖了art-template所以可以不用记载但是要安装npm install --save express-art-template 2.配置1app.engine('art',require('express-art-template'))//art 可以替换成其他的标示 html 等 3.使用1234567app.get('/',function (req,res) &#123; // 在 Express 中使用模板引擎有更好的方式：res.render('文件名， &#123;模板对象&#125;) // 可以自己尝试去看 art-template 官方文档：如何让 art-template 结合 Express 来使用 res.render('index.html',&#123; title: 'hello world' &#125;);&#125;); 4.如果希望修改默认的 views 视图渲染存储目录， 可以如下修改12// 第一个参数 views 不能写错app.set('views', 目录路径) body-parser 中间件(解析表单 post 请求体)1.安装1npm install --save body-parse 2.引包1const bodyParser = require('body-parser); 3.配置1234// parse application/x-www-form-urlencoded 解析applicationapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));// parse application/json 解析app.use(bodyParser.json()); 4.使用12345678910app.post('/post',function (req,res) &#123; var myDate = new Date(); var year = myDate.getFullYear(); //获取完整的年份(4位,1970-????) var month = myDate.getMonth() + 1; //获取当前月份(0-11,0代表1月) var date = myDate.getDate(); //获取当前日(1-31) let comment = req.body; comment.dateTime = year + "-" + month + "-" + date; comments.unshift(comment); res.redirect('/');&#125;) mongoose （mongodb数据库链接插件）1.安装1npm i -S mongoose 2.引包1const mongoose = require('mongoose'); 3.配置// 连接数据库1mongoose.connect('mongodb://localhost/test'); // 创建一个模型// 就是在设计数据库// MongoDB 是动态的，非常灵活，只需要在代码中设计你的数据库就可以了// mongoose 这个包就可以让你的设计编写过程变的非常的简单4.使用12345678910const Cat = mongoose.model('Cat', &#123; name: String&#125;);// 实例化一个 catconst kitty = new Cat(&#123; name: 'yhf'&#125;);// 持久化保存 kitty 实例kitty.save().then(() =&gt; console.log('meow')); 数据库安装开启安装1sudo brew install mongodb 开启1sudo mongod 链接(默认链接本地服务)1mongo 退出1exit 基本命令:1234561. show dbs 查看显示所以数据库2. db 查看当前链接打数据库3. use 数据库名称 切换到指定打数据库（如果没有会新建）4. 插入数据5. show collections 查看数据集合 6. db.students.find() 查看库中所以的数据]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs 案例1]]></title>
    <url>%2F2018%2F10%2F02%2F2018-10-02%2F</url>
    <content type="text"><![CDATA[nodejs小案例 留言页 实现添加数据 学生管理系统 实现增删改查 模块化 留言页效果图 案例说明 1.页面的数据 未链接数据库所以，用comments数组代替 app.get app.post 路由 app.listen 开启服务端口 2.页面显示 Express 为 Response 相应对象提供了一个方法：render render 方法默认是不可以使用，但是如果配置了模板引擎就可以使用了 res.render(‘html模板名’, {模板数据}) 第一个参数不能写路径，默认会去项目中的 views 目录查找该模板文件 也就是说 Express 有一个约定：开发人员把所有的视图文件都放到 views 目录中 express 模版引擎 express-art-template使用 res.render(‘文件名， {模板对象}) 3.数据传输 body-parser 中间件 解析表单 POST 请求体 req.body 得到数据 4.使用的外部插件 express express-art-template body-parse 5.项目地址 项目地址 6.开发配置 mac os 10.13.3 npm 6.4.1 node 10.10.0 Bootstrap v3 7.案例查看/使用 sudo git clone https://github.com/YHF7/Node.git cd mypro/nodejs2/feedback-express/ node app.js 8.具体功能 增加数据 查看数据 学生管理系统效果图 起步 初始化 模板处理 案例说明 路由设计 请求方法 请求路径 get 参数 post 参数 备注 GET /studens 渲染首页 GET /students/new 渲染添加学生页面 POST /studens/new name、age、gender、hobbies 处理添加学生请求 GET /students/edit id 渲染编辑页面 POST /studens/edit id、name、age、gender、hobbies 处理编辑请求 GET /students/delete id 处理删除请求 案例说明 1.页面的数据 用 db.json 装数据 挂载路由 app.get app.post 路由 app.listen 开启服务端口 node_modules \ public 页面数据共享 2.页面显示 router.js 和 students.js 控制路由与业务逻辑(模块化) Express 为 Response 相应对象提供了一个方法：render render 方法默认是不可以使用，但是如果配置了模板引擎就可以使用了 res.render(‘html模板名’, {模板数据}) 第一个参数不能写路径，默认会去项目中的 views 目录查找该模板文件 也就是说 Express 有一个约定：开发人员把所有的视图文件都放到 views 目录中 express 模版引擎 express-art-template使用 res.render(‘文件名， {模板对象}) 3.数据传输 body-parser 中间件 解析表单 POST 请求体 req.body 得到数据 4.使用的外部插件 express express-art-template body-parse 5.项目地址 项目地址 6.开发配置 mac os 10.13.3 npm 6.4.1 node 10.10.0 Bootstrap v3 7.案例查看/使用 sudo git clone https://github.com/YHF7/Node.git cd mypro/nodejs2/crud-express/ node app.js 8.具体功能 增加数据 修改数据 查看数据 删除数据 插件安装配置express 前端开发框架1.安装12npm init -y //添加json初始化文件npm install express --save//安装express 2.引包1const express = require('express'); 3.创建服务1const app = express(); 4.使用123app.get('/', function (req, res) &#123; req.send('index.html')&#125;) art-template 模版引擎 (配置在express中)安装使用1.安装12npm install --save art-template//express-art-templat依赖了art-template所以可以不用记载但是要安装npm install --save express-art-template 2.配置1app.engine('art',require('express-art-template'))//art 可以替换成其他的标示 html 等 3.使用1234567app.get('/',function (req,res) &#123; // 在 Express 中使用模板引擎有更好的方式：res.render('文件名， &#123;模板对象&#125;) // 可以自己尝试去看 art-template 官方文档：如何让 art-template 结合 Express 来使用 res.render('index.html',&#123; title: 'hello world' &#125;);&#125;); 4.如果希望修改默认的 views 视图渲染存储目录， 可以如下修改12// 第一个参数 views 不能写错app.set('views', 目录路径) body-parser 中间件(解析表单 post 请求体)1.安装1npm install --save body-parse 2.引包1const bodyParser = require('body-parser); 3.配置1234// parse application/x-www-form-urlencoded 解析applicationapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));// parse application/json 解析app.use(bodyParser.json()); 4.使用12345678910app.post('/post',function (req,res) &#123; var myDate = new Date(); var year = myDate.getFullYear(); //获取完整的年份(4位,1970-????) var month = myDate.getMonth() + 1; //获取当前月份(0-11,0代表1月) var date = myDate.getDate(); //获取当前日(1-31) let comment = req.body; comment.dateTime = year + "-" + month + "-" + date; comments.unshift(comment); res.redirect('/');&#125;)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs第二套 笔记]]></title>
    <url>%2F2018%2F09%2F29%2Fnodejs2%2F</url>
    <content type="text"><![CDATA[一、day1总结 Node.js 是什么 JavaScript 运行时 既不是语言，也不是框架，它是一个平台 Node.js 中的 JavaScript 没有 BOM、DOM EcmaScript 基本的 JavaScript 语言部分 在 Node 中为 JavaScript 提供了一些服务器级别的 API 文件操作的能力 http 服务的能力 Node 中的 JavaScript EcmaScript 变量 方法 数据类型 内置对象 Array Object Date Math 模块系统 在 Node 中没有全局作用域的概念 在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件 require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题 模块完全是封闭的 外部无法访问内部 内部也无法访问外部 模块作用域固然带来了一些好处，可以加载执行多个文件，可以完全避免变量命名冲突污染的问题 但是某些情况下，模块与模块是需要进行通信的 在每个模块中，都提供了一个对象：exports 该对象默认是一个空对象 你要做的就是把需要被外部访问使用的成员手动的挂载到 exports 接口对象中 然后谁来 require 这个模块，谁就可以得到模块内部的 exports 接口对象 还有其它的一些规则，具体后面讲，以及如何在项目中去使用这种编程方式，会通过后面的案例来处理 核心模块 核心模块是由 Node 提供的一个个的具名的模块，它们都有自己特殊的名称标识，例如 fs 文件操作模块 http 网络服务构建模块 os 操作系统信息模块 path 路径处理模块 。。。。 所有核心模块在使用的时候都必须手动的先使用 require 方法来加载，然后才可以使用，例如： var fs = require(&#39;fs&#39;) http require 端口号 ip 地址定位计算机 端口号定位具体的应用程序 Content-Type 服务器最好把每次响应的数据是什么内容类型都告诉客户端，而且要正确的告诉 不同的资源对应的 Content-Type 是不一样，具体参照：http://tool.oschina.net/commons 对于文本类型的数据，最好都加上编码，目的是为了防止中文解析乱码问题 通过网络发送文件 发送的并不是文件，本质上来讲发送是文件的内容 当浏览器收到服务器响应内容之后，就会根据你的 Content-Type 进行对应的解析处理 模块系统 Node 中的其它的核心模块 做一个小管理系统： CRUD Express Web 开发框架 npm install express 二、day2代码风格12345678910111213141516var foo = 'bar'var foo ='bar'var foo= 'bar'var foo = "bar"if (true) &#123; console.log('hello') &#125;if (true) &#123; console.log('hello') &#125;if (true )&#123; console.log('hello') &#125; 为了约定大家的代码风格，所以在社区中诞生了一些比较规范的代码风格规范：dnsajkndkjsabnjkdnjksandjknsajkdnjkasnjkdnjksandjknsajkdnjksajkdnas JavaScript Standard Style Airbnb JavaScript Style 总结 代码风格 无分号 ( [ ` 最好前面补分号，避免一些问题 《编写可维护的 JavaScript》 不仅是功能，还要写的漂亮 服务端渲染 说白了就是在服务端使用模板引擎 模板引擎最早诞生于服务端，后来才发展到了前端 服务端渲染和客户端渲染的区别 客户端渲染不利于 SEO 搜索引擎优化 服务端渲染是可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的 所以你会发现真正的网站既不是纯异步也不是纯服务端渲染出来的 而是两者结合来做的 例如京东的商品列表就采用的是服务端渲染，目的了为了 SEO 搜索引擎优化 而它的商品评论列表为了用户体验，而且也不需要 SEO 优化，所以采用是客户端渲染 三、day3知识点 增删改查 登陆 注册 头像 服务端图片 水印 图片水印 找回密码 密码修改 模块系统 核心模块 第三方模块 自己写的模块 加载规则以及加载机制 循环加载 npm package.json Express 第三方 Web 开发框架 高度封装了 http 模块 更加专注于业务，而非底层细节 知其所以然 增删改查 使用文件来保存数据（锻炼异步编码） MongoDB （所有方法都封装好了） 复习 网站开发模型 黑盒子、哑巴 写代码让它变得更智能 按照你设计好的套路供用户使用 在 Node 中使用 art-template 模板引擎 安装 加载 template.render() 客户端渲染和服务端渲染的区别 最少两次请求，发起 ajax 在客户端使用模板引擎渲染 客户端拿到的就是服务端已经渲染好的 处理留言本案例首页数据列表渲染展示 处理留言本案例发表留言功能 路径 设计好的请求路径 $GET 直接或查询字符串数据 Node 中需要咱们自己动手来解析 url.parse() /pinglun?name=jack&amp;message=hello split(‘?’) name=jack&amp;message=hello split(‘&amp;’) name=jack message=hello forEach() name=jack.split(‘=’) 0 key 1 value 掌握如何解析请求路径中的查询字符串 url.parse() 如何在 Node 中实现服务器重定向 header(‘location’) 301 永久重定向 浏览器会记住 a.com b.com a 浏览器不会请求 a 了 直接去跳到 b 了 302 临时重定向 浏览器不记忆 a.com b.com a.com 还会请求 a a 告诉浏览器你往 b Node 中的 Console（REPL）使用 上午总结 jQuery 的 each 和 原生的 JavaScript 方法 forEach EcmaScript 5 提供的 不兼容 IE 8 jQuery 的 each 由 jQuery 这个第三方库提供 jQuery 2 以下的版本是兼容 IE 8 的 它的 each 方法主要用来遍历 jQuery 实例对象（伪数组） 同时它也可以作为低版本浏览器中 forEach 替代品 jQuery 的实例对象不能使用 forEach 方法，如果想要使用必须转为数组才可以使用 [].slice.call(jQuery实例对象) 模块中导出多个成员和导出单个成员 301 和 302 状态码区别 301 永久重定向，浏览器会记住 302 临时重定向 exports 和 module.exports 的区别 每个模块中都有一个 module 对象 module 对象中有一个 exports 对象 我们可以把需要导出的成员都挂载到 module.exports 接口对象中 也就是：moudle.exports.xxx = xxx 的方式 但是每次都 moudle.exports.xxx = xxx 很麻烦，点儿的太多了 所以 Node 为了你方便，同时在每一个模块中都提供了一个成员叫：exports exports === module.exports 结果为 trues 所以对于：moudle.exports.xxx = xxx 的方式 完全可以：expots.xxx = xxx 当一个模块需要导出单个成员的时候，这个时候必须使用：module.exports = xxx 的方式 不要使用 exports = xxx 不管用 因为每个模块最终向外 return 的是 module.exports 而 exports 只是 module.exports 的一个引用 所以即便你为 exports = xx 重新赋值，也不会影响 module.exports 但是有一种赋值方式比较特殊：exports = module.exports 这个用来重新建立引用关系的 之所以让大家明白这个道理，是希望可以更灵活的去用它 Node 是一个比肩 Java、PHP 的一个平台 JavaScript 既能写前端也能写服务端 12345678moudle.exports = &#123; a: 123&#125;// 重新建立 exports 和 module.exports 之间的引用关系exports = module.exportsexports.foo = 'bar' 12345678910111213141516171819202122232425262728Array.prototype.mySlice = function () &#123; var start = 0 var end = this.length if (arguments.length === 1) &#123; start = arguments[0] &#125; else if (arguments.length === 2) &#123; start = arguments[0] end = arguments[1] &#125; var tmp = [] for (var i = start; i &lt; end; i++) &#123; // fakeArr[0] // fakeArr[1] // fakeArr[2] tmp.push(this[i]) &#125; return tmp&#125;var fakeArr = &#123; 0: 'abc', 1: 'efg', 2: 'haha', length: 3&#125;// 所以你就得到了真正的数组。 [].mySlice.call(fakeArr) 下午总结 jQuery 的 each 和 原生的 JavaScript 方法 forEach 301 和 302 的区别 模块中导出单个成员和导出多个成员的方式 module.exports 和 exports 的区别 require 方法加载规则 优先从缓存加载 核心模块 路径形式的模块 第三方模块 node_modules package.json 包描述文件 dependencies 选项的作用 npm 常用命令 Express 基本使用 使用 Express 把之前的留言本案例自己动手改造一下 四、day4知识点 Express 基于文件做一套 CRUD 复习 jQuery 的 each 和 原生的 JavaScript 方法 forEach 301 和 302 的区别 模块中导出单个成员和导出多个成员的方式 module.exports = xxx 通过多次：exports.xxx = xxx 导出多个也可以：moudle.exports = {多个成员} module.exports 和 exports 的区别 exports 只是 module.exports 的一个引用而已，目的只是为了简化写法 每个模块最终 return 的是 module.exports require 方法加载规则 优先从缓存加载 核心模块 路径形式的模块 ./xxx ../xxxx /xxxx / 在这里表示的是磁盘根路径 c:/xxx 第三方模块 第三方模块的标识就是第三方模块的名称（不可能有第三方模块和核心模块的名字一致） npm 开发人员可以把写好的框架、库发布到 npm 上 使用者在使用的时候就可以很方便的通过 npm 来下载 使用方式：var 名字 = require(&#39;npm install 的那个包名&#39;) node_modules node_modules/express node_modules/express/package.json node_modules/express/package.json main 如果 package.json 或者 package.json main 不成立，则查找备选项：index.js 如果以上条件都不成立，则继续进入上一级目录中的 node_modules 按照上面的规则继续查找 如果直到当前文件模块所属磁盘根目录都找不到，最后报错：can not find module xxx package.json 包描述文件 就是产品的说明书 dependencies 属性，用来保存项目的第三方包依赖项信息 所以建议每个项目都要有且只有一个 package.json (存放在项目的根目录) 我们可以通过 npm init [--yes] 来生成 package.json 文件 同样的，为了保存依赖项信息，我们每次安装第三方包的时候都要加上：--save 选项。 npm 常用命令 install uninstall Express 基本使用 使用 Express 把之前的留言本案例自己动手改造一下 模块标识中的 / 和文件操作路径中的 /上午总结演讲 说服PPT脑图markdown结构思维 找痛点 why 为什么 解决方案 what 是什么 怎么去使用 how 怎么用 where 在哪儿用 when 什么时候用 文件路径中的 / 和模块标识中的 / nodemon Express art-template 模板引擎的配置 body-parser 解析表单 POST 请求体 技术只是一种解决问题的手段、工具而已 第三方的东西，不要纠结 先以解决问题为主 详解了 express 静态服务 API app.use(‘/public/‘, express.static(‘./public’)) crud 下午总结目标 文件路径中的 / 和模块标识中的 / Express 中配置使用 art-template 模板引擎 Express 中配置使用 body-parser Express 中配置处理静态资源 CRUD 案例中单独提取路由模块 五、day5知识点 Express MongoDB 项目 一天半的时间 复习 文件路径中的 / 和模块标识中的 / Express 中配置使用 art-template 模板引擎 Express 中配置使用 body-parser Express 中配置处理静态资源 CRUD 案例中单独提取路由模块 上午总结 回调函数 异步编程 如果需要得到一个函数内部异步操作的结果，这是时候必须通过回调函数来获取 在调用的位置传递一个函数进来 在封装的函数内部调用传递进来的函数 find、findIndex、forEach 数组的遍历方法，都是对函数作为参数一种运用 every some includes map reduce package-lock.json 文件的作用 下载速度快了 锁定版本 JavaScript 模块化 Node 中的 CommonJS 浏览器中的 AMD require.js CMD sea.js EcmaScript 官方在 EcmaScript 6 中增加了官方支持 EcmaScript 6 后面我们会学，编译工具 MongoDB 数据库 MongoDB 的数据存储结构 数据库 集合（表） 文档（表记录） MongoDB 官方有一个 mongodb 的包可以用来操作 MongoDB 数据库 这个确实和强大，但是比较原始，麻烦，所以咱们不使用它 mongoose 真正在公司进行开发，使用的是 mongoose 这个第三方包 它是基于 MongoDB 官方的 mongodb 包进一步做了封装 可以提高开发效率 让你操作 MongoDB 数据库更方便 掌握使用 mongoose 对数据集合进行基本的 CRUD 把之前的 crud 案例改为了 MongoDB 数据库版本 使用 Node 操作 mysql 数据库 六、day6Node.js 第6天课堂笔记知识点 多人社区案例 复习 MongoDB 数据库 灵活 不用设计数据表 业务的改动不需要关心数据表结构 DBA 架构师 级别的工程师都需要掌握这项技能 设计 维护 分布式计算 mongoose mongodb 官方包也可以操作 MongoDB 数据库 第三方包：WordPress 项目开发团队 设计 Schema 发布 Model（得到模型构造函数） 查询 增加 修改 删除 Promise http://es6.ruanyifeng.com/#docs/promise callback hell 回调地狱 回调函数中套了回调函数 Promise(EcmaScript 6 中新增了一个语法 API) 容器 异步任务（pending） resolve reject then 方法获取容器的结果（成功的，失败的） then 方法支持链式调用 可以在 then 方法中返回一个 promise 对象，然后在后面的 then 方法中获取上一个 then 返回的 promise 对象的状态结果 总结 path 模块 dirname 和 filename 动态的 获取当前文件或者文件所处目录的绝对路径 用来解决文件操作路劲的相对路径问题 因为在文件操作中，相对路径相对于执行 node 命令所处的目录 所以为了尽量避免这个问题，都建议文件操作的相对路劲都转为：动态的绝对路径 方式：path.join(__dirname, &#39;文件名&#39;) art-template 模板引擎(include、block、extend) include extend block 表单同步提交和异步提交区别 以前没有 ajax 都是这么干的，甚至有些直接就是渲染了提示信息出来了 异步提交页面不会刷新，交互方式更灵活 Express 中配置使用 express-session 插件 概述案例中注册-登陆-退出的前后端交互实现流程]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs day5]]></title>
    <url>%2F2018%2F09%2F28%2Fnodejs(day5)%2F</url>
    <content type="text"><![CDATA[今日授课内容 Buffer 类型介绍 express 介绍 express 介绍 express 实现 hello world express 脚手架 express 简单路由 express 正则表达式路由 /^\/index(\/.+)?$/ express 处理静态资源 express 中的 res.send() 和 res.end() 区别 res.json()等价于 res.send(json)、res.sendFile()、res.redirect()、res.status(code).end() app.use()、app.get()、app.all()区别 中间件介绍 ejs 模板引擎介绍 一、Buffer思考：Buffer 类型产生的原因？主要用来解决什么问题？ 看一下什么是 Buffer? 什么是 Stream? 一、类型介绍 JavaScript 语言没有读取或操作二进制数据流的机制。 Node.js 中引入了 Buffer 类型使我们可以操作 TCP 流 或 文件流。 Buffer 类型的对象类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。（ buf.length 是固定的，不允许修改 ） Buffer 是全局的，所以使用的时候无需 require() 的方式来加载 二、如何创建一个 Buffer 对象常见的 API 介绍 1. 创建一个 Buffer 对象12345678910111213141516171819202122232425// 1. 通过 Buffer.from() 创建一个 Buffer 对象// 1.1 通过一个字节数组来创建一个 Buffer 对象var array = [ 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c];var buf = Buffer.from(array);console.log(buf.toString("utf8"));// 1.2 通过字符串来创建一个 Buffer 对象// Buffer.from(string[, encoding])var buf = Buffer.from("你好世界！ Hello World!~");console.log(buf);console.log(buf.toString()); 2. 拼接多个 Buffer 对象为一个对象123// Buffer.concat(list[, totalLength])var bufferList = [];var buf = Buffer.concat(bufferList); 3. 获取字符串对应的字节个数1234// Buffer.byteLength(string[, encoding])var len = Buffer.byteLength("你好世界Hello", "utf8");console.log(len); 4. 判断一个对象是否是 Buffer 类型对象1234// Buffer.isBuffer(obj)// obj &lt;Object&gt;// Returns: &lt;boolean&gt;// Returns true if obj is a Buffer, false otherwise. 5. 获取 Buffer 中的某个字节12// 根据索引获取 Buffer 中的某个字节（byte、octet）// buf[index] 6、获取 Buffer 对象中的字节的个数12// buf.length// 注意：length 属性不可修改 7. 已过时的 API123456// 以下 API 已全部过时new Buffer(array)new Buffer(buffer)new Buffer(arrayBuffer[, byteOffset [, length]])new Buffer(size)new Buffer(string[, encoding]) 三、Buffer 对象与编码Node.js 目前支持的编码如下： ascii utf8 utf16le ucs2 是 utf16le 的别名 base64 latin1 binary 是 latin1 的别名 hex 用两位 16 进制来表示每个字节 示例代码： 12345var buf = Buffer.from("你好世界，Hello World！", "utf8");console.log(buf.toString("hex"));console.log(buf.toString("base64"));console.log(buf.toString("utf8")); 四、思考：为什么会有 Buffer 类型？ Buffer 使用来临时存储一些数据（二进制数据） 当我们要把一大块数据从一个地方传输到另外一个地方的时候可以通过 Buffer 对象进行传输 通过 Buffer 每次可以传输小部分数据，直到所有数据都传输完毕。 五、补充 Stream Writable Stream 允许 node.js 写数据到流中 Readable Stream 允许 node.js 从流中读取数据 二、express 介绍 什么是 express ？ 基于 Node.js 平台开发的 “web 开发框架” ，就是一个 node.js 模块 express 的作用：它提供一系列强大的特性，帮助你创建各种 Web 和移动设备应用。 express 同时也是 Node.js 的一个模块 为什么学习 express 框架？ 为了让我们基于 Node.js 开发 web 应用程序更高效。 express 官方网站 http://expressjs.com/ http://www.expressjs.com.cn/ express 网站如何查阅？ 带领同学们一起看一下 express 特点 实现了路由功能 中间件（函数）功能 对 req 和 res 对象的扩展 可以集成其他模板引擎 express 基本使用 安装 express npm 搜索，安装。按照文档一步一步进行 创建 package.json 文件 安装 express 模块：npm install express --save 演示 Hello World 案例 在 express 中，request 对象 和 response 对象一样使用，同时这两个对象还额外添加了其他的好用功能 res.send() 是 res.end()的扩展 步骤总结：1、加载 express 模块2、创建 express 实例（一般叫 app ）3、设计路由4、启动监听服务 补充知识： 路由：请求路径（URL） + 请求方法（post、get、……） http 请求方法介绍：https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods 使用 express 框架模拟 Apache 服务器处理静态资源 主要使用到的方法express.static(&#39;public&#39;) express.static(&#39;public&#39;)的返回值就是一个函数，这个函数的作用就是根据请求，读取静态资源文件并响应给用户 注意：static() 方法参数路径要写 绝对路径，不要写相对路径。相对路径还是相对执行 node 命令的路径 主要使用到的方法 app.use() use()方法的参数 1 表示”虚拟路径”，参数 2 表示要开放的静态资源目录 如何向客户端发送单个静态文件 res.sendFile() 方法 托管静态资源时的两个注意点： 1234567// 问题一(提问、演示)、app.use(express.static("./public"));app.use(express.static("./file"));// 问题二(提问、演示)、app.use("/aaa", express.static("./public"));app.use("/bbb", express.static("./public")); 带同学们看一下 express 文档中关于各种设置路由的方法介绍一下 express 中的中间件 中间件（Middleware） 是一个函数，它可以访问请求对象（request object (req)）, 响应对象（response object (res)）, 和 web 应用中处于请求-响应循环流程中的中间件，一般被命名为 next 的变量。 常规中间件（应用级中间件）的回调函数，一般有 3 个参数 req, res, next 其中 next()是一个函数，通过这个函数把执行流程交给下一个中间件 可以挂在中间件的部分方法 app.use() app.get()、app.post()、app.put()、app.delete()、…等各种请求方法 注意：在挂载中间件时 next() 方法的重要性，不调用该方法无法执行到下一个中间件 中间件的应用场景 利用中间件实现记录日志功能 利用中间件模拟 body-parser 功能 介绍在 express 中如何使用模板引擎 在 express 中, res 对象是具有 redner 方法的，但是需要自己配置一个模板引擎 在 express 中渲染单个文件，使用 res.sendFile res.render()要在设置好模板引擎后再使用 ejs 模板引擎介绍 打开 npm 搜索 ejs 打开 GitHub 的 ejs 地址，查看如何使用 ejs 模板引擎介绍 ejs 使用 ejs.render(str, data, options); 在 express 中配置使用 ejs 模板引擎 npm install ejs –save 通过 app.set(‘views’, ‘路径’); 和 app.set(‘view engine’, ‘模板引擎名称’);来配置模板引擎 配置好后就可以通过 res.render(‘a.ejs’, {})来渲染模板了 express 中的 request 对象的成员：http://www.expressjs.com.cn/4x/api.html#req express 中的 response 对象的成员：http://www.expressjs.com.cn/4x/api.html#res express 中的 ‘中间件’ 含义。模板引擎后缀替换 app.engine(‘.ejs’, require(‘ejs’).renderFile) app.set(‘view engine’, ‘ejs’) 通过使用 express 框架改造 Hacker News 网站 把 resources、views、list.json 拷贝到该目录下，其他暂时不需要了 创建 app.js 创建 package.json 安装 express 提取 router.js 模块 拷贝 handler.js 模块 handler.js 模块中获取 post 提交数据时，可以使用 body-parser 模块实现 npm 安装 body-parser 在 express 中通过 app.use()挂载 body-parser 中间件，实现效果 在 express 中无需 url 模块，直接可以通过 req.query 获取查询字符串对象 三、其他1、ejs 模板引擎 ejs 模板引擎介绍 打开 npm 搜索 ejs 打开 GitHub 的 ejs 地址，查看如何使用 演示 ejs 模板引擎的使用 2、介绍在 express 中如何使用模板引擎 在 express 中, res 对象是具有 redner 方法的，但是需要自己配置一个模板引擎 在 express 中渲染单个文件，使用 res.sendFile res.render()要在设置好模板引擎后再使用 npm install ejs –save 通过 app.set(‘views’, ‘路径’); 和 app.set(‘view engine’, ‘模板引擎名称’);来配置模板引擎 配置好后就可以通过 res.render(‘a.ejs’, {})来渲染模板了 3、模板引擎后缀替换、 设置后缀为 .ejs app.engine(‘.ejs’, require(‘ejs’).renderFile) app.set(‘view engine’, ‘ejs’) 设置后缀为 .html app.engine(‘.html’, require(‘ejs’).renderFile) app.set(‘view engine’, ‘html’) 参考链接：https://cnodejs.org/topic/530318fa5366a72a2c070a5d http://www.cnblogs.com/dubaokun/p/3446206.html http://www.expressjs.com.cn/4x/api.html#app.engine 4、完成 hacker news 网站使用 express 改造 5、body-parser 使用 npm install 在模块中 require(‘body-parser’) 在 express 中配置 12345// parse application/x-www-form-urlencodedapp.use(bodyParser.urlencoded(&#123; extended: false &#125;));// parse application/jsonapp.use(bodyParser.json()); 1. res.send() 方法 - 参数可以是字符串、Buffer对象、数组（json对象）、普通对象 - 通过调用该方法进行响应的时候，会自动添加一些响应头(Content-Type、Content-Length等)]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs day4]]></title>
    <url>%2F2018%2F09%2F27%2Fnodejs(day4)%2F</url>
    <content type="text"><![CDATA[今日授课内容 复习 hackernews 实现 模块化改造 Hacker News 思路(5个模块) 项目地址:https://github.com/YHF7/HeackerNews HackerNews 代码模块化提取模块 app.js 模块 职责 创建并启动 http 服务 context.js 模块 职责 在 http request 事件正式开始前，先为 request 对象 和 response 对象挂载需要的成员 在正式开始处理请求前的准备工作 router.js 模块 职责 判断用户请求路径，根据不同路径调用不同的处理方法 其他 该模块返回一个函数，把req 和 res对象作为该函数的参数 路由一般包含两部分：1、URL路径； 2、请求方法：get 、 post 等 config.js模块 职责：对于可能变化的地方，比如路径，单独配置起来。 服务监听的端口号 viewPath路径 data保存的路径等 config.js模块一般放到项目根目录下，和app.js在同一级目录 handler.js模块 职责：用来封装处理业务逻辑的代码 把router.js模块中对于不同请求的处理代码封装到不同的函数（方法）中 处理不同请求封装成不同的方法]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs day3]]></title>
    <url>%2F2018%2F09%2F26%2Fnodejs(day3)%2F</url>
    <content type="text"><![CDATA[复习 try-catch 捕获异常 根据用户不同请求，读取不同HTML文件并返回（带图片、带CSS） 模拟Apache服务器，处理静态资源请求 用户请求的 url 对于服务器来说就是一个标识 request对象 和 response 对象 npm 安装和使用 modules 和 packages区别 package.json 文件作用 package-lock.json 文件作用 服务器端如何获取用户 get 提交的数据 服务器端如何做重定向操作 “路由” 由哪两部分组成？ 今日课程授课顺序 完成 get 方式添加新闻、post 方式添加新闻 完成新闻列表页渲染 完成新闻详情页渲染 封装读取 data.json 文件代码 封装写入 data.json 文件的代码 封装读取 post 数据的代码 require() 加载模块机制 加载过程 执行原理 node.js 模块化介绍 module、module.exports和exports 通过设置响应报文头让浏览器实现弹框下载功能 网页中的 ./ 和 ../ 等相对路径的含义 相对于请求当前页面的url来计算，根据这个url计算出上一级url或者本级url等 最终浏览器会根据相对url（相对路径）计算出绝对路径然后再请求服务器（向服务器发起请求） Buffer 类型介绍 通过模块化的方式改造 Hacker News 知识点 node.js 模块化介绍 require() 加载模块机制 get 和 post 请求区别 url 模块使用 querystring 模块使用 underscore 模块使用 node.js 中如何获取 get 请求提交的数据 node.js 中如何获取 post 请求提交的数据 module、module.exports、exports 前端资源库 课程总结： 通过 url 模块获取get 提交的数据 通过监听req 对象的 data 事件和 end 事件，配合 querystring模块获取用户 post 提交的数据 underscore 的 template方法使用 require() 加载机制 module、module.exports 和 exports 封装 异步回调的方法 node.js 模块的分类 node.js 模块在 node.js 开发中一个文件就可以认为是一个模块。 一、node.js 模块分类核心模块 Core Module、内置模块、原生模块 fs http path url … 所有内置模块在安装node.js的时候就已经编译成 二进制文件，可以直接加载运行（速度较快）部分内置模块，在 node.exe 这个进程启动的时候就已经默认加载了，所以可以直接使用。 文件模块按文件后缀来分如果加载时，没有指定后缀名，那么就按照如下顺序依次加载相应模块 .js .json .node（C/C++编写的模块） 自定义模块（第三方模块） mime cheerio moment mongo … 二、require 加载模块顺序 看 require() 加载模块时传入的参数是否以 ‘./‘ 或 ‘../‘ 或 ‘/‘ 等等这样的路径方式开头（相对路径或绝对路径都可以） 是，那么会按照传入的路径直接去查询对应的模块。 传入的是否为具体的文件名 require(‘./test.js’) 是具体的文件名 直接根据给定的路径去加载模块，找到了加载成功，找不到加载失败 require(‘./test’); 不是具体的文件名、 第一步：根据给定的路径，依次添加文件后缀 .js、.json、.node进行匹配，如果找不到匹配执行第二步 第二步：查找是否有 test 目录（尝试找 test 包） 找不到：加载失败 找到了：依次在 test 目录下查找 package.json 文件（找到该文件后尝试找 main 字段中的入口文件）、index.js、index.json、index.node，找不到则加载失败 不是，那么就认为传入的是 “模块名称”（比如：require(‘http’)、require(‘mime’)） 是核心模块：直接加载核心模块 不是核心模块 依次递归查找 node_modules 目录中是否有相应的包 从当前目录开始，依次递归查找所有父目录下的 node_modules 目录中是否包含相应的包 如果查找完毕磁盘根目录依然没有则加载失败 打印输入 module.paths 查看 1234567891011121314151617181920// require('http')// require('mime')// 情况一：require() 的参数是一个路径require('./index2.js')// index2.js// index2.json// index2.node// index2 文件夹 -&gt; package.json -&gt; main(入口文件 app.js -&gt; index.js/index.json/index.node) -&gt; 加载失败require('ndex2')// 情况二： require() 的参数不是路径，直接就是一个模块名称// 1. 先在核心模块中查找，是否有和给定的名字一样的模块。如果有，则直接加载该核心模块。// require('http')// 2. 如果核心模块中没有该模块那么就会认为这个模块是一个第三方模块（自定义模块）// 先会去当前js文件所在的目录下去找是否一个一个 node_modules 文件夹// require('mime') require 加载模块注意点 所有模块第一次加载完毕后都会有 缓存，二次加载直接读取缓存，避免了二次开销 因为有 缓存，所以模块中的代码只在第一次加载的时候执行一次 每次加载模块的时候都优先从缓存中加载，缓存中没有的情况下才会按照 node.js 加载模块的规则去查找 核心模块在 Node.js 源码编译的时候，都已经编译为二进制执行文件，所以加载速度较快（核心模块加载的优先级仅次于 缓存加载） 核心模块都保存在 lib 目录下 试图加载一个和 核心模块 同名的 自定义模块（第三方模块）是不会成功的 自定义模块要么名字不要与核心模块同名 要么使用路径的方式加载 核心模块 只能通过 模块名称 来加载（错误示例：require(‘./http’); 这样是无法加载 核心模块 http的 ） require() 加载模块使用 ./ 相对路径时，相对路径是相对当前模块，不受执行 node 命令的路径影响 建议加载文件模块的时候始终添加文件后缀名，不要省略。 三、补充 CommonJS 规范 CommonJS 规范 模块的定义 总结：CommonJS 是为 JavaScript 语言制定的一种 模块规范、编程 API规范 node.js 遵循了 CommonJS规范 关于 node.js 中 Module 详细介绍 Module 自己设计路由实现 Hacker News 网站部分功能参考网址：https://news.ycombinator.com/ 步骤 实现新闻列表页 - 首页 - index 实现新闻详情页 - 详情页 - details 实现新闻添加页 - 提交页 - submit 实现保存数据功能 - 将数据写入到 .json 文件中 实现首页数据的动态加载 - 根据.json文件来加载数据 实现思路规划项目目录结构 HackerNews resources css images views（存放html模板页面） data（保存新闻数据 data.json 文件） app.js 文件（该文件即我们写服务器端JavaScript代码的地方，用来处理用户请求） package.json 路由设计 注意：此处要自己设计路由，而不是像模拟 Apache 静态资源服务器一样 根据不同的请求返回相应的功能 当请求 / 和 /index 时，返回 views/index.html 文件内容 当请求 /details 时，返回 views/details.html 文件内容 当请求 /submit 时，返回 views/submit.html 文件内容 当请求 /r 时，保存用户提交的新闻数据，并将重定向到index页面。 对于其他以’/resources’开头的都当做静态资源来处理。 知识点 封装render()函数，将render()函数挂载到response对象上，实现response.render()效果。 使用underscore模块中的模板引擎功能，渲染index页面中的新闻数据。 通过 url 模块来处理 get 请求 12345678// 1. 将 req.url 通过 url 模块来处理 var urlObj = url.parse(req.url, true); // 1.1 获取用户请求的URL，不带查询字符串 // 注意：此时的reqUrl中不包含 get 的请求参数，只是pathname var reqUrl = urlObj.pathname.toLowerCase(); // urlObj.query 服务器端接收 post 提交过来的数据 通过 querystring 模块将查询字符串转换为 json 对象 JSON在线格式化JSON在线格式化 url模块介绍 当服务器处理 get 请求时，用户请求的参数是在 request 的 url 属性中，纯字符串，使用起来并不方便 url 模块可以更方便地解析用户 get 请求提交上来的参数 具体使用 加载模块 var url = require(&#39;url&#39;); 调用parse()方法解析 123456url.parse(urlString[, parseQueryString[, slashesDenoteHost]]);var urlObj = url.parse(reqUrl, true);// url对象的pathname属性，获取不包含查询字符串的url// url对象的query属性中包含的就是请求字符串的键值对对象 模块化什么是模块？ 每个.js文件就是一个模块 从npm上下载的一个包（可能是由多个文件组成的一个实现特定功能的包）也是一个模块 任何文件或目录只要可以被Node.js通过require()函数加载的都是模块 每个模块就是一个独立的作用域，模块和模块之间不会互相”污染” 我们可以通过编程的方式，指定某个模块要对外暴露的内容（其实就是指定require的返回值，通过require的返回值对外暴露指定内容）。这个对外暴露内容的过程也叫”导出” module.exports 为什么要进行模块化 方便代码管理、项目维护 有助于分工协同开发 模块和模块之间不会出现变量”污染”，一个模块就是一个作用域。 模块化可以做到职责分离，每个模块实现一个独立的功能 补充：面向对象编程的5（6）大原则： 开放封闭原则 里氏替换原则 依赖倒置原则 单一职责原则 接口隔离原则 什么是包？ 通过package.json描述的一个文件或目录（可以理解成一个实现某个功能的1个文件或多个文件，通过package.json组织起来） 包不一定能被Node.js通过require()来加载，那么就不就叫模块。比如有些包中没有设置启动文件（package.json中的main字段），就不是模块。 package 和 module 参考链接 在Node.js中模主要分为：核心模块 和 文件模块核心模块 http、fs、path、url、net、os、readline、…… 核心模块在Node.js自身源码编译时，已经编译成二进制文件 部分核心模块在Node.js进程启动的时候已经默认加载到缓存里面了 文件模块(包含独立文件模块和第三方模块) 文件模块可以是：.js 模块、.node模块、*.json模块，这些都是文件模块 无论从npm上下载的第三方模块还是我们自己编写的模块都是文件模块 module.exports 和 exports在每个模块中module表示当前模块对象, 里面保存了当前模块对象的各种信息module.exports 其实就是 require()加载模块时的返回值exports 就是module.exports的一个引用1exports = module.exports; 特别注意：最终暴露给require的返回值的是：module.exports, 而不是exports 1234567891011121314151617181920 // To illustrate（说明） the behavior, imagine this hypothetical implementation of require(), which is quite similar to what is actually done by require(): function require(...) &#123; var module = &#123; exports: &#123;&#125; &#125;; ((module, exports) =&gt; &#123; // Your module code here. In this example, define a function. function some_func() &#123;&#125;; exports = some_func; // At this point, exports is no longer a shortcut to module.exports, and // this module will still export an empty default object. module.exports = some_func; // At this point, the module will now export some_func, instead of the // default object. &#125;)(module, module.exports); return module.exports;&#125; require 加载模块时做了2件事 执行了模块中的代码 返回了模块中对外暴露的内容（可能是对象、函数等等） 下载Node.js源码，打开看下JavaScript 的严格模式—— &quot;use strict&quot;; 或 &#39;use strict&#39;; 参考链接： http://www.ruanyifeng.com/blog/2013/01/javascript_strict_mode.html https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode art-template npm 搜索：art-template 参考链接https://www.npmjs.com/package/art-templateart-template文档]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs day2]]></title>
    <url>%2F2018%2F09%2F24%2Fnodejs(day2)%2F</url>
    <content type="text"><![CDATA[复习了解: 浏览器渲染引擎工作原理 浏览器访问网站过程 Web开发本质：请求、处理、响应 C/S 架构 和 B/S 架构 node.js 是什么？ node.js 有什么特点？ node.js 安装 node.js 开发网站 和 传统方式开发网站（PHP、JSP等）有什么区别？ node.js REPL 如何进入 REPL 环境 如何退出 REPL 环境 通过创建 js 文件开发 node.js 程序 重点: 通过 fs 模块实现文件读写操作 path 模块使用 __dirname 和 __filename node.js 中异步是如何实现的？为什么说 node.js 即是单线程又是异步非阻塞 I/O 模型？ 调用栈 调用队列 编写简单的 http 服务程序，无论请求当前网站下哪个路径，都返回 hello world 乱码问题。res.setHeader(&#39;Content-Type&#39;, &#39;text/plain; charset=utf-8&#39;); 设置显示 HTML 内容。res.setHeader(&#39;Content-Type&#39;, &#39;text/html; charset=utf-8&#39;); 补充： 文件操作时，无需先判断文件是否存在，直接操作即可，如果文件不存在会反应在 error 对象中 try-catch 的使用 今日授课内容 通过 node.js 编写 http 服务程序 - 通过读取静态 HTML 文件来响应用户请求(带图片和外部CSS样式) 通过 node.js 编写 http 服务程序 - 模拟 Apache 服务器处理静态资源 mime 第三方模块使用 在请求服务器的时候，请求的 url 就是一个标识！ request（http.IncomingMessage） 和 response（ServerResponse） 对象介绍 request: 服务器解析用户提交的 http 请求报文，将结果解析到 request 对象中。凡是要获取和用户请求相关的数据都可以通过 request 对象获取 response: 在服务器端用来向用户做出响应的对象。凡是需要向用户（客户端）响应的操作，都需要通过 response 对象来进行。 NPM package.json、package-lock.json 文件介绍 元数据 自己设计路由，实现 HackerNews网站部分功能 underscore 模块介绍、url 模块介绍 在html页面中写相对路径’./‘ 和 绝对路径 ‘/‘的含义 此处 ./ 相对的是吐出当前页面的url 通过设置 http 响应报文头实现弹框下载功能 设置 Content-Type: application/octet-stream 设置 Content-Disposition: attachment; filename=demo.txt 其他参考 1、注意在发送不同类型的文件时，要设置好对应的Content-Type Content-Type参考 OSChina Content-Type参考 MDN 2、HTTP状态码参考 w3org参考 w3schools参考 在 html 网页中路径的含义在 html 网页中相对路径 ‘./‘ 和 绝对路径 ‘/‘的含义 “相对路径” 到底 “相对” 的是什么？ 相对当前请求的路径 相对于吐出当前网页的路径 网页中的这个路径主要是告诉浏览器向哪个地址发起请求用的 ‘./‘ 表示本次请求从相对于当前页面的请求路径（即服务器返回当前页面时的请求路径）开始 ‘/‘ 表示请求从根目录开始 打开浏览器来演示，最终主要体现在了请求报文的 url 上。演示步骤 找到之前的静态html页面中带有外部样式表连接的网页 请求该网页，查看http请求报文中的请求路径 一、通过静态html响应用户请求12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394// 根据用户不同请求，做出不同响应（响应 现有的 HTML 文件）// 加载 http 模块var http = require('http');// 加载 fs 模块var fs = require('fs');// 加载 path 模块var path = require('path');// 创建 http 服务，并启动该服务http.createServer(function (req, res) &#123; // 通过 req.url 获取用户请求的路径，根据不同的请求路径服务器做出不同的响应 if (req.url === '/' || req.url === '/index') &#123; // 读取 index.html 文件 fs.readFile(path.join(__dirname, 'htmls', 'index.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; // 把读取到的 index.html 中的内容直接发送给浏览器 res.end(data); &#125;); &#125; else if (req.url === '/login') &#123; // 读取 index.html 文件 fs.readFile(path.join(__dirname, 'htmls', 'login.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; // 把读取到的 index.html 中的内容直接发送给浏览器 res.end(data); &#125;); &#125; else if (req.url === '/list') &#123; // 读取 index.html 文件 fs.readFile(path.join(__dirname, 'htmls', 'list.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; // 把读取到的 index.html 中的内容直接发送给浏览器 res.end(data); &#125;); &#125; else if (req.url === '/register') &#123; // 读取 index.html 文件 fs.readFile(path.join(__dirname, 'htmls', 'register.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; // 把读取到的 index.html 中的内容直接发送给浏览器 res.end(data); &#125;); &#125; else if (req.url === '/images/index.png') &#123; // 表示用户要请求 images 下的 index.png 图片 fs.readFile(path.join(__dirname, 'images', 'index.png'), function (err, data) &#123; if (err) &#123; throw err; &#125; res.setHeader('Content-Type', 'image/png'); // 把读取到的 index.html 中的内容直接发送给浏览器 res.end(data); &#125;); &#125; else if (req.url === '/css/index.css') &#123; fs.readFile(path.join(__dirname, 'css', 'index.css'), function (err, data) &#123; if (err) &#123; throw err; &#125; res.setHeader('Content-Type', 'text/css'); // 把读取到的 index.html 中的内容直接发送给浏览器 res.end(data); &#125;); &#125; else &#123; // 读取 index.html 文件 fs.readFile(path.join(__dirname, 'htmls', '404.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; // 把读取到的 index.html 中的内容直接发送给浏览器 res.end(data); &#125;); &#125; &#125;).listen(9090, function () &#123; console.log('http://localhost:9090');&#125;); 二、模拟Apache第一步 建立public文件夹把要用的html css 图片都放进去第二步 下载安装第三方插件mime 打开 https://www.npmjs.com/package/mime 安装mime 命令：npm install mime （命令不一定是永久的还得看官网改变而改变）(2后面的方法均会因版本的变化而变化与官网为准) 引入外部模块 const mime = require(‘mime’); 使用方法 mime.getType(‘txt’); 第三步使用12345678910111213141516171819202122232425262728293031323334353637383940414243// 加载 http 模块var http = require('http');var path = require('path');var fs = require('fs');var mime = require('mime');// 创建服务http.createServer(function (req, res) &#123; // 1. 获取用户请求的路径 // req.url // /css/index.css // /images/index.png // 2. 获取 public 目录的完整路径 var publicDir = path.join(__dirname, 'public'); // 3. 根据 public 的路径 和用户请求的路径，最终计算出用户请求的静态资源的完整路径 var filename = path.join(publicDir, req.url); // console.log(filename); // 4. 根据文件的完整路径去读取该文件，如果读取到了，则把文件返回给用户，如果读取不到，则返回 404 fs.readFile(filename, function (err, data) &#123; // body... if (err) &#123; res.end('文件不存在 404'); &#125; else &#123; // 通过第三方模块 mime，来判断不同的资源对应的 Content-Type 的类型 res.setHeader('Content-Type', mime.getType(filename)); // 如果找到了用户要读取的文件，那么直接把该文件返回给用户 res.end(data); &#125; &#125;); // res.end('over');&#125;).listen(9090, function () &#123; console.log('http://localhost:9090');&#125;); 三、url就是一个标示index.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1 style=&quot;color: red;&quot;&gt;Hello Index&lt;/h1&gt; &lt;h1&gt;你好 首页！！！看乱码吗？&lt;/h1&gt; &lt;img src=&quot;./haha.xxx&quot; alt=&quot;haha.xxx&quot;&gt;//图片路径的变化&lt;/body&gt;&lt;/html&gt; add.js12345678910111213141516171819202122232425262728293031323334// 加载 http 模块var http = require('http');var path = require('path');var fs = require('fs');var mime = require('mime');// 创建服务http.createServer(function (req, res) &#123; if (req.url === '/index.do' || req.url === '/index.html') &#123; // 读取 index.html 并返回 fs.readFile(path.join(__dirname, 'index.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; res.end(data); &#125;); &#125; else if (req.url === '/haha.xxx') &#123; fs.readFile(path.join(__dirname, '150.jpg'), function (err, data) &#123; if (err) &#123; throw err; &#125; res.setHeader('Content-Type', 'image/jpeg'); res.end(data); &#125;); &#125; &#125;).listen(9090, function () &#123; console.log('http://localhost:9090');&#125;); 四、request 对象 和 response对象request 对象 request 对象类型 &lt;http.IncomingMessage&gt;, 继承自stream.Readable request 对象常用成员 request.headers request.rawHeaders request.httpVersion request.method request.url response 对象 response 对象类型 &lt;http.ServerResponse&gt; response 对象常用成员 response.writeHead(statusCode[, statusMessage][, headers]) This method must only be called once on a message and it must be called before response.end() is called. 这个方法在每次请求响应前都必须被调用（只能调用一次）。并且必须在end()方法调用前调用 2. If you call response.write() or response.end() before calling this, the implicit/mutable headers will be calculated and call this function for you. - 如果在调用writeHead()方法之前调用了write() 或 end()方法，系统会自动帮你调用writeHead()方法，并且会生成默认的响应头 3. When headers have been set with response.setHeader(), they will be merged with any headers passed to response.writeHead(), with the headers passed to response.writeHead() given precedence. - 如果通过 res.setHeader() 也设置了响应头，那么系统会将serHeader()设置的响应头和writeHead()设置的响应头合并。 并且writeHead()的设置优先 12345// 示例代码：res.writeHead(200, 'OK', &#123; 'Content-Type': 'text/html; charset=utf-8', 'Content-Length': Buffer.byteLength(msg)&#125;); response.write(chunk[, encoding][, callback]) 参数1：要写入的数据，可以是字符串或二进制数据，必填。 参数2：编码，默认是utf8，选填。 参数3：回调函数，选填。 response.end([data][, encoding][, callback]) 结束响应。 This method signals to the server that all of the response headers and body have been sent; that server should consider this message complete. The method, response.end(), MUST be called on each response. res.end()这个方法告诉服务器所有要发送的响应头和响应体都发送完毕了。可以人为这次响应结束了。 同时每次响应都必须调用该方法，用来结束响应 * 参数1：结束响应前要发送的数据，选填。 * 参数2：编码，选填。 * 参数3：回调函数，选填。 response.setHeader(name, value) 设置响应报文头 response.statusCode 设置或读取http响应码 response.statusMessage 设置或读取http响应状态消息 五、NPM - Node Package Manager - Node 包管理器NPM 是什么？ npm（全称Node Package Manager，即node包管理器）是Node.js默认的、以JavaScript编写的软件包管理系统。 npm 官方网站 npm 官方文档 一般当我们说npm的时候可能指3件事 NPM 网站：https://www.npmjs.com/ NPM 包管理库，存储了大量的JavaScript代码库 NPM 客户端，我们所使用的npm命令行工具。使用JavaScript开发的基于node.js的命令行工具，本身也是Node的一个包。 参考图片 NPM 官方解释： npm is the package manager for JavaScript and the world’s largest software registry. npm 是一个JavaScript包管理器，并且是世界上最大的软件登记处 discover packages of reusable code — and assemble them in powerful new ways. 发现可重用代码，并集成代码包到项目中的全新的、强大方式 npm makes it easy for JavaScript developers to share and reuse code, and it makes it easy to update the code that you’re sharing. npm 让JavaScript开发者共享和重用代码变的更容易，同时也让我们更容易地更新正在被共享的代码 npm与 node.js npm是Node.js默认的软件包管理系统。安装完毕node后，会默认安装好npm npm本身也是基于Node.js开发的包（软件） 如何安装 NPM? npm会随着Node.js自动安装，安装完毕node.js后会自动安装npm 查看当前npm版本：npm -v 更新npm：npm install npm@latest -g NPM 使用 在 https://www.npmjs.com/ 网站找到需要的包 在项目的根目录下，执行npm install 包名称安装 在node.js代码中通过 require(&#39;包名&#39;); 加载该模块 注意：通过npm install 包名安装的包，会自动下载到当前目录下的node_modules目录下，如果该目录不存在，则创建，如果已存在则直接下载进去。 在代码中通过 require(&#39;包名&#39;); 加载该模块 —– 上面说的这种方式叫做 本地安装。 NPM 全局安装介绍 什么是 npm 全局安装？ npm install 包名 -g npm 全局安装指的是把包安装成了一个命令行工具。 12345// 通过npm全局安装mimenpm install mime -g//安装完毕后可以在命令行中直接使用mime a.txt 命令来查看对应的结果 npm 全局安装实际做了2件事： 下载包到一个指定的目录C:\Users\username\AppData\Roaming\npm\node_modules 创建一段命令行执行的代码。C:\Users\username\AppData\Roaming\npm\mime -&gt; C:\Users\steve xiaohu zhao\AppData\Roaming\npm\node_modules\mime\cli.js NPM 安装建议 全局安装只是为了可以当做命令行使用而已 五、npm常用命令介绍 install，安装包。npm install 包名 uninstall，卸载包。·npm uninstall 包名` version，查看当前npm版本。npm version 或 npm -v init，创建一个package.json文件。npm init 注意：当使用 npm init -y 的时候，如果当前文件夹（目录）的名字比较怪（有大写、有中文等等）就会影响npm init -y 的一步生成操作，此时需要 npm init 根据向导来生成 “模块”（Modules）和”包”（Packages）的区别 A module is any file or directory that can be loaded by Node.js’ require(). 模块可以是任何一个文件或目录（目录下可以有很多个文件），只要能被node.js通过require()即可。 A package is a file or directory that is described by a package.json. This can happen in a bunch of different ways! 包是一个文件或目录（目录下可以有多个文件）必须有一个package.json文件来描述，就可以是一个包。 node.js 错误调试： 当开启服务后，在浏览器中输入地址，如果出现浏览问题，首先要先看 服务器控制台是否报错。如果报错，直接根据服务器报错进行排错。 打开浏览器开发者工具中的 “网络” 部分，查看请求是否成功发出去了 看一下请求报文是不是和我们想的一样 响应状态码 六、package.json 文件package.json 文件的作用？ package.json 文件是一个包说明文件（项目描述文件），用来管理组织一个包（一个项目） package.json 文件是一个 json 格式的文件 位于当前项目的根目录下 元数据 package.json 文件中常见的项有哪些？ name 包的名字 version 包的版本 description 包描述 author 包的作者 main 包的入口js文件，从main字段这里指定的那个js文件开始执行 dependencies 当前包依赖的其他包 如何创建一个 package.json 文件 通过 npm init 命令 或者 npm init -y 或 npm init -yes 命令 手动创建一个 注意 通过 npm init -y 或 npm init -yes 创建 package.json 文件时，执行命令所在的目录接名称中不能包含大写字母 package.json 文件中，项目名称本身不能包含大写字母 npm 更新新版本后，项目所在的文件夹如果包含中文等特殊字符，创建的时候不会提示一步一步的输入，直接报错。 官方介绍 package.json Using a package.json 七、自己设计路由实现 Hacker News 网站部分功能参考网址：https://news.ycombinator.com/ 步骤 实现新闻列表页 - 首页 - /index get 实现新闻详情页 - 详情页 - /details get 实现新闻添加页 - 提交页 - /submit get/add get/add post 实现保存数据功能 - 将数据写入到 data.json 文件中 实现首页数据的动态加载 - 根据.json文件来加载数据 实现思路规划项目目录结构 HackerNews resources css images views（存放html模板页面） data（保存新闻数据 data.json 文件） app.js 文件（该文件即我们写服务器端JavaScript代码的地方，用来处理用户请求） package.json 路由设计 注意：此处要自己设计路由，而不是像模拟 Apache 静态资源服务器一样 根据不同的请求返回相应的功能 当请求 / 和 /index 时，返回 views/index.html 文件内容 当请求 /details 时，返回 views/details.html 文件内容 当请求 /submit 时，返回 views/submit.html 文件内容 当请求 /add 时，保存用户提交的新闻数据，并将重定向到index页面。 对于其他以’/resources’开头的都当做静态资源来处理。 知识点 封装render()函数，将render()函数挂载到response对象上，实现response.render()效果。 使用underscore模块中的模板引擎功能，渲染index页面中的新闻数据。 通过 url 模块来处理 get 请求 12345678// 1. 将 req.url 通过 url 模块来处理 var urlObj = url.parse(req.url, true); // 1.1 获取用户请求的URL，不带查询字符串 // 注意：此时的reqUrl中不包含 get 的请求参数，只是pathname var reqUrl = urlObj.pathname.toLowerCase(); // urlObj.query 服务器端接收 post 提交过来的数据 通过 querystring 模块将查询字符串转换为 json 对象 JSON在线格式化JSON在线格式化]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习心路历程]]></title>
    <url>%2F2018%2F09%2F22%2F2018-09-22%2F</url>
    <content type="text"><![CDATA[作为一个 IT 业学者，快要从事软件技术开发类的大二学生我内心很慌，不知道自己到底准备好了没有，感觉自己准备好了但是自己的技术好像并没有那么好，有时候还是很迷茫的，不知道自己到底要做什么该做什么，做什么才是对的一直都很迷糊该走前端路线还是后台开发呢，还是做全栈什么都要学本来我以为前端只是很简单的页面，但是接触了后才发现虽然只是分了三个比较大一点点方向就没什么了，但是要学好并不是那么的容易的 css，html，js 掌握后还要学习各种的框架不断的去练习才可以让自己更加快速的写页面，然后学了一点点后台 php 和 java，就觉得自己很厉害了想去写一个系统在我开始构想写这一个系统的时候我一开始写的是登陆页面的前后台，在我还没有写完的时候我遇到了问题后台数据的传输，虽然我解决了这个问题但是我也发现了自己所用的方法是最笨嘬的方法，在那个时候慢慢的回想自己学的知识，才发现自己写前端页面用原生写是可以写的出来的但是用到框架 vue 就不太懂，很多之前的知识因为不用也开始慢慢的忘记了，在这时候我才发现自己对前端有一定的了解但是对后台的庞大我是一无所知，比小白还小吧，虽然学过java，c，php这些后台语言但是没有用过这些写过系统，java写过的项目也是很早之前的都不记得了，用php做后台来写的是可以但是用的方法实在是太笨拙了，对于后台的很多交互方式作用也并不是很了解，只是会简单的与数据库进行交互，这对于在公司工作的话远远不够，所以又要开始新的历程，php框架开始php框架学习的时候，一开始配置apache服务器的时候弄了两天找了各种的方法才配置好服务器当时的内心真的是奔溃了，然后开始写代码了才发现后台语言框架的编写是很方便的但是在这过程中也遇到了问题，框架无法渲染可视页面，也是搞了两天各种方法用遍，后来的这几天都没有看php，而是把我一直在看的js高级教程看完，然后看node，后台的庞大让我有点害怕所以暂时放弃一下后台把前端的一些知识巩固一下再去看后台，把我的项目写好，作为编程学习者来说我并不算是优秀的一个，我算是那种比较懒又不聪明的那个，所以很多时候还是坚持着每天都学习，让自己每天都可以进步一点点，可能是我比较乐观我觉得自己比昨天好那就是自己进步了，但是我并不觉得自己很努力，因为还有更多的人比我更聪明更厉害更谦虚更努力，我本来都一无所有了虽然不惧怕从头再来，但是我输不起了，没有时间可以让我再去浪费再去输了，大二了马上就是要出来实习没有再多的机会可以让我去学习和拼搏，老师说我那么拼干什么说我很努力，但是我并没有觉得我自己很努力，我是觉得我永远感觉不到自己到底又多懒，我的对手到底有多强大，别人到底付出了多少的时间精力代价，而我只是每天都学习几个小时就觉得很累很累的人，我也不知道我自己这么懒可以用什么和别人去比拼，我也不想输，所以只可以每天坚持学一点，虽然追不上比我厉害很多的人但是起码不会让自己堕落下去，起码我还可以挺起胸膛为了生活去拼搏，我也不是家里有矿的人，我的父母什么也没有留给我，以后要什么样的生活，什么都要自己去打拼回来，我的父母和我说他们那时候爷爷奶奶也是什么都没有给他们都是他们自己一手一脚熬回来的，生活真的不容易，社会也不容易，能生存下来并且养大我们也不是容易，都是点点都熬出来我们没有经历过抗战内战文化大革命闹饥荒那些，我们从出生到现在都没有熬过一日苦爸妈都能给饱饭吃没有试过饿肚子，社会都残酷无情并不是不知道，要是想站稳脚步那必须把自己武装起来，打造成不屈的钢铁才能抵御最强烈的风暴，虽然这样真的很辛苦也不一定可以做到，但是真的没时间了，累了可以歇但是歇息的时候别人也是在奋斗的根本追不上别人的脚步，那些更加厉害的人更加的努力，不知道自己凭什么闲着，大家都是一个头颅两个手两个脚，为何自己就是那么的差劲，别人就是那么的厉害，别人都是在拼命为什么自己不可以，继续加油即使输了也没有关系，生活不会亏待付出努力的人上学期认识了个已经毕业的师兄一直都没这么联系，是一位很厉害的师兄，这个学期突然联系我，不断的想我去参加比赛和我说了很多，从中学习到了很多也发现了很多自己的陋习，知道了很多的一些自己以前都不注意的问题也告诉了我一些方向，不断的在后面推动的我，和高手谈话每一次都可以收益非浅，不过说起引路人，还是在大一的时候认识的一个公司里面有着十几年工作经验的老大哥，一直对我比较好，每次请教都很细心的教导也不摆老大哥的架子很好人，算是我的引路人，从一开始的css，js，html，框架，php等这些知识都是看他的教程和与他交流学习，不断的指引我向前面走，感谢老大哥虽然学校大一开始开始c语言html但是都是很基础很基础所以每一次上课都没有什么学的只可以回去自己学，大一第二学期的时候有java和数据库，但是也是非常基础对数据库没有什么兴趣所以并不是学的很好，这个学期开设了js，h5，javaweb，ps但是除了javaweb以外我都学过了而且学校一直都是学的很基础的东西完全都没有学到很多的真本事，虽然说打好基础很重要但是全部都是基础也没什么用，没有写过项目不知道着么去写项目，要这么去布局如何写，着么才可以达到很好的效果，根本都没有，然而经常被老师危险期末不给过我也是醉了！只可以自己控制好自己不断的去学习，但愿还能坚持住，彩虹的尽头总是会有希望的！]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs day1]]></title>
    <url>%2F2018%2F09%2F22%2Fnodejs(day1)%2F</url>
    <content type="text"><![CDATA[day1十部曲1.课程安排2.授课思路3.浏览器工作原理4.web开发的本质5.nodejs的介绍6.基于nodejs编写程序7.nodejs学习8.nvm9.buffer10.总结 一、课程安排课程总天数：7天第 01 天： 浏览器工作原理 浏览器访问网站全过程 node.js 介绍 通过 node.js 编写服务端程序 第 02 天： node.js 中的 request 对象 和 response 对象 npm 介绍 HTML 页面中路径的真实含义 package.json 文件 路由介绍、设计路由 代码封装 开始实现 Hacker News 网站 循环中的异步 封装异步函数 待定：模拟 Chrome 显示文件列表 第 03 天： HackerNews 新闻列表展示 添加新闻页 新闻详情页 underscore module 、 module.exports 和 exports node.js 模块化 第 04 天： HackerNews 代码模块化 http-server express 介绍 中间件 通过 express 完成 HackerNews 思路 第 05 天： express 实现 Hacker News MongoDb 介绍第 06 天： 完善 Hacker News 封装 DB 模块第 07 天： 实现 sms ajax 实现 sms node.js 抓取数据、cheerio 介绍 模拟 body-parser 中间件 二、授课思路准备知识 浏览器工作原理 浏览器组成 浏览器渲染引擎工作原理 通过浏览器访问网站全过程 Web 开发本质 请求: 客户端发起请求. 处理: 服务器 处理请求. 响应: 服务器将处理结果发送给客户端. Web应用程序与桌面应用程序对比（计算器案例） 关于C/S（Client/Server） 和 B/S（Browser/Server） node.js 介绍 node.js 是什么？ node.js 有哪些特点？ node.js 官方网站 node.js 学习资源 为什么要学习Node.js? Node.js安装和配置 Node.js 开发 Web 应用程序 和 PHP、Java、ASP.Net等传统模式开发Web应用程序区别 node.js 编程 node.js 编写控制台程序 node.js 进行文件读写 同步 &amp; 异步读取文件 node.js 创建 http 服务程序解释异步是如何实现的？ eventloopnpm 介绍node.js 实现新闻列表 三、浏览器工作原理浏览器的组成 人机交互部分（UI） 网络请求部分（Socket） JavaScript引擎部分（解析执行JavaScript） 渲染引擎部分（渲染HTML、CSS等） 数据存储部分（cookie、HTML5中的本地存储LocalStorage、SessionStorage） sqlite 主流渲染引擎介绍 渲染引擎 又叫 排版引擎 或 浏览器内核。 主流的 渲染引擎 有 Chrome浏览器: Blink引擎（WebKit的一个分支）。 Safari浏览器: WebKit引擎，windows版本2008年3月18日推出正式版，但苹果已于2012年7月25日停止开发Windows版的Safari。 FireFox浏览器: Gecko引擎。 Opera浏览器: Blink引擎(早期版使用Presto引擎）。 Internet Explorer浏览器: Trident引擎。 Microsoft Edge浏览器: EdgeHTML引擎（Trident的一个分支）。 工作原理 解析HTML构建Dom树（Document Object Model，文档对象模型），DOM 是W3C组织推荐的处理可扩展置标语言的标准编程接口。 构建渲染树，渲染树并不等同于Dom树，因为像head标签 或 display: none这样的元素就没有必要放到渲染树中了，但是它们在Dom树中。 对渲染树进行布局，定位坐标和大小、确定是否换行、确定position、overflow、z-index等等，这个过程叫&quot;layout&quot; 或 &quot;reflow&quot;。 绘制渲染树，调用操作系统底层API进行绘图操作。 渲染引擎工作原理示意图渲染引擎工作原理示意图 WebKit工作原理（Chrome、Safari、Opera） Gecko工作原理（FireFox） 浏览器的 reflow 或 layout 过程https://www.youtube.com/watch?v=ZTnIxIA5KGw 打开 Chrome 的 Rendering 功能第一步： 第二步： 浏览器访问网站过程 在浏览器地址栏中输入网址。 浏览器通过用户在地址栏中输入的URL构建HTTP请求报文。 123456789GET / HTTP/1.1Host: www.taobao.comConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Accept-Encoding: gzip, deflate, sdch, brAccept-Language: zh-CN,zh;q=0.8,en;q=0.6Cookie: l=Ag0NWp9E8X4hgaGEtIBhOmKxnSOH6kG8; isg=AkZGLTL-Yr9tHDZbgd5bsn4Rlzwg5IphaK-1BzBvMmlEM-ZNmDfacSyDfdgF; thw=cn 浏览器发起DNS解析请求，将域名转换为IP地址。 浏览器将请求报文发送给服务器。 服务器接收请求报文，并解析。 服务器处理用户请求，并将处理结果封装成HTTP响应报文。 1234567891011121314151617181920212223242526272829303132333435HTTP/1.1 200 OKServer: TengineDate: Thu, 13 Apr 2017 02:24:25 GMTContent-Type: text/html; charset=utf-8Transfer-Encoding: chunkedConnection: keep-aliveVary: Accept-EncodingVary: Ali-Detector-Type, X-CIP-PTCache-Control: max-age=0, s-maxage=300Via: cache8.l2cm10-1[172,200-0,C], cache13.l2cm10-1[122,0], cache3.cn206[0,200-0,H], cache6.cn206[0,0]Age: 293X-Cache: HIT TCP_MEM_HIT dirn:-2:-2X-Swift-SaveTime: Thu, 13 Apr 2017 02:19:32 GMTX-Swift-CacheTime: 300Timing-Allow-Origin: *EagleId: 9903e7e514920502659594264eStrict-Transport-Security: max-age=31536000Content-Encoding: gzip&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt;&lt;meta charset="utf-8" /&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;meta name="renderer" content="webkit" /&gt;&lt;title&gt;淘宝网 - 淘！我喜欢&lt;/title&gt;&lt;meta name="spm-id" content="a21bo" /&gt;&lt;meta name="description" content="淘宝网 - 亚洲较大的网上交易平台，提供各类服饰、美容、家居、数码、话费/点卡充值… 数亿优质商品，同时提供担保交易(先收货后付款)等安全交易保障服务，并由商家提供退货承诺、破损补寄等消费者保障服务，让你安心享受网上购物乐趣！" /&gt;&lt;meta name="aplus-xplug" content="NONE"&gt;&lt;meta name="keyword" content="淘宝,掏宝,网上购物,C2C,在线交易,交易市场,网上交易,交易市场,网上买,网上卖,购物网站,团购,网上贸易,安全购物,电子商务,放心买,供应,买卖信息,网店,一口价,拍卖,网上开店,网络购物,打折,免费开店,网购,频道,店铺" /&gt;&lt;/head&gt;&lt;body&gt;......&lt;/body&gt;&lt;/html&gt; 服务器将HTTP响应报文发送给浏览器。 浏览器接收服务器响应的HTTP报文，并解析。 浏览器解析 HTML 页面并展示，在解析HTML页面时遇到新的资源需要再次发起请求。 最终浏览器展示出了页面 HTTP请求报文和响应报文格式 DNS 解析过程 windows 下 hosts 文件位置C:\Windows\System32\drivers\etc\hosts DOM 解析参考代码: 123456&lt;html&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;div&gt; &lt;img src="example.png" alt="example"/&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; Webkit CSS 解析 How Browsers work - 浏览器是如何工作的How Browsers workhttps://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/ 四、Web开发本质牢记以下三点 请求，客户端发起请求。 处理，服务器处理请求。 响应，服务器将处理结果发送给客户端 对比一个单机版计算器和Web版计算器客户端处理响应 服务器响应完毕后，客户端继续处理： 浏览器：解析服务器返回的数据 iOS、Android 客户端，解析服务器返回的数据，并且通过iOS或Android的UI技术实现界面的展示功能 关于 C/S（Client/Server） 和 B/S（Browser/Server）C/S: 客户端服务器 B/S: 浏览器服务器 五、node.js 介绍node.js 是什么？ node.js 是一个开发平台，就像Java开发平台、.Net开发平台、PHP开发平台、Apple开发平台一样。 何为开发平台？有对应的编程语言、有语言运行时、有能实现特定功能的API（SDK：Software Development Kit） 该平台使用的编程语言是 JavaScript 语言。 node.js 平台是基于 Chrome V8 JavaScript 引擎构建。 基于 node.js 可以开发控制台程序（命令行程序、CLI程序）、桌面应用程序（GUI）（借助 node-webkit、electron 等框架实现）、Web 应用程序（网站） PHP开发技术栈: LAMP - Linux Apache MySQL PHP node.js 全栈开发技术栈: MEAN - MongoDB Express Angular Node.js node.js 有哪些特点？ 事件驱动(当事件被触发时，执行传递过去的回调函数) 非阻塞 I/O 模型（当执行I/O操作时，不会阻塞线程） 单线程 拥有世界最大的开源库生态系统 —— npm。 node.js 网站 node.js官方网站 node.js中文网 node.js 中文社区 为什么要学习Node.js? 通过学习Node.js开发深入理解服务器开发、Web请求和响应过程、 了解服务器端如何与客户端配合 学习服务器端渲染 学习服务器端为客户端编写接口 现在前端工程师面试，对 Node.js 开发有要求 补充提问： 在Node.js平台开发时，能使用Dom API吗？比如：document.getElementById(&#39;id&#39;); window.location 等? 复习 浏览器端 JavaScript 组成：ECMAscript、Dom、Bom 学习目标 了解服务器开发过程 会使用 node.js 开发基本的 http 服务程序（Web应用程序） Node.js安装和配置 下载地址 当前版本 历史版本 官网术语解释 LTS 版本：Long-term Support 版本，长期支持版，即稳定版。 Current 版本：Latest Features 版本，最新版本，新特性会在该版本中最先加入。 注意： 安装完毕后通过命令：node -v来确定是否安装成功【注意：打开”命令窗口”的时候建议使用”管理员方式”打开】 如果需要则配置环境变量。 通过 nvm-windows 管理一台计算机上的多个 node 版本 Node.js 开发 Web 应用程序 和 PHP、Java、ASP.Net等传统模式开发Web应用程序区别 传统模式 有 Web 容器 Node.js开发Web应用程序 没有 Web 容器 补充提问： 什么是动态网页？什么是静态网页？ 六、基于nodejs编写程序(在 node.js 上编写程序)REPL介绍 REPL 全称: Read-Eval-Print-Loop（交互式解释器） R 读取 - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。 E 执行 - 执行输入的数据结构 P 打印 - 输出结果 L 循环 - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。 在REPL中编写程序 （类似于浏览器开发人员工具中的控制台功能） 直接在控制台输入 node 命令进入 REPL 环境 按两次 Control + C 退出REPL界面 或者 输入 .exit 退出 REPL 界面 按住 control 键不要放开, 然后按两下 c 键 创建 JavaScript 文件编写程序编程注意事项 配置一下Sublime Text 的代码缩进格式为2个空格 方式一 方式二 JavaScript 文件名命名规则 不要用中文 不要包含空格 不要出现node关键字 建议以 ‘-‘ 分割单词 案例 案例1：编写一个简单的函数, 实现数字相加 12345678910var n = 10;var m = 100;function add(x, y) &#123; return x + y;&#125;var result = add(m, n);console.log('计算结果是：' + result); 案例2：编写一个输出’三角形’的程序 123456789101112// process 对象是一个 global （全局变量），提供有关信息，控制当前 Node.js 进程。// 作为一个对象，它对于 Node.js 应用程序始终是可用的，故无需使用 require()。for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt;= i; j++) &#123; // 注意：console.log()输出完毕后是带换行的，所以这样做不可以 // console.log('*'); process.stdout.write('* '); &#125; process.stdout.write('\n');&#125; 案例3：文件读写案例（带同学们打开官方文档查阅） 使用到的模块var fs = require(&#39;fs&#39;); 1、写文件：fs.writeFile(file, data[, options], callback); 参数1：要写入的文件路径，必填。 参数2：要写入的数据，必填。 参数3：写入文件时的选项，比如：文件编码，选填。 参数4：文件写入完毕后的回调函数，必填。 写文件注意： 该操作采用异步执行 如果文件已经存在则替换掉 默认写入的文件编码为utf8 回调函数有1个参数：err，表示在写入文件的操作过程中是否出错了。 如果出错了err != null，否则 err === null 2、读文件：fs.readFile(file[, options], callback) 参数1：要读取的文件路径，必填。 参数2：读取文件时的选项，比如：文件编码。选填。 参数3：文件读取完毕后的回调函数，必填。 读文件注意： 该操作采用异步执行 回调函数有两个参数，分别是err和data 如果读取文件时没有指定编码，那么返回的将是原生的二进制数据；如果指定了编码，那么会根据指定的编码返回对应的字符串数据。 注意： 文件操作中的./表示当前路径，相对的是执行node命令的路径，而不是当前被执行的*.js文件的实际路径。 __dirname才永远表示当前被执行的*.js文件的实际路径 /表示根目录, 读取文件或写入文件的时候写/目录，在Windows下相当于当前磁盘根目录（比如：c:\ 或 d:\ 或 e:\ 等，在Mac下相当于硬盘根目录 /） 12345678910111213141516171819202122232425262728293031323334353637// --------------------------------- 写文件 -----------------------------// 加载文件操作模块var fs = require('fs');// 创建要写入的文件的字符串var msg = '你好，世界！你好 Node.js.';// 执行文件写入操作fs.writeFile('./data.txt', msg, 'utf8', function (err) &#123; console.log('---' + err + '----'); // /判断是否写入文件出错了 if (err) &#123; console.log('文件写入出错了，详细错误信息：' + err); // 把错误继续向上抛出 throw err; &#125; else &#123; console.log('文件写入成功！'); &#125;&#125;);// --------------------------------- 读文件 -----------------------------// 加载文件操作模块var fs = require('fs');// 执行文件读取操作fs.readFile('./data.txt', 'utf8', function (err, data) &#123; // 输出err 和 data // console.log('error: ' + err); // console.log('data: ' + data); if (err) &#123; console.log('文件读取出错啦！详细信息: ' + err); &#125; else &#123; console.log('文件读取成功，以下是文件内容：'); console.log(data); &#125;&#125;); 案例4：创建目录案例 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768// 创建一个文件夹// 加载文件操作模块var fs = require('fs');// 创建一个目录fs.mkdir('./test-mkdir', function (err) &#123; if (err) &#123; console.log('创建目录出错了，详细信息如下：'); console.log(err); &#125; else &#123; console.log('目录创建成功！'); &#125;&#125;);// ----------------------------------------------------------// 加载文件操作模块var fs = require('fs');// 1. 创建 '01-教学资料' 目录fs.mkdir('./01-教学资料', function (err) &#123; if (err) &#123; throw err; &#125; // 1.1 创建 '01-笔记大纲' 目录 fs.mkdir('./01-教学资料/01-笔记大纲'); // 1.2 创建 '02-作业任务' 目录 fs.mkdir('./01-教学资料/02-作业任务'); // 1.3 创建 '03-素材资料' 目录 fs.mkdir('./01-教学资料/03-素材资料'); // 1.4 创建 '04-随堂笔记' 目录 fs.mkdir('./01-教学资料/04-随堂笔记');&#125;);// 2. 创建 '02-源代码' 目录fs.mkdir('./02-源代码', function (err) &#123; if (err) &#123; throw err; &#125; // 2.1 创建 '预习代码'目录 fs.mkdir('./02-源代码/预习代码'); // 2.2 创建 '课堂代码'目录 fs.mkdir('./02-源代码/课堂代码');&#125;);// 3. 创建 '03-视频' 目录fs.mkdir('./03-视频');// 4. 创建 '04-其他资料' 目录fs.mkdir('./04-其他资料'); 注意： 异步操作无法通过 try-catch 来捕获异常，要通过判断 error 来判断是否出错。 同步操作可以通过 try-catch 来捕获异常。 不要使用 fs.exists(path, callback) 来判断文件是否存在，直接判断 error 即可 文件操作时的路径问题 在读写文件的时候 ‘./‘ 表示的是当前执行node命令的那个路径，不是被执行的js文件的路径 __dirname, 表示的永远是”当前被执行的js的目录” __filename, 表示的是”被执行的js的文件名（含路径)” error-first 介绍(错误优先) 案例5：通过 node.js 编写 http 服务程序 - 极简版本步骤： 加载http模块 创建http服务 为http服务对象添加 request 事件处理程序 开启http服务监听，准备接收客户端请求 注意： 浏览器显示可能是乱码，所以可以通过 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain; charset=utf-8&#39;);设置浏览器显示时所使用的编码。 Chrome 浏览器默认无法手动设置编码，需要安装”Set Character Encoding”扩展。 演示一下设置Content-Type=text/html 和 Content-Type=text/plain的区别。 参考代码： 123456789101112131415161718// 1. 加载http模块var http = require('http');// 2. 创建http服务var server = http.createServer();// 3. 开始监听'request'事件// 详细解释一下request对象和response对象server.on('request', function (req, res) &#123; // body... console.log('有人请求了~~');&#125;);// 4. 启动服务，开始监听server.listen(9000, function () &#123; console.log('服务已经启动，请访问： http://localhost:9000');&#125;); 案例6：通过 node.js 编写 http 服务程序 - 根据不同请求作出不同响应说明： 根据不同请求，显示index页面、login页面、register页面、list页面。 请求 / 或 /index 请求 /login 请求 /register 请求 /list 参考代码123456789101112131415161718192021222324252627282930313233343536// 加载http模块var http = require('http');// 创建http servervar server = http.createServer(function (req, res) &#123; // body... console.log(req.url); if (req.url === '/' || req.url === '/index') &#123; // 表示请求网站首页 res.end('这是 index.html'); &#125; else if (req.url === '/login') &#123; // 表示请求登录页面 res.end('这是 login.html'); &#125; else if (req.url === '/register') &#123; // 表示请求注册页面 res.end('这是 register.html'); &#125; else if (req.url === '/list') &#123; // 表示请求列表页面 res.end('这是 list.html'); &#125; else &#123; // 表示请求的页面不存在 res.writeHead(404, 'Not Found'); res.end('Sorry, page not found.'); &#125;&#125;);// 监听端口的网络请求server.listen(9000, function () &#123; console.log('http://localhost:9000');&#125;); 案例7：通过 node.js 编写 http 服务程序 - 通过读取静态 HTML 文件来响应用户请求步骤： 创建index.html、login.html、register.html、list.html、404.html文件。 演示通过读取最简单的 HTML 文件来响应用户。 演示通过读取”具有引入外部CSS样式表”的HTML文件来响应用户。 演示通过读取”具有img标签”的HTML文件来响应用户。 注意： 1、注意在发送不同类型的文件时，要设置好对应的Content-Type Content-Type参考 OSChina Content-Type参考 MDN 2、HTTP状态码参考 w3org参考 w3schools参考 3、在html页面中写相对路径’./‘ 和 绝对路径 ‘/‘的含义 。 网页中的这个路径主要是告诉浏览器向哪个地址发起请求用的 ‘./‘ 表示本次请求从相对于当前页面的请求路径（即服务器返回当前页面时的请求路径）开始 ‘/‘ 表示请求从根目录开始 补充知识点： path 模块的 join() 方法 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// 1. 加载 http 模块var http = require('http');// 加载文件操作模块var fs = require('fs');// 加载path模块，这个模块主要用来处理各种路径。var path = require('path');// 2. 创建http servervar server = http.createServer(function (req, res) &#123; // 1. 获取用户请求的URL var url = req.url.toLowerCase(); // 2. 根据用户的不同请求，做出不同响应 if (url === '/' || url === '/index') &#123; // 读取index.html文件，把该文件响应给用户 fs.readFile(path.join(__dirname, 'index.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; res.writeHead(200, 'OK', &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); // res.setHeader('Content-Type', 'text/html; charset=utf-8'); res.end(data); &#125;); &#125; else if (url === '/login') &#123; // 读取login.html文件，把该文件响应给用户 fs.readFile(path.join(__dirname, 'login.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; res.writeHead(200, 'OK', &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); // res.setHeader('Content-Type', 'text/html; charset=utf-8'); res.end(data); &#125;); &#125; else if (url === '/register') &#123; // 读取register.html文件，把该文件响应给用户 fs.readFile(path.join(__dirname, 'register.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; res.writeHead(200, 'OK', &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); // res.setHeader('Content-Type', 'text/html; charset=utf-8'); res.end(data); &#125;); &#125; else if (url === '/404') &#123; // 读取register.html文件，把该文件响应给用户 fs.readFile(path.join(__dirname, '404.html'), function (err, data) &#123; if (err) &#123; throw err; &#125; res.writeHead(200, 'OK', &#123; 'Content-Type': 'text/html; charset=utf-8' &#125;); // res.setHeader('Content-Type', 'text/html; charset=utf-8'); res.end(data); &#125;); &#125; &#125;);// 3. 启动服务server.listen(9090, function () &#123; // body... console.log('please visit: http://localhost:9090');&#125;); 案例8：模拟 Apache 实现静态资源服务器步骤： 单独创建一个目录来实现，比如：创建一个”07-Apache”的目录。 在该目录下新建 public 目录，假设该目录为静态资源目录。 根据用户请求的路径在 public 目录下寻找对应路径下的资源。 如果找到了，那么将该资源返回给用户，如果没找到则返回404错误。 通过 mime 模块设置不同类型资源的Content-Type 实现完毕后把素材中的’An Ocean of Sky’ 和 ‘Hacker News’分别拷贝到静态资源目录下, 测试是否成功 其他： 介绍 NPM 介绍 mime 第三方模块 npm install mime 在代码中直接 var mime = require(&#39;mime&#39;) 参考代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172// 1. 加载对应模块// 1.1 加载http模块var http = require('http');// 1.2 加载path模块，方便路径拼接var path = require('path');// 1.3 加载文件读取模块var fs = require('fs');// 1.4 加载判断文件MIME类型的模块var mime = require('mime');// 2. 创建http servervar server = http.createServer();// 3. 监听用户request事件server.on('request', function (req, res) &#123; // 1. 获取用户的请求路径, 并转换为小写 var url = req.url.toLowerCase(); // 判断如果请求的路径是 '/' 那么等价于 '/index.html' url = (url === '/') ? '/index.html' : url; // 2. 根据用户请求的url路径, 去public目录下查找对应的静态资源文件。找到后读取该文件，并将结果返回给用户 // 2.1 根据用户请求的url拼接本地资源文件的路径 var filePath = path.join(__dirname, 'public', url); // 2.2 根据请求的文件路径设置Content-Type res.setHeader('Content-Type', mime.lookup(url)); // 2.2 根据路径去读取对应的文件 // 【注意】读取文件前无需判断文件是否已经存在，而是在读取文件的回调函数中根据error的错误信息来判断读取文件是否成功以及发生的错误 fs.readFile(filePath, function (err, data) &#123; // 判断是否有错误 if (err) &#123; if (err.code === 'ENOENT') &#123; // 判断是否是请求的文件是否不存在 res.setHeader('Content-Type', 'text/html; charset=utf8'); res.statusCode = 404; res.statusMessage = 'Not Found'; res.end('&lt;h1&gt;请求的资源不存在！&lt;/h1&gt;'); &#125; else if (err.code === 'EACCES') &#123; // 判断文件是否有访问权限 res.setHeader('Content-Type', 'text/html; charset=utf8'); res.statusCode = 403; res.statusMessage = 'Forbidden'; res.end('&lt;h1&gt;Permission denied！&lt;/h1&gt;'); &#125; else &#123; throw err; &#125; &#125; else &#123; // 如果没有错误则将读取到的文件返回给用户 res.statusCode = 200; res.statusMessage = 'OK'; res.end(data); &#125; &#125;)&#125;);// 4. 启动服务server.listen(9000, function () &#123; // body... console.log('server is running, please visit: http://localhost:9000');&#125;); Common System Errors - 常见错误号 EACCES (Permission denied) An attempt was made to access a file in a way forbidden by its file access permissions. 访问被拒绝 EADDRINUSE (Address already in use) An attempt to bind a server (net, http, or https) to a local address failed due to another server on the local system already occupying that address. 地址正在被使用（比如：端口号备占用） EEXIST (File exists) An existing file was the target of an operation that required that the target not exist. 文件已经存在 EISDIR (Is a directory) An operation expected a file, but the given pathname was a directory. 给定的路径是目录 ENOENT (No such file or directory) Commonly raised by fs operations to indicate that a component of the specified pathname does not exist – no entity (file or directory) could be found by the given path. 文件 或 目录不存在 ENOTDIR (Not a directory) A component of the given pathname existed, but was not a directory as expected. Commonly raised by fs.readdir. 给定的路径不是目录 同步文件操作 和 异步文件操作 fs.readFile(file[, options], callback) fs.readFileSync(file[, options]) 通过设置 http 响应报文头实现弹框下载功能 设置 Content-Type: application/octet-stream 设置 Content-Disposition: attachment; filename=demo.txt 七、node.js 学习资源1. 图书 《深入浅出Node.js》 作者：朴灵 《node.js 实战 中国程序员6》 2. 网站资源 CNODE社区 Node.js 简易教程 Node入门 Node.js包教不包会 CNODE-新手入门 其他参考链接 Node.js 究竟是什么？ Node.js是用来做什么的？ 什么是 node.js 3. Node.js 使用场景 &amp; 实战 Node.js雪球实战半年谈 雪球上的 Node.js 国内有哪些网站使用了 Node.js Node.js &amp; Uber Node.js 的优势和劣势 node.js的15个应用场景 How to decide when to use Node.js? 优缺点及适用场景讨论 Node.js 发展前景如何？适用于哪些场景？ Node.js企业开发 一应用场景 10个最佳Node.js企业应用案例：从Uber到LinkedIn 极速Node.js：来自LinkedIn的10个性能提升秘籍 为分布式应用做中转 前后端团队融合，节省成本 Node.js 简单高效 Node.js 是给前端用的，后端复杂的业务逻辑肯定不会用 Node.js 八、Node Version Manager（Node 版本管理器）nvm (Linux、Unix、OS X) https://github.com/creationix/nvm 产用命令： nvm install node （安装最新版本的node） nvm use node （使用指定版本的node） nvm-windows (Windows) https://github.com/coreybutler/nvm-windows 常用命令： nvm version nvm install latest nvm install 版本号 nvm uninstall 版本号 nvm list nvm use 版本号 九、Buffer思考：Buffer 类型产生的原因？主要用来解决什么问题？ 看一下什么是 Buffer? 什么是 Stream? 一、类型介绍 JavaScript 语言没有读取或操作二进制数据流的机制。 Node.js 中引入了 Buffer 类型使我们可以操作 TCP流 或 文件流。 Buffer 类型的对象类似于整数数组，但 Buffer 的大小是固定的、且在 V8 堆外分配物理内存。 Buffer 的大小在被创建时确定，且无法调整。（ buf.length 是固定的，不允许修改 ） Buffer 是全局的，所以使用的时候无需 require() 的方式来加载 二、如何创建一个 Buffer 对象常见的 API 介绍 创建一个 Buffer 对象 123456789101112// 1. 通过 Buffer.from() 创建一个 Buffer 对象// 1.1 通过一个字节数组来创建一个 Buffer 对象var array = [0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0xe4, 0xb8, 0x96, 0xe7, 0x95, 0x8c];var buf = Buffer.from(array);console.log(buf.toString('utf8'));// 1.2 通过字符串来创建一个 Buffer 对象// Buffer.from(string[, encoding])var buf = Buffer.from('你好世界！ Hello World!~');console.log(buf);console.log(buf.toString()); 拼接多个 Buffer 对象为一个对象 123// Buffer.concat(list[, totalLength])var bufferList = [];var buf = Buffer.concat(bufferList); 获取字符串对应的字节个数 1234// Buffer.byteLength(string[, encoding])var len = Buffer.byteLength('你好世界Hello', 'utf8');console.log(len); 判断一个对象是否是 Buffer 类型对象 1234// Buffer.isBuffer(obj)// obj &lt;Object&gt;// Returns: &lt;boolean&gt;// Returns true if obj is a Buffer, false otherwise. 获取 Buffer 中的某个字节 12// 根据索引获取 Buffer 中的某个字节（byte、octet）// buf[index] 6、获取 Buffer 对象中的字节的个数 12// buf.length// 注意：length 属性不可修改 已过时的 API 123456// 以下 API 已全部过时new Buffer(array)new Buffer(buffer)new Buffer(arrayBuffer[, byteOffset [, length]])new Buffer(size)new Buffer(string[, encoding]) 三、Buffer 对象与编码Node.js 目前支持的编码如下： ascii utf8 utf16le ucs2 是 utf16le 的别名 base64 latin1 binary 是 latin1 的别名 hex 用两位 16 进制来表示每个字节 示例代码： 123456var buf = Buffer.from('你好世界，Hello World！', 'utf8');console.log(buf.toString('hex'));console.log(buf.toString('base64'));console.log(buf.toString('utf8')); 四、思考：为什么会有 Buffer 类型？ Buffer 使用来临时存储一些数据（二进制数据） 当我们要把一大块数据从一个地方传输到另外一个地方的时候可以通过 Buffer 对象进行传输 通过 Buffer 每次可以传输小部分数据，直到所有数据都传输完毕。 五、补充 Stream Writable Stream 允许 node.js 写数据到流中 Readable Stream 允许 node.js 从流中读取数据 十、day1总结1、浏览器的基本概念 浏览器组成部分 浏览器的渲染引擎工作原理 浏览器访问服务器全过程 dns解析过程 2、node.js 介绍 node.js 是什么 node.js 特点 node.js 能做什么 3、通过 node.js 编写代码 REPL 通过创建 .js 文件来编写代码 4、通过 fs 模块进行文件读写 dirname、filename path 模块，用来对文件路径进行操作（path.join() 拼接路径） 5、全局模块 process console 6、创建 http 服务 加载 http 模块 创建 http 服务 监听 request 事件 开启服务 7、在用户的 request 事件中，必须要结束请求 。 res.end()8、服务器端通过用户不同请求（req.url），做出不同响应]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
      <tags>
        <tag>Nodejs笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包/沙箱/递归/深浅拷贝]]></title>
    <url>%2F2018%2F09%2F19%2F2018-09-19%2F</url>
    <content type="text"><![CDATA[重点闭包闭包的概念:函数A中,有一个函数B,函数B中可以访问函数A中定义的变量或者是数据,此时形成了闭包(这句话暂时不严谨)闭包的模式:函数模式的闭包,对象模式的闭包闭包的作用:缓存数据,延长作用域链闭包的优点和缺点:缓存数据闭包的应用//总结:如果想要缓存数据,就把这个数据放在外层的函数和里层的函数的中间位置//闭包的作用:缓存数据.优点也是缺陷,没有及时的释放//局部变量是在函数中,函数使用结束后,局部变量就会被自动的释放//闭包后,里面的局部变量的使用作用域链就会被延长 沙箱沙箱:环境,黑盒,在一个虚拟的环境中模拟真实世界,做实验,实验结果和真实世界的结果是一样,但是不会影响真实世界 递归递归:函数中调用函数自己,此时就是递归,递归一定要有结束的条件 浅拷贝:拷贝就是复制,就相当于把一个对象中的所有的内容,复制一份给另一个对象,直接复制,或者说,就是把一个对象的地址给了另一个对象,他们指向相同,两个对象之间有共同的属性或者方法,都可以使用 深拷贝:拷贝还是复制,深:把一个对象中所有的属性或者方法,一个一个的找到.并且在另一个对象中开辟相应的空间,一个一个的存储到另一个对象中 案例：闭包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;对自己狠点&lt;/title&gt; &lt;style&gt; ul &#123; list-style-type: none; &#125; li &#123; float: left; margin-left: 10px; &#125; img &#123; width: 200px; height: 180px; &#125; input &#123; margin-left: 30%; &#125; &lt;/style&gt; &lt;script&gt; //$永远都是24k纯帅的十八岁的杨哥$ &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;img src=&quot;images/ly.jpg&quot; alt=&quot;&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;赞(1)&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/lyml.jpg&quot; alt=&quot;&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;赞(1)&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/fj.jpg&quot; alt=&quot;&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;赞(1)&quot;&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=&quot;images/bd.jpg&quot; alt=&quot;&quot;&gt;&lt;br/&gt;&lt;input type=&quot;button&quot; value=&quot;赞(1)&quot;&gt;&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; //获取所有的按钮 //根据标签名字获取元素 function my$(tagName) &#123; return document.getElementsByTagName(tagName); &#125; //闭包缓存数据 function getValue() &#123; var value=2; return function () &#123; //每一次点击的时候,都应该改变当前点击按钮的value值 this.value=&quot;赞(&quot;+(value++)+&quot;)&quot;; &#125; &#125; //获取所有的按钮 var btnObjs=my$(&quot;input&quot;); //循环遍历每个按钮,注册点击事件 for(var i=0;i&lt;btnObjs.length;i++)&#123; //注册事件 btnObjs[i].onclick=getValue(); &#125;// var btnObjs=my$(&quot;input&quot;);// var value=1;// //循环遍历每个按钮// for(var i=0;i&lt;btnObjs.length;i++)&#123;//// //为每个按钮注册点击事件// btnObjs[i].onclick=function () &#123;// console.log(&quot;哈哈&quot;);// this.value=&quot;赞(&quot;+(value++)+&quot;)&quot;;// &#125;;// &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 沙箱12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;这是div&lt;/div&gt;&lt;div&gt;这是div&lt;/div&gt;&lt;div&gt;这是div&lt;/div&gt;&lt;p&gt;这是p&lt;/p&gt;&lt;p&gt;这是p&lt;/p&gt;&lt;p&gt;这是p&lt;/p&gt;&lt;script&gt; var getTag = 10; var dvObjs = 20; var pObjs = 30; (function () &#123; //根据标签名字获取元素 function getTag(tagName) &#123; return document.getElementsByTagName(tagName) &#125; //获取所有的div var dvObjs = getTag(&quot;div&quot;); for (var i = 0; i &lt; dvObjs.length; i++) &#123; dvObjs[i].style.border = &quot;2px solid pink&quot;; &#125; //获取所有的p var pObjs = getTag(&quot;p&quot;); for (var i = 0; i &lt; pObjs.length; i++) &#123; pObjs[i].style.border = &quot;2px solid pink&quot;; &#125; &#125;()); console.log(getTag); console.log(dvObjs); console.log(pObjs);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 递归1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;title&lt;/title&gt; &lt;script&gt; //求n个数字的和,5 计算1+2+3+4+5// var sum=0;// for(var i=1;i&lt;=5;i++)&#123;// sum+=i;// &#125;// console.log(sum); //递归实现:求n个数字的和 n=5---&gt; 5+4+3+2+1 //函数的声明// function getSum(x) &#123;// if(x==1)&#123;// return 1;// &#125;// return x+getSum(x-1);// &#125;// //函数的调用// console.log(getSum(5)); /* * * 执行过程: * 代码执行getSum(5)---&gt;进入函数,此时的x是5,执行的是5+getSum(4),此时代码等待 * 此时5+getSum(4),代码先不进行计算,先执行getSum(4),进入函数,执行的是4+getSum(3),等待, 先执行的是getSum(3),进入函数,执行3+getSum(2),等待,先执行getSum(2),进入函数,执行 2+getSum(1);等待, 先执行getSum(1),执行的是x==1的判断,return 1,所以, * 此时getSum(1)的结果是1,开始向外走出去 * 2+getSum(1) 此时的结果是:2+1 * 执行: * getSum(2)----&gt;2+1 * 3+getSum(2) 此时的结果是3+2+1 * 4+getSum(3) 此时的结果是4+3+2+1 * 5+getSum(4) 此时的结果是5+4+3+2+1 * * 结果:15 * * * * */ //递归案例:求一个数字各个位数上的数字的和: 123 ---&gt;6 ---1+2+3 //523 function getEverySum(x) &#123; if(x&lt;10)&#123; return x; &#125; //获取的是这个数字的个位数 return x%10+getEverySum(parseInt(x/10)); &#125; console.log(getEverySum(1364));//5 //递归案例:求斐波那契数列 function getFib(x) &#123; if(x==1||x==2)&#123; return 1 &#125; return getFib(x-1)+getFib(x-2); &#125; console.log(getFib(12)); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 浅考备123456789101112131415161718var obj1=&#123; age:10, sex:&quot;男&quot;, car:[&quot;奔驰&quot;,&quot;宝马&quot;,&quot;特斯拉&quot;,&quot;奥拓&quot;] &#125;; //另一个对象 var obj2=&#123;&#125;; //写一个函数,作用:把一个对象的属性复制到另一个对象中,浅拷贝 //把a对象中的所有的属性复制到对象b中 function extend(a,b) &#123; for(var key in a)&#123; b[key]=a[key]; &#125; &#125; extend(obj1,obj2); console.dir(obj2);//开始的时候这个对象是空对象 console.dir(obj1);//有属性 深拷贝1234567891011121314151617181920212223242526272829303132333435363738var obj1=&#123; age:10, sex:&quot;男&quot;, car:[&quot;奔驰&quot;,&quot;宝马&quot;,&quot;特斯拉&quot;,&quot;奥拓&quot;], dog:&#123; name:&quot;大黄&quot;, age:5, color:&quot;黑白色&quot; &#125; &#125;; var obj2=&#123;&#125;;//空对象 //通过函数实现,把对象a中的所有的数据深拷贝到对象b中 function extend(a,b) &#123; for(var key in a)&#123; //先获取a对象中每个属性的值 var item=a[key]; //判断这个属性的值是不是数组 if(item instanceof Array)&#123; //如果是数组,那么在b对象中添加一个新的属性,并且这个属性值也是数组 b[key]=[]; //调用这个方法，把a对象中这个数组的属性值一个一个的复制到b对象的这个数组属性中 extend(item,b[key]); &#125;else if(item instanceof Object)&#123;//判断这个值是不是对象类型的 //如果是对象类型的,那么在b对象中添加一个属性,是一个空对象 b[key]=&#123;&#125;; //再次调用这个函数,把a对象中的属性对象的值一个一个的复制到b对象的这个属性对象中 extend(item,b[key]); &#125;else&#123; //如果值是普通的数据,直接复制到b对象的这个属性中 b[key]=item; &#125; &#125; &#125; extend(obj1,obj2); console.dir(obj1); console.dir(obj2);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象案例表格排序--函数做返回值]]></title>
    <url>%2F2018%2F09%2F12%2F2018-09-12(2)%2F</url>
    <content type="text"><![CDATA[重点1.数组的创建，添加，调用，输出2.构造函数，原型方法添加，函数的调用3.函数做返回值做数组的排序4.元素的创建，添加，调用，获取，清除5.innerHtml的使用 效果 素材 案例代码Css (外部引入) style.css123456789101112131415161718192021222324252627/* * @Author: yhf * @Date: 2018-09-12 20:43:23 * @Last Modified by: yhf * @Last Modified time: 2018-09-12 23:23:48 *//* 初始化页面 */* &#123; padding: 0; margin: 0;&#125;/* 表格 */table &#123; position: relative; top: 100px; left: 100px; width: 800px;&#125;/* 表头 */th &#123; height: 50px; cursor: pointer;&#125;/* 表格 */td &#123; text-align: center;&#125; Html1&lt;table border="1" cellspacing="0" cellpadding="0"&gt;&lt;/table&gt; Js(外部引入) index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143/* * @Author: yhf * @Date: 2018-09-12 20:47:37 * @Last Modified by: yhf * @Last Modified time: 2018-09-12 23:16:19 */// 参数数组let movieArray = [&#123; img: "bianxingjingang.jpg", movieName: "变形金刚", star: "希亚·拉伯夫", direct: "迈克尔·贝", type: "d动作", time: "2007年07月03日"&#125;,&#123; img: "qiannvyouhun.jpg", movieName: "倩女幽魂", star: "张国荣", direct: "程小东", type: "j惊悚", time: "1987年7月18日"&#125;,&#123; img: "gongfu.jpg", movieName: "功夫", star: "周星驰", direct: "周星驰", type: "x喜剧", time: "2014年12月24日"&#125;,&#123; img: "suduyujiqing.jpg", movieName: "速度与激情", star: "保罗·沃克", direct: "罗伯·科恩", type: "d动作", time: "2015年4月3日"&#125;,&#123; img: "dahuaxiyou.jpg", movieName: "大话西游", star: "周星驰", direct: "刘镇伟", type: "a爱情", time: "2014年10月24日"&#125;];// 获取元素的函数function $my(date) &#123; return document.querySelector(date);&#125;;// 创建构造函数function Person(date) &#123; this.table = $my(date);&#125;;// 添加原型方法 初始化Person.prototype.init = function (date) &#123; // 初始化表头 this.initThead(); // 初始化表格内容 this.initTbody(date); this.initPx(date)&#125;;// 添加原型方法 添加表头Person.prototype.initThead = function () &#123; //先创建一个thead标签,创建tr-th,立刻加入到table中 var thead = document.createElement("thead"); // 给表头添加资料 thead.innerHTML = '&lt;tr&gt;&lt;th falg="img"&gt;影片&lt;/th&gt;&lt;th falg="star"&gt;主演&lt;/th&gt;&lt;th falg="direct"&gt;导演&lt;/th&gt;&lt;th falg="type"&gt;类别&lt;/th&gt;&lt;th falg="time"&gt;上映时间&lt;/th&gt;&lt;/tr&gt;'; // 添加到表格 this.table.appendChild(thead);&#125;;// 添加原型方法 添加表格内容 刷新页面Person.prototype.initTbody = function (date) &#123; // 刷新页面，判断有id等于tob的时候删除 if ($my("#tob")) &#123; this.table.removeChild($my("#tob")); &#125; // 创建tbody let tbody = document.createElement("tbody"); // 添加id tbody.id = "tob"; // 装数据的数组 let arr=[]; for (let i = 0; i &lt; date.length; i++) &#123; const ele = date[i]; // 把数组的数据拿出来添加到新的数组 arr.push("&lt;tr&gt;&lt;td&gt;&lt;img src=images/" + ele.img + "&gt; &lt;br /&gt;" + ele.movieName + "&lt;/td&gt;&lt;td&gt;" + ele.star + "&lt;/td&gt;&lt;td&gt;" + ele.direct + "&lt;/td&gt;&lt;td&gt;" + ele.type + "&lt;/td&gt;&lt;td&gt;" + ele.time + "&lt;/td&gt;&lt;/tr&gt;"); &#125; // 把新数组中的元素拿出来添加到tbody join是控制连接符 “”是空，表示没有链接符 tbody.innerHTML = arr.join(""); // 把tbody添加到表格里面 this.table.appendChild(tbody);&#125;;// 添加原型方法 数组排序Person.prototype.Szpx = function (date,attr) &#123; function fn(attr) &#123; return function (obj1,obj2) &#123; if (obj1[attr] &gt; obj2[attr]) &#123; return 1; &#125; else if (obj1[attr] == obj2[attr]) &#123; return 0; &#125; else &#123; return -1; &#125; &#125; &#125; let ff = fn(attr); date.sort(ff);&#125;// 添加原型方法 获取点击元素判断排序值Person.prototype.initPx = function (date) &#123; // 获取每一个表头的th let ths = document.querySelectorAll("th"); // 定义this let that = this; // 循环添加点击事件 for (let i = 0; i &lt; ths.length; i++) &#123; const ele = ths[i]; ele.onclick = function () &#123; // 获取定义值 let falg = this.getAttribute("falg"); // 调用数组排序方法 that.Szpx(date,falg); // 调用刷新页面 that.initTbody(date); &#125; &#125;&#125;// new实例对象let pr = new Person("table");// 调用实例的原型方法pr.init(movieArray);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apply/call/bind/函数]]></title>
    <url>%2F2018%2F09%2F12%2F2018-09-12%2F</url>
    <content type="text"><![CDATA[重点：apply/call 都可以改变 this 的指向apply 和 call 的使用方法apply 和 call 方法中如果没有传入参数,或者是传入的是 null,那么调用该方法的函数对象中的 this 就是默认的 window apply 的使用语法 函数名字.apply(对象,[参数 1,参数 2,…]); 方法名字.apply(对象,[参数 1,参数 2,…]); call 的使用语法 函数名字.call(对象,参数 1,参数 2,…); 方法名字.call(对象,参数 1,参数 2,…); 作用:改变 this 的指向 不同的地方:参数传递的方式是不一样的 只要是想使用别的对象的方法,并且希望这个方法是当前对象的,那么就可以使用 apply 或者是 call 的方法改变 this 的指向 bindbind 是用来复制一份使用的语法: 函数名字.bind(对象,参数 1,参数 2,…);—-&gt;返回值是复制之后的这个函数 方法名字.bind(对象,参数 1,参数 2,…);—-&gt;返回值是复制之后的这个方法 函数函数的值函数中有一个 name 属性—–&gt;函数的名字,name 属性是只读的,不能修改函数中有一个 arguments 属性—&gt;实参的个数函数中有一个 length 属性—-&gt;函数定义的时候形参的个数函数中有一个 caller 属性—-&gt;调用(f1 函数在 f2 函数中调用的,所以,此时调用者就是 f2)函数作为参数的时候,如果是命名函数,那么只传入命名函数的名字,没有括号函数可作为返回值 练习代码apply/call123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//案例一function Person(age,sex) &#123; this.age=age; this.sex=sex;&#125;//通过原型添加方法Person.prototype.sayHi=function (x,y) &#123; console.log("您好啊:"+this.sex); return 1000;&#125;;var per=new Person(10,"男");per.sayHi();console.log("==============");function Student(name,sex) &#123; this.name=name; this.sex=sex;&#125;var stu=new Student("小明","人妖");var r1=per.sayHi.apply(stu,[10,20]);var r2=per.sayHi.call(stu,10,20);console.log(r1);console.log(r2);//案例二function f1() &#123; console.log(this+":====&gt;调用了");&#125;//f1是函数,f1也是对象console.dir(f1);//对象调用方法,说明,该对象中有这个方法f1.apply();f1.call();console.log(f1.__proto__==Function.prototype);//所有的函数都是Function的实例对象console.log(Function.prototype);//ƒ () &#123; [native code] &#125;console.dir(Function);//apply和call方法实际上并不在函数这个实例对象中,而是在Function的prototype中function Person() &#123; this.sayHi=function () &#123; console.log("您好"); &#125;;&#125;Person.prototype.eat=function () &#123; console.log("吃");&#125;;var per=new Person();per.sayHi();per.eat();console.dir(per); bind123456789101112131415161718192021//通过对象,调用方法,产生随机数function ShowRandom() &#123; //1-10的随机数 this.number=parseInt(Math.random()*10+1);&#125;//添加原型方法ShowRandom.prototype.show1=function () &#123; //改变了定时器中的this的指向了,本来应该是window,现在是实例对象了 window.setInterval(this.show2.bind(this),1000);&#125;;//添加原型方法ShowRandom.prototype.show2=function () &#123; //显示随机数-- console.log(this.number);&#125;;//实例对象var sr=new ShowRandom();//调用方法,输出随机数字//调用这个方法一次,可以不停的产生随机数字sr.show1(); 函数函数作为参数使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061//案例一 function f1(fn) &#123; console.log("f1的函数"); fn();//此时fn当成是一个函数来使用的 &#125; //fn是参数,最后作为函数使用了,函数是可以作为参数使用 //传入匿名函数 f1(function () &#123; console.log("我是匿名函数"); &#125;); //命名函数 function f2() &#123; console.log("f2的函数"); &#125; f1(f2); //函数作为参数的时候,如果是命名函数,那么只传入命名函数的名字,没有括号//案例二 function f1(fn) &#123; setInterval(function () &#123; console.log("定时器开始"); fn(); console.log("定时器结束"); &#125;,1000); &#125; f1(function () &#123; console.log("好困啊,好累啊,就是想睡觉"); &#125;); //案例三 // var arr = [1, 100, 20, 200, 40, 50, 120, 10]; // //排序 // arr.sort(); // console.log(arr); var arr = [1, 100, 20, 200, 40, 50, 120, 10]; //排序---函数作为参数使用,匿名函数作为sort方法的参数使用,那么此时的匿名函数中有两个参数, arr.sort(function (obj1,obj2) &#123; if(obj1&gt;obj2)&#123; return -1; &#125;else if(obj1==obj2)&#123; return 0; &#125;else&#123; return 1; &#125; &#125;); console.log(arr); var arr1=["acdef","abcd","bcedf","bced"]; arr1.sort(function (a,b) &#123; if(a&gt;b)&#123; return 1; &#125;else if(a==b)&#123; return 0; &#125;else&#123; return -1; &#125; &#125;); console.log(arr1); 函数作为返回值使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//案例一//判断这个对象和传入的类型是不是同一个类型 function getFunc(type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === type; &#125; &#125; var ff = getFunc("[object Array]"); var result = ff([10, 20, 30]); console.log(result); var ff1 = getFunc("[object Object]"); var dt = new Date(); var result1 = ff1(dt); console.log(result1); //案例二 //排序,每个文件都有名字，大小,时间,都可以按照某个属性的值进行排序 //三部电影,电影有名字,大小,上映时间 function File(name, size, time) &#123; this.name = name;//电影名字 this.size = size;//电影大小 this.time = time;//电影的上映时间 &#125; var f1 = new File("jack.avi", "400M", "1997-12-12"); var f2 = new File("tom.avi", "200M", "2017-12-12"); var f3 = new File("xiaosu.avi", "800M", "2010-12-12"); var arr = [f1, f2, f3]; function fn(attr) &#123; //函数作为返回值 return function getSort(obj1, obj2) &#123; if (obj1[attr] &gt; obj2[attr]) &#123; return 1; &#125; else if (obj1[attr] == obj2[attr]) &#123; return 0; &#125; else &#123; return -1; &#125; &#125; &#125; var ff = fn("name"); //函数作为参数 arr.sort(ff); for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i].name + "====&gt;" + arr[i].size + "===&gt;" + arr[i].time); &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与继承，数组调用函数]]></title>
    <url>%2F2018%2F09%2F11%2F2018-09-11%2F</url>
    <content type="text"><![CDATA[数组的函数调用12345678910111213141516171819202122232425//数组可以存储任何类型的数据 var arr=[ function () &#123; console.log("十一假期快乐"); &#125;, function () &#123; console.log("十一假期开心"); &#125; , function () &#123; console.log("十一假期健康"); &#125; , function () &#123; console.log("十一假期安全"); &#125;, function () &#123; console.log("十一假期如意"); &#125; ]; //回调函数:函数作为参数使用 arr.forEach(function (ele) &#123; ele(); &#125;); 继承//面向对象特性:封装,继承,多态 //继承,类与类之间的关系,面向对象的语言的继承是为了多态服务的, //js不是面向对象的语言,但是可以模拟面向对象.模拟继承.为了节省内存空间 //继承: /* * 原型作用: 数据共享 ，目的是:为了节省内存空间, * 原型作用: 继承 目的是:为了节省内存空间 * * 原型继承:改变原型的指向 * 借用构造函数继承:主要解决属性的问题 * 组合继承:原型继承+借用构造函数继承 * 既能解决属性问题,又能解决方法问题 * 拷贝继承:就是把对象中需要共享的属性或者犯法,直接遍历的方式复制到另一个对象中 * */ 原型与原型链实例对象中proto是原型,浏览器使用的构造函数中的 prototype 是原型,程序员使用的原型链:是一种关系,实例对象和原型对象之间的关系,关系是通过原型(proto)来联系的 原型的指向是可以改变的实例对象中有proto原型构造函数中有 prototype 原型prototype 是对象所以,prototype 这个对象中也有proto,那么指向了哪里实例对象中的proto指向的是构造函数的 prototype所以,prototype 这个对象中proto指向的应该是某个构造函数的原型 prototype Person 的 prototype 中的proto的指向console.log(Person.prototype.proto); per 实例对象的proto——-&gt;Person.prototype 的proto—-&gt;Object.prototype 的proto是 null 1234567891011121314151617181920//人的构造函数 function Person(age) &#123; this.age=10; &#125; //人的原型对象方法 Person.prototype.eat=function () &#123; console.log("人的吃"); &#125;; //学生的构造函数 function Student() &#123; &#125; Student.prototype.sayHi=function () &#123; console.log("嗨,小苏你好帅哦"); &#125;; //学生的原型,指向了一个人的实例对象 Student.prototype=new Person(10); var stu=new Student(); stu.eat(); stu.sayHi(); 如何在原型改变了指向，中添加方法和访问如果原型指向改变了,那么就应该在原型改变指向之后添加原型方法 12345678910111213141516function Person(age) &#123; this.age = age; &#125; //指向改变了 Person.prototype = &#123; eat: function () &#123; console.log("吃"); &#125; &#125;; //先添加原型方法 Person.prototype.sayHi = function () &#123; console.log("您好"); &#125;; var per = new Person(10); per.sayHi(); 实例对象的属性和原型对象中的属性重名问题因为JS是一门动态类型的语言,对象没有什么,只要点了,那么这个对象就有了这个东西,没有这个属性,只要对象.属性名字,对象就有这个属性了,但是,该属性没有赋值,所以,结果是:undefined实例对象访问这个属性,应该先从实例对象中找,找到了就直接用，找不到就去指向的原型对象中找,找到了就使用,找不到呢?=====通过实例对象能否改变原型对象中的属性值?不能就想改变原型对象中属性的值,怎么办?直接通过原型对象.属性=值;可以改变123456789101112function Person(age,sex) &#123; this.age=age; this.sex=sex; &#125; Person.prototype.sex="女"; var per=new Person(10,"男"); console.log(per.sex); //因为JS是一门动态类型的语言,对象没有什么,只要点了,那么这个对象就有了这个东西,没有这个属性,只要对象.属性名字,对象就有这个属性了,但是,该属性没有赋值,所以,结果是:undefined console.log(per.fdsfdsfsdfds); console.log(fsdfdsfds); 继承* * 面向对象编程思想:根据需求,分析对象,找到对象有什么特征和行为,通过代码的方式来实现需求,要想实现这个需求,就要创建对象,要想创建对象,就应该显示有构造函数,然后通过构造函数来创建对象.,通过对象调用属性和方法来实现相应的功能及需求,即可 * 首先JS不是一门面向对象的语言,JS是一门基于对象的语言,那么为什么学习js还要学习面向对象,因为面向对象的思想适合于人的想法,编程起来会更加的方便,及后期的维护.... * 面向对象的编程语言中有类(class)的概念(也是一种特殊的数据类型),但是JS不是面向对象的语言,所以,JS中没有类(class),但是JS可以模拟面向对象的思想编程,JS中会通过构造函数来模拟类的概念(class) * * * * * 小明,小红，小丽，小白，小花 都是人 * 共同的特征和行为 * 特征---&gt;属性 * 行为---方法 * * 面向对象的特性:封装,继承,多态 * * 封装:就是包装 * 一个值存储在一个变量中--封装 * 一坨重复代码放在一个函数中--封装 * 一系列的属性放在一个对象中--封装 * 一些功能类似的函数(方法)放在一个对象中--封装 * 好多相类似的对象放在一个js文件中---封装 * * 继承: 首先继承是一种关系,类(class)与类之间的关系,JS中没有类,但是可以通过构造函数模拟类,然后通过原型来实现继承 * 继承也是为了数据共享,js中的继承也是为了实现数据共享 * * 原型作用之一:数据共享,节省内存空间 * 原型作用之二:为了实现继承 * * 继承是一种关系: * * 父类级别与类级别的关系 * * 例子: * * 小杨---&gt;人, 姓名, 有钱, 帅, 有功夫--降龙十八掌 * 小杨子--&gt;人, * 继承: * 姓氏----继承 * 外表----继承 * 财产----继承 * 功夫---继承 * * * 人: 姓名, 性别, 年龄 ,吃饭, 睡觉 * * 学生类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 学习行为 * 老师类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资,教学行为 * 程序员: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资, 敲代码 * 司机类别: 姓名, 性别, 年龄 ,吃饭, 睡觉 工资 开车 * * * 动物类别: 体重， 颜色, 吃 * 狗类别: 体重,颜色, 吃, 咬人 * 二哈类别: 体重,颜色, 吃, 咬人 逗主人开心,汪汪,你好帅 * * * * * * * 多态:一个对象有不同的行为,或者是同一个行为针对不同的对象,产生不同的结果,要想有多态,就要先有继承,js中可以模拟多态,但是不会去使用,也不会模拟, * * * * * * */ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384//例子://人,都有姓名,性别,年龄, 吃饭, 睡觉, 玩//学生,都有姓名,性别,年龄, 成绩, 吃饭, 睡觉, 玩 ,学习的行为//js中通过原型来实现继承function Person(name,age,sex) &#123; this.name=name; this.sex=sex; this.age=age;&#125;Person.prototype.eat=function () &#123; console.log("人可以吃东西");&#125;;Person.prototype.sleep=function () &#123; console.log("人在睡觉");&#125;;Person.prototype.play=function () &#123; console.log("生活就是不一样的玩法而已");&#125;;function Student(score) &#123; this.score=score;&#125;//改变学生的原型的指向即可==========&gt;学生和人已经发生关系Student.prototype=new Person("小明",10,"男");Student.prototype.study=function () &#123; console.log("学习很累很累的哦.");&#125;;//相同的代码太多,造成了代码的冗余(重复的代码)var stu=new Student(100);console.log(stu.name);console.log(stu.age);console.log(stu.sex);stu.eat();stu.play();stu.sleep();console.log("下面的是学生对象中自己有的");console.log(stu.score);stu.study();// 例子2//动物有名字,有体重,有吃东西的行为//小狗有名字,有体重,有毛色, 有吃东西的行为,还有咬人的行为//哈士奇名字,有体重,有毛色,性别, 有吃东西的行为,还有咬人的行为,逗主人开心的行为//动物的构造韩素function Animal(name,weight) &#123; this.name=name; this.weight=weight;&#125;//动物的原型的方法Animal.prototype.eat=function () &#123; console.log("天天吃东西,就是吃");&#125;;//狗的构造函数function Dog(color) &#123; this.color=color;&#125;Dog.prototype=new Animal("哮天犬","50kg");Dog.prototype.bitePerson=function () &#123; console.log("哼~汪汪~咬死你");&#125;;//哈士奇function ErHa(sex) &#123; this.sex=sex;&#125;ErHa.prototype=new Dog("黑白色");ErHa.prototype.playHost=function () &#123; console.log("哈哈~要坏衣服,要坏桌子,拆家..嘎嘎...好玩,开心不,惊喜不,意外不");&#125;;var erHa=new ErHa("雄性");console.log(erHa.name,erHa.weight,erHa.color);erHa.eat();erHa.bitePerson();erHa.playHost(); 借用构造函数//为了数据共享,改变原型指向,做到了继承—通过改变原型指向实现的继承//缺陷:因为改变原型指向的同时实现继承,直接初始化了属性，继承过来的属性的值都是一样的了,所以,这就是问题//只能重新调用对象的属性进行重新赋值, //解决方案:继承的时候,不用改变原型的指向,直接调用父级的构造函数的方式来为属性赋值就可以了——借用构造函数:把要继承的父级的构造函数拿过来,使用一下就可以了 //借用构造函数:构造函数名字.call(当前对象,属性,属性,属性….);//解决了属性继承,并且值不重复的问题//缺陷:父级类别中的方法不能继承 12345678910111213141516171819202122function Person(name, age, sex, weight) &#123; this.name = name; this.age = age; this.sex = sex; this.weight = weight; &#125; Person.prototype.sayHi = function () &#123; console.log("您好"); &#125;; function Student(name,age,sex,weight,score) &#123; //借用构造函数 Person.call(this,name,age,sex,weight); this.score = score; &#125; var stu1 = new Student("小明",10,"男","10kg","100"); console.log(stu1.name, stu1.age, stu1.sex, stu1.weight, stu1.score); var stu2 = new Student("小红",20,"女","20kg","120"); console.log(stu2.name, stu2.age, stu2.sex, stu2.weight, stu2.score); var stu3 = new Student("小丽",30,"妖","30kg","130"); console.log(stu3.name, stu3.age, stu3.sex, stu3.weight, stu3.score); 组合继承1234567891011121314151617181920212223242526272829303132//原型实现继承 //借用构造函数实现继承 //组合继承:原型继承+借用构造函数继承 function Person(name,age,sex) &#123; this.name=name; this.age=age; this.sex=sex; &#125; Person.prototype.sayHi=function () &#123; console.log("阿涅哈斯诶呦"); &#125;; function Student(name,age,sex,score) &#123; //借用构造函数:属性值重复的问题 Person.call(this,name,age,sex); this.score=score; &#125; //改变原型指向----继承 Student.prototype=new Person();//不传值 Student.prototype.eat=function () &#123; console.log("吃东西"); &#125;; var stu=new Student("小黑",20,"男","100分"); console.log(stu.name,stu.age,stu.sex,stu.score); stu.sayHi(); stu.eat(); var stu2=new Student("小黑黑",200,"男人","1010分"); console.log(stu2.name,stu2.age,stu2.sex,stu2.score); stu2.sayHi(); stu2.eat(); //属性和方法都被继承了 拷贝继承拷贝继承；把一个对象中的属性或者方法直接复制到另一个对象中12345678910111213141516function Person() &#123; &#125; Person.prototype.age=10; Person.prototype.sex="男"; Person.prototype.height=100; Person.prototype.play=function () &#123; console.log("玩的好开心"); &#125;; var obj2=&#123;&#125;; //Person的构造中有原型prototype,prototype就是一个对象,那么里面,age,sex,height,play都是该对象中的属性或者方法 for(var key in Person.prototype)&#123; obj2[key]=Person.prototype[key]; &#125; console.dir(obj2); obj2.play();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生贪吃蛇升级版]]></title>
    <url>%2F2018%2F09%2F10%2F2018-09-10%2F</url>
    <content type="text"><![CDATA[贪吃蛇升级版重点：1.添加了开始，停止，结束按钮，改变了启动和结束的方式，修复了游戏结束后不可以再次玩游戏2.改变了蛇的身体颜色，变成随机颜色3.修改了蛇头方向都变化不可以返回4.添加了蛇头碰到身体结束游戏5.初始化游戏6.添加了wasd键盘控制事件，添加了鼠标拖拽改变方向 效果 案例代码Css 外部引入style.css123456789101112131415161718192021222324252627282930* &#123; padding: 0; margin: 0;&#125;/* 蛇身体的长度和分数 */.df,.ssc &#123; position: absolute; top: 0px; left: 400px;&#125;.ssc &#123; left: 250px;&#125;/* 蛇地图的样式 */.wrap &#123; width: 800px; height: 600px; position: relative; top: 20px; left: 20px; background-color: #ccc;&#125;/* 游戏说明 */.yx &#123; position: absolute; margin: 40px; font-size: 20px; color: pink;&#125; Html1234567891011121314151617181920&lt;input type="button" value="开始游戏"&gt; &lt;input type="button" value="停止游戏"&gt; &lt;input type="button" value="结束游戏"&gt; &lt;div class="ssc"&gt; 蛇身的长度: 0 &lt;/div&gt; &lt;div class="df"&gt; 得分: 0 &lt;/div&gt; &lt;!-- 蛇地图 --&gt; &lt;div class="wrap"&gt; &lt;/div&gt; &lt;div class="yx"&gt; &lt;h3&gt;游戏说明：&lt;/h3&gt; 玩法：上下左右键控制，w上s下a左d右控制，鼠标上下左右拖拽&lt;br&gt; 点击开始游戏，开启游戏&lt;br&gt; 点击停止游戏，暂停游戏，点击开始游戏恢复继续玩&lt;br&gt; 点击结束游戏，停止游戏要点击开启游戏重新开始&lt;br&gt; &lt;/div&gt; Js外部引入食物 Food.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/* * @Author: yhf * @Date: 2018-09-10 12:36:12 * @Last Modified by: yhf * @Last Modified time: 2018-09-11 09:08:11 */(function () &#123; // 存放食物的数组 var elements = []; // 食物方法 function Food(x, y, height, width, color) &#123; // 食物的横纵坐标 this.x = x; this.y = y; // 食物的宽高 this.height = height || 20; this.width = width || 20; // 食物的颜色 this.color = color || "yellow"; &#125;; // 删除食物函数 function remove() &#123; var i = elements.length - 1; for (; i &gt;= 0; i--) &#123; var ele = elements[i]; // 从wrap删除 ele.parentNode.removeChild(ele); elements.splice(i, 1); &#125; &#125;; // 添加原型方法--初始化食物 Food.prototype.init = function (wrap) &#123; // 删除食物 remove(); // 创建食物 var div = document.createElement("div"); // 添加食物到地图 wrap.appendChild(div); // 设置食物div的样式 // div脱离文档流 div.style.position = "absolute"; // div宽高 div.style.width = this.width + "px"; div.style.height = this.height + "px"; // div颜色 div.style.backgroundColor = this.color; // 随机食物横纵坐标 this.x = parseInt(Math.random() * (wrap.offsetWidth / this.width)) * this.width; this.y = parseInt(Math.random() * (wrap.offsetHeight / this.height)) * this.height; // 设置食物横纵坐标 div.style.left = this.x + "px"; div.style.top = this.y + "px"; // 把新建的数组添加到食物数组中 elements.push(div); &#125;; // 添加原型方法清空食物 Food.prototype.empty = function () &#123; remove(); elements.splice(0, elements.length); &#125; // 把食物暴露给window，外界可以调用 window.Food = Food;&#125;()); 外部引入蛇 Snake.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/* * @Author: yhf * @Date: 2018-09-10 14:28:55 * @Last Modified by: yhf * @Last Modified time: 2018-09-11 08:28:31 */(function () &#123; // 存放蛇数组· var elements = []; // 蛇的函数 function Snake(width, height, direction) &#123; // 计算得分 this.df = 0; // 判断是否碰到身体 this.stfh = true; // 蛇的宽高 this.width = width || 20; this.height = height || 20; // 蛇身体 this.body = [&#123; x: 3, y: 2, color: "red" &#125;, &#123; x: 2, y: 2, color: "#00FFFF" &#125;, &#123; x: 1, y: 2, color: "pink" &#125;]; // 颜色 this.col = ["#F0F8FF", "#FAEBD7", "#F0F8FF", "#FAEBD7", "#00FFFF", "#7FFFD4", "#F0FFFF", "#F5F5DC", "#FFE4C4", "#000000", "#FFEBCD", "#0000FF", "#8A2BE2", "#A52A2A", "#DEB887", "#5F9EA0", "#7FFF00", "#D2691E", "#FF7F50", "#6495ED", "#FFF8DC", "#DC143C", "#00FFFF", "#00008B", "#008B8B", "#B8860B", "#A9A9A9", "#006400", "#BDB76B", "#8B008B", "#556B2F", "#FF8C00", "#9932CC", "#8B0000", "#E9967A", "#8FBC8F", "#483D8B", "#2F4F4F", "#00CED1", "#9400D3", "#FF1493", "#00BFFF", "#696969", "#1E90FF", "#D19275", "#B22222", "#FFFAF0", "#228B22", "#FF00FF", "#DCDCDC", "#F8F8FF", "#FFD700", "#DAA520", "#808080", "#008000", "#ADFF2F", "#F0FFF0", "#FF69B4", "#CD5C5C", "#4B0082", "#FFFFF0", "#F0E68C", "#E6E6FA", "#FFF0F5", "#7CFC00", "#FFFACD", "#ADD8E6", "#F08080", "#E0FFFF", "#FAFAD2", "#D3D3D3", "#90EE90", "#FFB6C1", "#FFA07A", "#20B2AA", "#87CEFA", "#8470FF", "#778899", "#B0C4DE", "#FFFFE0", "#00FF00", "#32CD32", "#FAF0E6", "#FF00FF", "#800000", "#66CDAA", "#0000CD", "#BA55D3", "#9370D8", "#3CB371", "#7B68EE", "#00FA9A", "#48D1CC", "#C71585", "#191970", "#F5FFFA", "#FFE4E1", "#FFE4B5", "#FFDEAD", "#000080", "#FDF5E6", "#808000", "#6B8E23", "#FFA500", "#FF4500", "#DA70D6", "#EEE8AA", "#98FB98", "#AFEEEE", "#D87093", "#FFEFD5", "#FFDAB9", "#CD853F", "#FFC0CB", "#DDA0DD", "#B0E0E6", "#800080", "#FF0000", "#BC8F8F", "#4169E1", "#8B4513", "#FA8072", "#F4A460", "#2E8B57", "#FFF5EE", "#A0522D", "#C0C0C0", "#87CEEB", "#6A5ACD", "#708090", "#FFFAFA", "#00FF7F", "#4682B4", "#D2B48C", "#008080", "#D8BFD8", "#FF6347", "#40E0D0", "#EE82EE", "#D02090", "#F5DEB3", "#FFFFFF", "#F5F5F5", "#FFFF00", "#9ACD32"]; // 蛇的行走方向 this.direction = direction || "right"; &#125;; // 添加原型初始化蛇 Snake.prototype.init = function (wrap) &#123; // 初始化删除蛇 remove(); // 循环创建蛇的身体 for (let i = 0; i &lt; this.body.length; i++) &#123; // 初始化this.body[i] const ele = this.body[i]; // 创建蛇 var div = document.createElement("div"); // 添加蛇到地图 wrap.appendChild(div); // div脱离文档流 div.style.position = "absolute"; // div宽高 div.style.width = this.width + "px"; div.style.height = this.height + "px"; // div颜色 div.style.backgroundColor = ele.color; // div横纵坐标 var x = this.width * ele.x; var y = this.height * ele.y; // 设置横纵坐标 div.style.left = x + "px"; div.style.top = y + "px"; // 添加到数组 elements.push(div); &#125; &#125;; // 添加原型方法--蛇动起来 Snake.prototype.move = function (food, wrap) &#123; // 获取到蛇身体数据 var i = this.body.length - 1; // 循环设置身体的变动位置，把蛇头以外，从蛇尾开始把前一位的数据获取到 for (; i &gt; 0; i--) &#123; this.body[i].x = this.body[i - 1].x; this.body[i].y = this.body[i - 1].y; &#125; // 判断键盘到移动改变蛇头到移动方向 switch (this.direction) &#123; case "right": this.body[0].x += 1; break; case "left": this.body[0].x -= 1; break; case "top": this.body[0].y -= 1; break; case "bottom": this.body[0].y += 1; break; &#125; // 获取蛇头到横纵坐标 var sx = this.body[0].x * this.width; var sy = this.body[0].y * this.height; // 判断蛇头是否吃到了食物 if (sx == food.x &amp;&amp; sy == food.y) &#123; var sjys = parseInt(Math.random() * this.col.length); for (let i = 0; i &lt; this.col.length; i++) &#123; const ele = this.col[i]; if (i == sjys) &#123; this.df++; // 获取到蛇的尾巴 var list = this.body[this.body.length - 1]; // 再蛇身体添加多一个身体值 this.body.push(&#123; x: list.x, y: list.y, color: ele &#125;); // 删除食物 food.init(wrap); &#125; &#125; // this.df++; // // 获取到蛇的尾巴 // var list = this.body[this.body.length - 1]; // // 再蛇身体添加多一个身体值 // this.body.push(&#123; // x: list.x, // y: list.y, // color: list.color // &#125;); // // 删除食物 // food.init(wrap); &#125; // 循环获取身体位置，把蛇头以外，从蛇尾开始把前一位的数据获取到，判断蛇头是否碰到身体，判断生死 for (var i = this.body.length - 1; i &gt; 0; i--) &#123; if (this.body[i].x * this.width == sx &amp;&amp; sy == this.body[i].y * this.height) &#123; this.stfh = false; &#125; &#125; &#125;; // 添加原型方法清空蛇 Snake.prototype.empty = function () &#123; remove(); elements.splice(0, elements.length); this.body = [&#123; x: 3, y: 2, color: "red" &#125;, &#123; x: 2, y: 2, color: "pink" &#125;, &#123; x: 1, y: 2, color: "pink" &#125;]; this.direction = "right"; &#125;; // 删除蛇函数 function remove() &#123; var i = elements.length - 1; for (; i &gt;= 0; i--) &#123; var ele = elements[i]; // 从wrap删除 ele.parentNode.removeChild(ele); // 删除数组中到蛇身 elements.splice(i, 1); &#125; &#125;; // 把Snake暴露给window window.Snake = Snake;&#125;()); 外部引入初始化 Game.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/* * @Author: yhf * @Date: 2018-09-10 15:37:16 * @Last Modified by: yhf * @Last Modified time: 2018-09-11 08:30:40 */(function () &#123; // 定义this var _this = null; // 键盘方向 var key = 39; // 定时器 var time = null; // 启动游戏构造函数 function Game() &#123; // 初始化食物 this.food = new Food(); // 初始化蛇 this.snake = new Snake(); // 定义画布 this.wrap = wrap; // 定义this _this = this; // 判断是否点击开始 this.bol = false; &#125;; // 添加原型启动游戏函数 Game.prototype.init = function () &#123; // 初始化食物 this.food.init(this.wrap); // 初始化蛇 this.snake.init(this.wrap); // 蛇动 this.runSnake(); // 键盘事件 this.keyDown(); &#125;; // 添加原型蛇动起来 Game.prototype.runSnake = function () &#123; // 添加名为time的定时器 time = setInterval(function () &#123; // 蛇动函数 this.snake.move(this.food, this.wrap); // 初始化蛇 this.snake.init(this.wrap); // 最大横纵坐标 --蛇最大可以移动的距离 var maxX = wrap.offsetWidth / this.snake.width; var maxY = wrap.offsetHeight / this.snake.height; // 获取蛇头部横纵坐标 var hearX = this.snake.body[0].x; var hearY = this.snake.body[0].y; // 判断是否碰到墙壁结束游戏 if (hearX &lt; 0 || hearX &gt;= maxX) &#123; // 清空函数 this.empty(); &#125;; if (hearY &lt; 0 || hearY &gt;= maxY) &#123; // 清空函数 this.empty(); &#125;; if (!this.snake.stfh) &#123; this.snake.stfh = true; this.empty(); &#125; df.innerHTML = "得分：" + this.snake.df; ssc.innerHTML = "蛇身长度：" + (this.snake.df + 2); &#125;.bind(_this), 150); &#125;; // 添加原型方法--键盘和鼠标事件 Game.prototype.keyDown = function () &#123; // document.addEventListener("keydown", function (e) &#123; // // 此时this应该是keydown的事件对象 // // 所以this就是document // // 获取按键值 // keyfn(this, e.keyCode); // &#125;.bind(_this), false); // 鼠标拖动控制方向 var dx = 0; //鼠标点击时的位置 var dy = 0; //鼠标点击时的位置 var sx = 0; //鼠标当前位置 var sy = 0; //鼠标当前位置 // 给页面添加监听事件 // 监听鼠标按下 document.onmousedown = function (e) &#123; bol = true; dx = e.clientX; dy = e.clientY; e.preventDefault(); &#125; // 鼠标移动 document.onmousemove = function (e) &#123; sx = e.clientX; sy = e.clientY; &#125; // 鼠标抬起 document.onmouseup = function () &#123; console.log(sx - dx) if (Math.abs(sx - dx) &gt; Math.abs(sy - dy)) &#123; if (sx - dx &gt; 0) &#123; keyfn(this, 39); &#125; else &#123; keyfn(this, 37); &#125; &#125; else if (sy - dy == 0) &#123; keyfn(this, 39); &#125; else &#123; if (sy - dy &gt; 0) &#123; keyfn(this, 40); &#125; else &#123; keyfn(this, 38); &#125; &#125; &#125;.bind(_this); // 给页面添加监听事件 // 监听键盘按下 document.onkeydown = function (e) &#123; keyfn(this, e.keyCode); &#125;.bind(_this); &#125;; // 添加原型-停止游戏 Game.prototype.stop = function () &#123; clearInterval(time); this.bol = false; &#125; // 添加原型-结束游戏 Game.prototype.empty = function () &#123; alert("游戏结束"); // 结束定时器 clearInterval(time); // 删除清空蛇 this.snake.empty(); // 删除清空食物 this.food.empty(); // 结束游戏 this.bol = false; // 清空得分 this.snake.df = 0; &#125; // 键盘事件 function keyfn(_this, keys) &#123; switch (keys) &#123; case 37: //左 if (key != 39 &amp;&amp; key != 68) &#123; _this.snake.direction = "left"; key = keys; &#125; break; case 38: //上 if (key != 40 &amp;&amp; key != 83) &#123; _this.snake.direction = "top"; key = keys; &#125; break; case 39: //右 if (key != 37 &amp;&amp; key != 65) &#123; _this.snake.direction = "right"; key = keys; &#125; break; case 40: //下 if (key != 38 &amp;&amp; key != 87) &#123; _this.snake.direction = "bottom"; key = keys; &#125; break; case 65: //左 if (key != 39 &amp;&amp; key != 68) &#123; _this.snake.direction = "left"; key = keys; &#125; break; case 87: //上 if (key != 40 &amp;&amp; key != 83) &#123; _this.snake.direction = "top"; key = keys; &#125; break; case 68: //右 if (key != 37 &amp;&amp; key != 65) &#123; _this.snake.direction = "right"; key = keys; &#125; break; case 83: //下 if (key != 38 &amp;&amp; key != 87) &#123; _this.snake.direction = "bottom"; key = keys; &#125; break; &#125; &#125; // 把Game暴露给window window.Game = Game;&#125;()); 外部引入开启 index.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* * @Author: yhf * @Date: 2018-09-10 23:45:57 * @Last Modified by: yhf * @Last Modified time: 2018-09-11 08:38:58 */// 获取定义的蛇地图const wrap = document.querySelector(".wrap");const btn = document.querySelectorAll("input");const df = document.querySelector(".df");const ssc = document.querySelector(".ssc");// 定义运动函数var gm = new Game(wrap);btn[0].onclick = function () &#123; // 判断点击了不可以再点击 if (gm.bol) &#123; return; &#125; // 开关 gm.bol = "true"; // 开启游戏 gm.init();&#125;btn[1].onclick = function () &#123; // 停止游戏 gm.stop();&#125;btn[2].onclick = function () &#123; // 未点击开始不可以点击 if (!gm.bol) &#123; return; &#125; // 结束游戏 gm.empty();&#125;/* * 后期添加项目： * 食物颜色改变不同的颜色，加的身体值不同 * 改关卡闯关 * 添加其他功能 * 未完待续。。。 * 手机事件 * */]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇案例]]></title>
    <url>%2F2018%2F09%2F10%2F2018-09-09%2F</url>
    <content type="text"><![CDATA[案例分析重点模拟贪吃蛇游戏,做的项目地图: 宽，高，背景颜色，因为小蛇和食物都是相对于地图显示的,这里小蛇和食物都是地图的子元素,随机位置显示,脱离文档流的,地图也需要脱离文档流–css需要设置:宽,高,背景颜色,脱标 食物—div元素elements—&gt;存储div的数组(将来删除的食物div时候,先从map中删除div,再从数组中移除div)食物:宽,高,背景颜色,横坐标,纵坐标一个食物就是一个对象,这个对象有相应的属性,这个对象需要在地图上显示最终要创建食物的对象,先 有构造函数,并且把相应的值作为参数传入到构造函数中食物要想显示在地图上,食物的初始化就是一个行为1.食物的构造函数—&gt;创建食物对象2.食物的显示的方法–&gt;通过对象调用方法,显示食物,设置相应的样式2.1.1 因为食物要被小蛇吃掉,吃掉后应该再次出现食物,原来的食物就删除了2.1.2 每一次初始化食物的时候先删除原来的食物,然后重新的初始化食物2.1.3 通过一个私有的函数(外面不能调用的函数)删除地图上的食物,同时最开始的时候食物也相应的保存到一个数组中,再从这个数组中把食物删除最后的时候,把食物的构造函数给window下的属性,这样做,外部就可以直接使用这个食物的构造函数了 小蛇小蛇就是一个对象属性: 每个身体都有宽，高，方向属性:身体分三个部分,每个部分都是一个对象,每个部分都有横纵坐标,背景颜色小蛇要想显示在地图上,先删除之前的小蛇,然后再初始化小蛇(小蛇要移动)–方法 小蛇要移动—方法思路:把小蛇的头的坐标给小蛇第一部分的身体,第一部分的身体的坐标给下一个部分身体小蛇的头,需要单独的设置:方向 案例效果 案例代码Css12345678910111213* &#123; padding: 0; margin: 0;&#125;.wrap &#123; width: 800px; height: 600px; background-color: #ccc; position: relative; top: 20px; left: 20px;&#125; Html1234&lt;!-- 贪吃蛇地图 --&gt;&lt;div class="wrap"&gt;&lt;/div&gt; Js (Js代码均为外部引入代码)引入代码一 food.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/* * @Author: yhf * @Date: 2018-09-10 00:04:58 * @Last Modified by: yhf * @Last Modified time: 2018-09-10 10:23:05 */// 食物就是一个对象，有宽高颜色，横纵坐标// 食物自调用(function () &#123; var elements = []; // 先有食物的对象 function Food(x, y, width, height, color) &#123; this.x = x; this.y = y; this.width = width || 20; this.height = height || 20; this.color = color || "green"; &#125;; // 私有函数--删除食物 function remove() &#123; for (let i = 0; i &lt; elements.length; i++) &#123; const ele = elements[i]; // 找到这个子元素的父级元素，删除 ele.parentNode.removeChild(ele); // 再次吧elements中的元素也要删除 elements.splice(i, 1); &#125; &#125; // 在原始添加初始化方法（作用：再页面上显示） // 因为食物要在地图上显示，所以需要在地图的这个参数（wrap--就是页面上的.class = wrap 的这个div） Food.prototype.init = function (wrap) &#123; // 先删除这个食物 // 外部无法访问 remove(); // 创建div var div = document.createElement("div"); // 把div添加到wrap上 wrap.appendChild(div); // 设置div的样式 div.style.width = this.width + "px"; div.style.height = this.height + "px"; div.style.backgroundColor = this.color; // 脱离文档流 div.style.position = "absolute"; // 随机横纵坐标 this.x = parseInt(Math.random() * (wrap.offsetWidth / this.width)) * this.width; this.y = parseInt(Math.random() * (wrap.offsetHeight / this.height)) * this.height; div.style.left = this.x + "px"; div.style.top = this.y + "px"; // 把div加入到数组中 elements.push(div); &#125;; // Food暴露给力windwo，外部可以使用 window.Food = Food;&#125;()); 引入代码二 Snake.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120/* * @Author: yhf * @Date: 2018-09-10 00:08:15 * @Last Modified by: yhf * @Last Modified time: 2018-09-10 00:11:02 */// 小蛇的自调函数(function () &#123; // 存放蛇 var elements = []; // 小蛇的构造函数 function Snake(width, height, direction) &#123; // 蛇的每个部分的宽 this.width = width || 20; this.height = height || 20; // 蛇的身体 this.body = [&#123; x: 3, y: 2, color: "red" &#125;, // 头 &#123; x: 2, y: 2, color: "orange" &#125;, // 身体 &#123; x: 1, y: 2, color: "orange" &#125; // 身体 ]; // 方向 this.direction = direction || "right"; &#125;; // 添加小蛇初始化方法 Snake.prototype.init = function (wrap) &#123; // 清理蛇 remove(); // 创建div for (let i = 0; i &lt; this.body.length; i++) &#123; const obj = this.body[i] // 创建div var div = document.createElement("div"); // 吧div加入到wrap wrap.appendChild(div); // 设置div样式 div.style.position = "absolute"; div.style.width = this.width + "px"; div.style.height = this.height + "px"; // 横纵坐标 div.style.left = obj.x * this.width + "px"; div.style.top = obj.y * this.height + "px"; // 背景颜色 div.style.backgroundColor = obj.color; // 把div加入到数组 elements.push(div); &#125; &#125;; // 小蛇动方法 Snake.prototype.move = function (food, wrap) &#123; // 改变小蛇身体坐标位置 var i = this.body.length - 1; for (; i &gt; 0; i--) &#123; this.body[i].x = this.body[i - 1].x; this.body[i].y = this.body[i - 1].y; &#125; // 判断方向--改变小蛇头位置 switch (this.direction) &#123; case "right": this.body[0].x += 1; break; case "left": this.body[0].x -= 1; break; case "top": this.body[0].y -= 1; break; case "bottom": this.body[0].y += 1; break; &#125; // 判断有没有吃到食物 // 蛇和食物的坐标一致 var headX = this.body[0].x * this.width; var headY = this.body[0].y * this.height; // 判断蛇的头的坐标和食物的坐标是否相同 if (headX == food.x &amp;&amp; headY == food.y) &#123; // 获取蛇的尾巴 var last = this.body[this.body.length - 1]; // 复制多一个 this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;); // 把食物删除 food.init(wrap); &#125; &#125;; // 删除小蛇都函数 function remove() &#123; // 获取数组 var i = elements.length - 1; for (; i &gt;= 0; i--) &#123; // 从当前元素找到父级元素删除 const ele = elements[i]; // 从wrap删除 ele.parentNode.removeChild(ele); elements.splice(i, 1); &#125; &#125; // 把Snake暴露给window window.Snake = Snake;&#125;()); 引入代码三 Game.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283/* * @Author: yhf * @Date: 2018-09-10 00:08:23 * @Last Modified by: yhf * @Last Modified time: 2018-09-10 00:08:23 */// 自调用封装游戏对象(function () &#123; var that = null; // 游戏构造函数 function Game() &#123; this.food = new Food(); // 食物对象 this.snake = new Snake(); // 蛇对象 this.wrap = wrap; // 地图 that = this; &#125;; Game.prototype.init = function () &#123; // 初始化游戏 // 食物初始化 this.food.init(this.wrap); // 小蛇初始化 this.snake.init(this.wrap); // 调用自动移动蛇方法 this.runSnake(this.food, this.wrap); // 调用按键方法 this.bindKey(); &#125;; // 添加原型，设小蛇跑起来 Game.prototype.runSnake = function (food, wrap) &#123; // 自动移动 var time = setInterval(function () &#123; // 此时this是window // 移动蛇 this.snake.move(food, wrap); // 初始化蛇 this.snake.init(wrap); // 横坐标的最大值 var maxX = wrap.offsetWidth / this.snake.width; var maxY = wrap.offsetHeight / this.snake.height; // 小蛇头坐标 var headX = this.snake.body[0].x; var headY = this.snake.body[0].y; // 横坐标 if (headX &lt; 0 || headX &gt;= maxX) &#123; // 撞墙，停止定时器 clearInterval(time); alert("游戏结束"); &#125; // 纵坐标 if (headY &lt; 0 || headY &gt;= maxY) &#123; // 撞墙，停止定时器 clearInterval(time); alert("游戏结束"); &#125; &#125;.bind(that), 150) &#125;; // 添加原型方法--设置用户按键 Game.prototype.bindKey = function () &#123; // 获取用户按键 document.addEventListener("keydown", function (e) &#123; // 此时this应该是keydown的事件对象 // 所以this就是document // 获取按键值 switch (e.keyCode) &#123; case 37: this.snake.direction = "left"; break; case 38: this.snake.direction = "top"; break; case 39: this.snake.direction = "right"; break; case 40: this.snake.direction = "bottom"; break; &#125; &#125;.bind(that), false); &#125;; window.Game = Game;&#125;()); 内部调用代码1234567891011121314// 方法一// 获取地图const wrap = document.querySelector(".wrap");// 初始化游戏对象var gm = new Game(wrap);// 开始游戏gm.init();// 方法二// 初始化游戏对象var gm = new Game(document.querySelector(".wrap"));// 开始游戏gm.init();]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义滚动条 两版本]]></title>
    <url>%2F2018%2F09%2F07%2F2018-09-07%2F</url>
    <content type="text"><![CDATA[重点版本一1.鼠标事件 （鼠标按下-&gt;鼠标移动-&gt;鼠标抬起）2.滚动条的高度计算3.滚动条的上下移动范围设置4.滚动条的移动设置5.阻止默认事件6.计算和设置文字的移动距离 版本二1.增加了滚动等功能2.事件的兼容问题解决 项目代码版本一Css123456789101112131415161718192021222324252627282930313233343536* &#123; padding: 0; margin: 0;&#125;.wrap &#123; width: 200px; height: 400px; border: 1px solid black; position: relative; top: 100px; left: 100px; overflow: hidden;&#125;.con &#123; padding: 5px 16px 5px 5px; font-size: 25px; position: relative; font-size: 14px;&#125;.gdt &#123; width: 15px; height: 100%; background: #ccc; position: absolute; right: 0; top: 0;&#125;.gd &#123; width: 15px; background-color: red; position: absolute;&#125; Html1234567891011&lt;div class="wrap"&gt; &lt;div class="con"&gt; start------ 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内 内容自己增加 ------end &lt;/div&gt; &lt;div class="gdt"&gt; &lt;div class="gd"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Js123456789101112131415161718192021222324252627282930313233343536373839404142434445window.onload = () =&gt; &#123; // 获取元素 // 外部div框架 let wrap = document.querySelector(".wrap"); // 文字div let con = document.querySelector(".con"); // 滚动条div--容器 let gdt = document.querySelector(".gdt"); // 滚动条 let gd = document.querySelector(".gd"); // 设置滚动条高度 // 滚动条/装滚动条的高=框架的高/文字的高 // 滚动条=装滚动条的高*框架的高/文字的高 let height = gdt.offsetHeight * wrap.offsetHeight / con.offsetHeight; if (height &lt; 30) &#123; height = 30; &#125; gd.style.height = height + "px"; // 移动滚动条 gd.onmousedown = (e) =&gt; &#123; let spaceY = e.clientY - gd.offsetTop; document.onmousemove = (e) =&gt; &#123; let y = e.clientY - spaceY; y = y &lt; 0 ? y = 0 : y; y = y &gt; gdt.offsetHeight - gd.offsetHeight ? y = gdt.offsetHeight - gd.offsetHeight : y; gd.style.top = y + "px"; //设置鼠标移动的时候,文字不被选中 window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty(); // 滚动条移动的距离/文字的距离=滚动最大的移动距离/文字最大的移动距离 // 文字的移动距离 = 滚动的移动距离*文字的最大移动距离/滚动条的最大移动距离 let moveY = y * (con.offsetHeight - wrap.offsetHeight) / (gdt.offsetHeight - gd.offsetHeight); // 设置文字的div距离 con.style.marginTop = -moveY + "px"; &#125; &#125; document.onmouseup = () =&gt; &#123; document.onmousemove = null; &#125; &#125; 版本二Css123456789101112131415161718192021222324252627.wrap&#123; width: 200px; height: 300px; border:5px solid black; position: relative; overflow: hidden;&#125;.con&#123; /*width: 185px;*/ padding-right: 15px; font-size: 25px; position: relative;&#125;.scroll&#123; width: 15px; height: 100%; background: #ccc; position: absolute; right: 0; top: 0;&#125;.scrollbar&#123; width: 15px; background: red; height: 50px; position: absolute;&#125; Html12345678910&lt;div class="wrap"&gt; &lt;div class="con"&gt; start------ 内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容内容 ------end &lt;/div&gt; &lt;div class="scroll"&gt; &lt;div class="scrollbar"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Js外部引入的js1234567891011121314151617181920212223function mousewheel(obj,callback) &#123;true//判断是否火狐浏览器trueif (navigator.userAgent.indexOf("Firefox")&gt;-1) &#123;truetrueobj.addEventListener("DOMMouseScroll",fn);//火狐滚轮事件true&#125;else&#123;truetrueobj.addEventListener("mousewheel",fn);//非火狐滚轮事件true&#125;truefunction fn(e) &#123;truetruevar e = e || window.event;truetrue//火狐 detail 上-3 下3truetrue//非火狐 wheelDelta 上120 下-120truetrue// false:下 true:上truetrueif (e.detail) &#123;truetruetrue//e.detail&lt;0判断往上还是往下滚动小于0是上truetruetruecallback.call(obj,e,e.detail&lt;0);truetrue&#125;else&#123;truetruetrue//e.wheelDelta&gt;0判断往上还是往下滚动大于0是上truetruetruecallback.call(obj,e,e.wheelDelta&gt;0); truetrue&#125;truetrue//阻止默认事件truetruee.preventDefault ? e.preventDefault() : (e.returnValue = false);true&#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697var wrap=document.querySelector(".wrap");var con=document.querySelector(".con");var scroll=document.querySelector(".scroll");var scrollbar=document.querySelector(".scrollbar");//计算滚动条的高度console.log(wrap.clientHeight);console.log(con.offsetHeight);var barH = wrap.clientHeight/con.offsetHeight*scroll.offsetHeight;if (barH&lt;50) &#123;barH=50&#125;scrollbar.style.height = barH + "px";var bol=false;var dy=0;scrollbar.onmousedown = function (e) &#123;truebol = true;//设置可以移动truedy = e.clientY-offsetFn(scrollbar).top;//计算鼠标和滚动条的位置差truetrue//阻止事件冒泡trueevent.stopPropagation ? event.stopPropagation() : (event.cancelBubble = true);true//阻止默认事件trueevent.preventDefault ? event.preventDefault() : (event.returnValue = false);&#125;scroll.onmousedown = function (e) &#123;truevar y = e.clientY-scrollbar.offsetHeight/2-13;truemove(y);&#125;document.onmousemove = function (e) &#123;trueif (bol) &#123;//判断是否可以移动truetruevar y = e.clientY-wrap.offsetTop-5-dy;truetruemove(y)true&#125;&#125;document.onmouseup = function () &#123;truebol = false;//设置不可以移动&#125;//移动滚动条和内容的函数function move(y) &#123;true//判断不可以超过父级框trueif(y&lt;0)&#123;y=0&#125;trueelse if (y&gt;scroll.offsetHeight-scrollbar.offsetHeight) &#123;truetruey=scroll.offsetHeight-scrollbar.offsetHeight;true&#125;truescrollbar.style.top = y + "px";//设置滚动条位置true// 内容可移动距离truevar conDy = con.offsetHeight-wrap.clientHeight;true// 滚动条可移动距离truevar scrollDy = scroll.offsetHeight-scrollbar.offsetHeight; truevar scale = conDy/scrollDy;//计算比例true//设置内容位置truecon.style.top = -y*scale + "px";&#125;// 滚轮事件mousewheel(wrap,function (e,bol) &#123;trueif (bol) &#123;//判断往上滚还是往下滚truetruey = scrollbar.offsetTop-10;true&#125;else&#123;truetruey = scrollbar.offsetTop+10;true&#125; truemove(y);//调用移动滚动条和内容的函数&#125;)//键盘控制滚动条移动document.onkeydown = function (e) &#123;true// console.log(e.keyCode)trueif (e.keyCode==38) &#123;//键盘上truetruey = scrollbar.offsetTop-10;true&#125;else if(e.keyCode==40)&#123;//键盘下truetruey = scrollbar.offsetTop+10;true&#125;truemove(y);//调用移动滚动条和内容的函数&#125;function offsetFn(obj) &#123;truevar l = obj.offsetLeft;//获取自己的lefttruevar t = obj.offsetTop;//获取自己的top trueobj = obj.offsetParent;//获取定位父级元素truewhile(obj)&#123;//判断有没有定位父级元素truetrue//加上定位父级的定位的left和toptruetruel += obj.offsetLeft + parseInt(getStyle(obj,"borderLeftWidth"));truetruet += obj.offsetTop + parseInt(getStyle(obj,"borderTopWidth")); truetrueobj = obj.offsetParent;//继续找定位父级true&#125;truereturn &#123;"left":l,"top":t&#125;;&#125;//获取计算后的样式function getStyle(obj,attr) &#123;trueif (obj.currentStyle) &#123;truetruereturn obj.currentStyle[attr];//IE获取方法true&#125;else&#123;truetruereturn getComputedStyle(obj,null)[attr];//非IE取方法true&#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始化css和阻止链接跳转]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05(3)%2F</url>
    <content type="text"><![CDATA[重点1.初始化解决h5和兼容问题 阻止跳转12345678let a = document.querySelector("a");a.onclick = (e) =&gt; &#123; // 方法一 // return false; // 方法二 // 不支持ie8 e.preventDefault();//阻止浏览器的默认事件&#125; 初始化css5.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463/*! normalize.css v5.0.0 | MIT License | github.com/necolas/normalize.css *//*http://necolas.github.io/normalize.css/*//** * 1. Change the default font family in all browsers (opinionated). * 2. Correct the line height in all browsers. * 3. Prevent adjustments of font size after orientation changes in * IE on Windows Phone and in iOS. *//* Document ========================================================================== */html &#123; font-family: sans-serif; /* 1 */ line-height: 1.15; /* 2 */ -ms-text-size-adjust: 100%; /* 3 */ -webkit-text-size-adjust: 100%; /* 3 */&#125;/* Sections ========================================================================== *//** * Remove the margin in all browsers (opinionated). */body &#123; margin: 0;&#125;/** * Add the correct display in IE 9-. */article,aside,footer,header,nav,section &#123; display: block;&#125;/** * Correct the font size and margin on `h1` elements within `section` and * `article` contexts in Chrome, Firefox, and Safari. */h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;/* Grouping content ========================================================================== *//** * Add the correct display in IE 9-. * 1. Add the correct display in IE. */figcaption,figure,main &#123; /* 1 */ display: block;&#125;/** * Add the correct margin in IE 8. */figure &#123; margin: 1em 40px;&#125;/** * 1. Add the correct box sizing in Firefox. * 2. Show the overflow in Edge and IE. */hr &#123; box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */pre &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/* Text-level semantics ========================================================================== *//** * 1. Remove the gray background on active links in IE 10. * 2. Remove gaps in links underline in iOS 8+ and Safari 8+. */a &#123; background-color: transparent; /* 1 */ -webkit-text-decoration-skip: objects; /* 2 */&#125;/** * Remove the outline on focused links when they are also active or hovered * in all browsers (opinionated). */a:active,a:hover &#123; outline-width: 0;&#125;/** * 1. Remove the bottom border in Firefox 39-. * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari. */abbr[title] &#123; border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */&#125;/** * Prevent the duplicate application of `bolder` by the next rule in Safari 6. */b,strong &#123; font-weight: inherit;&#125;/** * Add the correct font weight in Chrome, Edge, and Safari. */b,strong &#123; font-weight: bolder;&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */code,kbd,samp &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/** * Add the correct font style in Android 4.3-. */dfn &#123; font-style: italic;&#125;/** * Add the correct background and color in IE 9-. */mark &#123; background-color: #ff0; color: #000;&#125;/** * Add the correct font size in all browsers. */small &#123; font-size: 80%;&#125;/** * Prevent `sub` and `sup` elements from affecting the line height in * all browsers. */sub,sup &#123; font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;&#125;sub &#123; bottom: -0.25em;&#125;sup &#123; top: -0.5em;&#125;/* Embedded content ========================================================================== *//** * Add the correct display in IE 9-. */audio,video &#123; display: inline-block;&#125;/** * Add the correct display in iOS 4-7. */audio:not([controls]) &#123; display: none; height: 0;&#125;/** * Remove the border on images inside links in IE 10-. */img &#123; border-style: none;&#125;/** * Hide the overflow in IE. */svg:not(:root) &#123; overflow: hidden;&#125;/* Forms ========================================================================== *//** * 1. Change the font styles in all browsers (opinionated). * 2. Remove the margin in Firefox and Safari. */button,input,optgroup,select,textarea &#123; font-family: sans-serif; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */&#125;/** * Show the overflow in IE. * 1. Show the overflow in Edge. */button,input &#123; /* 1 */ overflow: visible;&#125;/** * Remove the inheritance of text transform in Edge, Firefox, and IE. * 1. Remove the inheritance of text transform in Firefox. */button,select &#123; /* 1 */ text-transform: none;&#125;/** * 1. Prevent a WebKit bug where (2) destroys native `audio` and `video` * controls in Android 4. * 2. Correct the inability to style clickable types in iOS and Safari. */button,html [type=&quot;button&quot;], /* 1 */[type=&quot;reset&quot;],[type=&quot;submit&quot;] &#123; -webkit-appearance: button; /* 2 */&#125;/** * Remove the inner border and padding in Firefox. */button::-moz-focus-inner,[type=&quot;button&quot;]::-moz-focus-inner,[type=&quot;reset&quot;]::-moz-focus-inner,[type=&quot;submit&quot;]::-moz-focus-inner &#123; border-style: none; padding: 0;&#125;/** * Restore the focus styles unset by the previous rule. */button:-moz-focusring,[type=&quot;button&quot;]:-moz-focusring,[type=&quot;reset&quot;]:-moz-focusring,[type=&quot;submit&quot;]:-moz-focusring &#123; outline: 1px dotted ButtonText;&#125;/** * Change the border, margin, and padding in all browsers (opinionated). */fieldset &#123; border: 1px solid #c0c0c0; margin: 0 2px; padding: 0.35em 0.625em 0.75em;&#125;/** * 1. Correct the text wrapping in Edge and IE. * 2. Correct the color inheritance from `fieldset` elements in IE. * 3. Remove the padding so developers are not caught out when they zero out * `fieldset` elements in all browsers. */legend &#123; box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */&#125;/** * 1. Add the correct display in IE 9-. * 2. Add the correct vertical alignment in Chrome, Firefox, and Opera. */progress &#123; display: inline-block; /* 1 */ vertical-align: baseline; /* 2 */&#125;/** * Remove the default vertical scrollbar in IE. */textarea &#123; overflow: auto;&#125;/** * 1. Add the correct box sizing in IE 10-. * 2. Remove the padding in IE 10-. */[type=&quot;checkbox&quot;],[type=&quot;radio&quot;] &#123; box-sizing: border-box; /* 1 */ padding: 0; /* 2 */&#125;/** * Correct the cursor style of increment and decrement buttons in Chrome. */[type=&quot;number&quot;]::-webkit-inner-spin-button,[type=&quot;number&quot;]::-webkit-outer-spin-button &#123; height: auto;&#125;/** * 1. Correct the odd appearance in Chrome and Safari. * 2. Correct the outline style in Safari. */[type=&quot;search&quot;] &#123; -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */&#125;/** * Remove the inner padding and cancel buttons in Chrome and Safari on macOS. */[type=&quot;search&quot;]::-webkit-search-cancel-button,[type=&quot;search&quot;]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;/** * 1. Correct the inability to style clickable types in iOS and Safari. * 2. Change font properties to `inherit` in Safari. */::-webkit-file-upload-button &#123; -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */&#125;/* Interactive ========================================================================== *//* * Add the correct display in IE 9-. * 1. Add the correct display in Edge, IE, and Firefox. */details, /* 1 */menu &#123; display: block;&#125;/* * Add the correct display in all browsers. */summary &#123; display: list-item;&#125;/* Scripting ========================================================================== *//** * Add the correct display in IE 9-. */canvas &#123; display: inline-block;&#125;/** * Add the correct display in IE. */template &#123; display: none;&#125;/* Hidden ========================================================================== *//** * Add the correct display in IE 10-. */[hidden] &#123; display: none;&#125; Css2 8.0123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331/*! normalize.css v8.0.0 | MIT License | github.com/necolas/normalize.css *//* Document ========================================================================== *//** * 1. Correct the line height in all browsers. * 2. Prevent adjustments of font size after orientation changes in iOS. */html &#123; line-height: 1.15; /* 1 */ -webkit-text-size-adjust: 100%; /* 2 */&#125;/* Sections ========================================================================== *//** * Remove the margin in all browsers. */body &#123; margin: 0;&#125;/** * Correct the font size and margin on `h1` elements within `section` and * `article` contexts in Chrome, Firefox, and Safari. */h1 &#123; font-size: 2em; margin: 0.67em 0;&#125;/* Grouping content ========================================================================== *//** * 1. Add the correct box sizing in Firefox. * 2. Show the overflow in Edge and IE. */hr &#123; box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */pre &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/* Text-level semantics ========================================================================== *//** * Remove the gray background on active links in IE 10. */a &#123; background-color: transparent;&#125;/** * 1. Remove the bottom border in Chrome 57- * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari. */abbr[title] &#123; border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */&#125;/** * Add the correct font weight in Chrome, Edge, and Safari. */b,strong &#123; font-weight: bolder;&#125;/** * 1. Correct the inheritance and scaling of font size in all browsers. * 2. Correct the odd `em` font sizing in all browsers. */code,kbd,samp &#123; font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */&#125;/** * Add the correct font size in all browsers. */small &#123; font-size: 80%;&#125;/** * Prevent `sub` and `sup` elements from affecting the line height in * all browsers. */sub,sup &#123; font-size: 75%; line-height: 0; position: relative; vertical-align: baseline;&#125;sub &#123; bottom: -0.25em;&#125;sup &#123; top: -0.5em;&#125;/* Embedded content ========================================================================== *//** * Remove the border on images inside links in IE 10. */img &#123; border-style: none;&#125;/* Forms ========================================================================== *//** * 1. Change the font styles in all browsers. * 2. Remove the margin in Firefox and Safari. */button,input,optgroup,select,textarea &#123; font-family: inherit; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */&#125;/** * Show the overflow in IE. * 1. Show the overflow in Edge. */button,input &#123; /* 1 */ overflow: visible;&#125;/** * Remove the inheritance of text transform in Edge, Firefox, and IE. * 1. Remove the inheritance of text transform in Firefox. */button,select &#123; /* 1 */ text-transform: none;&#125;/** * Correct the inability to style clickable types in iOS and Safari. */button,[type=&quot;button&quot;],[type=&quot;reset&quot;],[type=&quot;submit&quot;] &#123; -webkit-appearance: button;&#125;/** * Remove the inner border and padding in Firefox. */button::-moz-focus-inner,[type=&quot;button&quot;]::-moz-focus-inner,[type=&quot;reset&quot;]::-moz-focus-inner,[type=&quot;submit&quot;]::-moz-focus-inner &#123; border-style: none; padding: 0;&#125;/** * Restore the focus styles unset by the previous rule. */button:-moz-focusring,[type=&quot;button&quot;]:-moz-focusring,[type=&quot;reset&quot;]:-moz-focusring,[type=&quot;submit&quot;]:-moz-focusring &#123; outline: 1px dotted ButtonText;&#125;/** * Correct the padding in Firefox. */fieldset &#123; padding: 0.35em 0.75em 0.625em;&#125;/** * 1. Correct the text wrapping in Edge and IE. * 2. Correct the color inheritance from `fieldset` elements in IE. * 3. Remove the padding so developers are not caught out when they zero out * `fieldset` elements in all browsers. */legend &#123; box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */&#125;/** * Add the correct vertical alignment in Chrome, Firefox, and Opera. */progress &#123; vertical-align: baseline;&#125;/** * Remove the default vertical scrollbar in IE 10+. */textarea &#123; overflow: auto;&#125;/** * 1. Add the correct box sizing in IE 10. * 2. Remove the padding in IE 10. */[type=&quot;checkbox&quot;],[type=&quot;radio&quot;] &#123; box-sizing: border-box; /* 1 */ padding: 0; /* 2 */&#125;/** * Correct the cursor style of increment and decrement buttons in Chrome. */[type=&quot;number&quot;]::-webkit-inner-spin-button,[type=&quot;number&quot;]::-webkit-outer-spin-button &#123; height: auto;&#125;/** * 1. Correct the odd appearance in Chrome and Safari. * 2. Correct the outline style in Safari. */[type=&quot;search&quot;] &#123; -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */&#125;/** * Remove the inner padding in Chrome and Safari on macOS. */[type=&quot;search&quot;]::-webkit-search-decoration &#123; -webkit-appearance: none;&#125;/** * 1. Correct the inability to style clickable types in iOS and Safari. * 2. Change font properties to `inherit` in Safari. */::-webkit-file-upload-button &#123; -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */&#125;/* Interactive ========================================================================== *//* * Add the correct display in Edge, IE 10+, and Firefox. */details &#123; display: block;&#125;/* * Add the correct display in all browsers. */summary &#123; display: list-item;&#125;/* Misc ========================================================================== *//** * Add the correct display in IE 10+. */template &#123; display: none;&#125;/** * Add the correct display in IE 10. */[hidden] &#123; display: none;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[放大镜]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05(2)%2F</url>
    <content type="text"><![CDATA[重点1.鼠标事件2.offset系列，client系列3.数据 效果 素材 案例代码Css12345678910111213141516171819202122232425262728293031323334353637383940414243444546*&#123; padding: 0; margin: 0;&#125;/* 框架 */.wrap &#123; position: relative; margin: 100px;&#125;/* 小图框 */.min &#123; position: relative; width: 350px;&#125;/* 小图图片 */.min img &#123; width: 100%;&#125;/* 遮罩 */.min_wrap &#123; width: 175px; height: 175px; position: absolute; top: 0; left: 0; cursor: move; background-color: rgba(255,255,0,.4); display: none;&#125;/* 大图框 */.max_wrap &#123; border: 1px solid #000; position: absolute; top: 1px; left: 370px; width: 400px; height: 400px; overflow: hidden; display: none;&#125;.max_wrap img &#123; position: absolute; width: 800px;&#125; Html1234567891011&lt;div class="wrap"&gt; &lt;div class="min"&gt; &lt;img src="images/small.png" alt=""&gt; &lt;div class="min_wrap"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class="max_wrap"&gt; &lt;img src="images/big.jpg" alt=""&gt; &lt;/div&gt;&lt;/div&gt; Js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152window.onload = () =&gt; &#123; let wrap = document.querySelector(".wrap"); let min = document.querySelector(".min"); let min_img = document.querySelector(".min img"); let min_wrap = document.querySelector(".min_wrap"); let max_img = document.querySelector(".max_wrap img"); let max_wrap = document.querySelector(".max_wrap"); // 鼠标进入框架显示遮罩和大图 min.onmouseenter = () =&gt; &#123; min_wrap.style.display = "block"; max_wrap.style.display = "block"; &#125; // 鼠标离开框架隐藏遮罩和大图 min.onmouseleave = () =&gt; &#123; min_wrap.style.display = "none"; max_wrap.style.display = "none"; &#125; // 鼠标移动事件 wrap.onmousemove = e =&gt; &#123; // 兼容写法 var e = e || window.event; // 获取鼠标的移动位置 let x = e.clientX - wrap.offsetLeft - min_wrap.offsetWidth / 2; let y = e.clientY - wrap.offsetTop - min_wrap.offsetHeight / 2; // 判断不要超出框架 if (x &lt; 0) &#123; x = 0; &#125; else if (x &gt; min_img.offsetWidth - min_wrap.offsetWidth) &#123; x = min_img.offsetWidth - min_wrap.offsetWidth; &#125; if (y &lt; 0) &#123; y = 0; &#125; else if (y &gt; min_img.offsetHeight - min_wrap.offsetHeight) &#123; y = min_img.offsetHeight - min_wrap.offsetHeight; &#125; // 设置遮罩移动 min_wrap.style.left = x + "px"; min_wrap.style.top = y + "px"; // 计算比例 let bl = (max_img.offsetWidth-max_wrap.offsetWidth) / (min.offsetWidth - min_wrap.offsetWidth); // 设置大图移动 max_img.style.left = -x * bl + "px"; max_img.style.top = -y * bl + "px"; &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖拽对话框案例]]></title>
    <url>%2F2018%2F09%2F05%2F2018-09-05(1)%2F</url>
    <content type="text"><![CDATA[重点1.点击事件2.样式的改变3.鼠标事件4.client系列运用5.offset系列 效果图 案例代码Css12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/* 点击字 */.top &#123; text-align: center; font-size: 34px; cursor: pointer&#125;/* 背景遮罩层 */.bg &#123; width: 100%; height: 100%; position: fixed; top: 0px; left: 0px; background: #000; filter: alpha(opacity=30); -moz-opacity: 0.3; -khtml-opacity: 0.3; opacity: 0.3; display: none;&#125;/* 登录框 */.dl &#123; width: 500px; height: 250px; background-color: #fff; position: fixed; top: 200px; left: 50%; transform: translateX(-50%); display: none; z-index: 999; text-align: center; position: relative; padding: 10px;&#125;.gb &#123; width: 35px; line-height: 35px; border-radius: 50%; border: 1px solid #ccc; background-color: #fff; position: absolute; top: -10px; right: -10px; cursor: pointer;&#125;h3 &#123; cursor: move; font-weight: normal;&#125;.yh input &#123; display: inline-block; width: 350px; height: 35px; margin: 10px 0;&#125;.yh .txt &#123; margin-right: 15px;&#125;.hy&#123; width: 200px; line-height: 35px; border: 1px solid #ccc; margin: 10px auto;&#125; Html12345678910111213141516171819202122232425 &lt;div class="wrap"&gt; &lt;div class="top"&gt; 点击，弹出登陆框! &lt;/div&gt; &lt;/div&gt; &lt;!-- 登陆框 --&gt; &lt;div class="dl"&gt; &lt;div class="gb"&gt; 关闭 &lt;/div&gt; &lt;h3&gt;会员登陆&lt;/h3&gt; &lt;div class="yh"&gt;用户名：&lt;input type="text" placeholder="请输入用户名"&gt;&lt;br&gt;登陆密码：&lt;input type="text" placeholder="请输入登陆密码" class="txt"&gt; &lt;/div&gt; &lt;div class="hy"&gt; 登陆会员 &lt;/div&gt; &lt;/div&gt; &lt;!-- 遮罩层 --&gt; &lt;div class="bg"&gt; &lt;/div&gt; Js1234567891011121314151617181920212223242526272829303132333435363738394041window.onload = () =&gt; &#123; let dj = document.querySelector(".top"); let bg = document.querySelector(".bg"); let dl = document.querySelector(".dl"); let gb = document.querySelector(".gb"); let h = document.querySelector("h3"); dj.onclick = e =&gt; &#123; bg.style.display = "block"; dl.style.display = "block"; // window.event.cancelBubble = true; e.stopPropagation(); &#125;;// document.onclick = () =&gt; &#123;// bg.style.display = "none";// dl.style.display = "none";// &#125;; gb.onclick = () =&gt; &#123; bg.style.display = "none"; dl.style.display = "none"; &#125;; h.onmousedown = e =&gt; &#123; // 获取此时可视区域的横坐标 let spaceX = e.clientX - dl.offsetLeft; let spaceY = e.clientY - dl.offsetTop; // 移动事件 document.onmousemove = e =&gt; &#123; let x = e.clientX - spaceX; let y = e.clientY - spaceY; dl.style.left = x + "px"; dl.style.top = y + "px"; &#125;; &#125;; document.onmouseup = () =&gt; &#123; document.onmousemove = null; &#125;&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[旋转木马案例]]></title>
    <url>%2F2018%2F09%2F04%2F2018-09-04%2F</url>
    <content type="text"><![CDATA[重点难点1.数组的运用2.事件的添加3.逻辑关系 效果图 代码Css123456789101112131415161718192021222324252627282930313233343536373839404142@charset "UTF-8";/*初始化 reset*/blockquote,body,button,dd,dl,dt,fieldset,form,h1,h2,h3,h4,h5,h6,hr,input,legend,li,ol,p,pre,td,textarea,th,ul&#123;margin:0;padding:0&#125;body,button,input,select,textarea&#123;font:12px/1.5 "Microsoft YaHei", "微软雅黑", SimSun, "宋体", sans-serif;color: #666;&#125;ol,ul&#123;list-style:none&#125;a&#123;text-decoration:none&#125;fieldset,img&#123;border:0;vertical-align:top;&#125;a,input,button,select,textarea&#123;outline:none;&#125;a,button&#123;cursor:pointer;&#125;.wrap&#123; width:1200px; margin:100px auto;&#125;.slide &#123; height:500px; position: relative;&#125;.slide li&#123; position: absolute; left:200px; top:0;&#125;.slide li img&#123; width:100%;&#125;.arrow&#123; opacity: 0;&#125;.prev,.next&#123; width:76px; height:112px; position: absolute; top:50%; margin-top:-56px; background: url(../images/prev.png) no-repeat; z-index: 99;&#125;.next&#123; right:0; background-image: url(../images/next.png);&#125; Html123456789101112131415&lt;div class="wrap" id="wrap"&gt; &lt;div class="slide" id="slide"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/slidepic1.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/slidepic2.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/slidepic3.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/slidepic4.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#"&gt;&lt;img src="images/slidepic5.jpg" alt=""/&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="arrow" id="arrow"&gt; &lt;a href="javascript:;" class="prev" id="arrLeft"&gt;&lt;/a&gt; &lt;a href="javascript:;" class="next" id="arrRight"&gt;&lt;/a&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; Js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142window.onload = function () &#123; let slide = document.querySelector(".slide"); let li = document.querySelectorAll("li"); let arrow = document.querySelector(".arrow"); let prev = this.document.querySelector(".prev"); let next = this.document.querySelector(".next"); let bol = true; let arr = [&#123; width: 400, top: 20, left: 50, opacity: 0.2, zIndex: 2 &#125;, //0 &#123; width: 600, top: 70, left: 0, opacity: 0.8, zIndex: 3 &#125;, //1 &#123; width: 800, top: 100, left: 200, opacity: 1, zIndex: 4 &#125;, //2 &#123; width: 600, top: 70, left: 600, opacity: 0.8, zIndex: 3 &#125;, //3 &#123; width: 400, top: 20, left: 750, opacity: 0.2, zIndex: 2 &#125; //4 ]; // 封装的函数 // 判断浏览器是否自持方法，得到css返回值 function getStyle(element, attr) &#123; //判断浏览器是否支持这个方法 return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr]; &#125; // 封装点击事件移动函数 //设置任意的一个元素,移动到指定的目标位置 function fn(element, json, fn1) &#123; clearInterval(element.timeId); //定时器的id值存储到对象的一个属性中 element.timeId = setInterval(function () &#123; var flag = true; //判断目标到达 for (const attr in json) &#123; //判断这个属性attr中是不是opacity if (attr == "opacity") &#123; //获取元素的当前的透明度，放大一百倍 var current = getStyle(element, attr) * 100; // 当前属性对应的目标值,放大一百倍 var target = json[attr] * 100; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //当前移动到位置 current += step; element.style[attr] = current / 100; &#125; else if (attr == "zIndex") &#123; //判断这个属性attr中是不是zIndex element.style[attr] = json[attr]; &#125; else &#123; //获取元素的当前的位置,数字类型 var current = parseInt(getStyle(element, attr)); // 当前属性对应的目标值 var target = json[attr]; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //当前移动到位置 current += step; element.style[attr] = current + "px"; &#125; if (current != target) &#123; flag = false; &#125; &#125; if (flag) &#123; //清理定时器 clearInterval(element.timeId); // 所有属性到达目标后才能使用，并且用户有输入函数 if (fn1) &#123; fn1(); &#125; &#125; &#125;, 20); &#125; fs = () =&gt; &#123; for (let i = 0; i &lt; li.length; i++) &#123; fn(li[i], arr[i], () =&gt; &#123; bol = true; &#125;); &#125; &#125; fs(); // 左 prev.onclick = () =&gt; &#123; if (bol) &#123; bol = false; arr.unshift(arr.pop()); fs(); &#125; &#125; // 右 next.onclick = () =&gt; &#123; if (bol) &#123; bol = false; arr.push(arr.shift()); fs(); &#125; &#125; slide.onmouseover = () =&gt; &#123; fn(arrow, &#123; "opacity": 1 &#125;) &#125; slide.onmouseout = () =&gt; &#123; fn(arrow, &#123; "opacity": 0 &#125;) &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手风琴案例]]></title>
    <url>%2F2018%2F09%2F03%2F2018-09-03%2F</url>
    <content type="text"><![CDATA[重点1.获取计算后样式函数2.封装的变速移动函数3.获取加载图片4.添加鼠标进入事件5.添加鼠标移出事件 效果图 素材 案例代码Css1234567891011121314151617181920212223242526ul &#123; list-style: none;&#125;* &#123; margin: 0; padding: 0;&#125;div &#123; width: 1150px; height: 400px; margin: 50px auto; border: 1px solid red; overflow: hidden;&#125;div li &#123; width: 240px; height: 400px; float: left;&#125;div ul &#123; width: 1300px;&#125; Html123456789&lt;div id="box"&gt;&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;s&lt;/ul&gt;&lt;/div&gt; Js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788 let li = document.querySelectorAll("li");// 封装的函数// 判断浏览器是否自持方法，得到css返回值function getStyle(element, attr) &#123; //判断浏览器是否支持这个方法 return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr];&#125;// 封装点击事件移动函数//设置任意的一个元素,移动到指定的目标位置function fn(element, json, fn1) &#123; clearInterval(element.timeId); //定时器的id值存储到对象的一个属性中 element.timeId = setInterval(function () &#123; var flag = true; //判断目标到达 for (const attr in json) &#123; //判断这个属性attr中是不是opacity if (attr == "opacity") &#123; //获取元素的当前的透明度，放大一百倍 var current = getStyle(element, attr) * 100; // 当前属性对应的目标值,放大一百倍 var target = json[attr] * 100; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //当前移动到位置 current += step; element.style[attr] = current / 100; &#125; else if (attr == "zIndex") &#123; //判断这个属性attr中是不是zIndex element.style[attr] = json[attr]; &#125; else &#123; //获取元素的当前的位置,数字类型 var current = parseInt(getStyle(element, attr)); // 当前属性对应的目标值 var target = json[attr]; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //当前移动到位置 current += step; element.style[attr] = current + "px"; &#125; if (current != target) &#123; flag = false; &#125; &#125; if (flag) &#123; //清理定时器 clearInterval(element.timeId); // 所有属性到达目标后才能使用，并且用户有输入函数 if (fn1) &#123; fn1(); &#125; &#125; &#125;, 20);&#125;// 加载图片for (let i = 0; i &lt; li.length; i++) &#123; li[i].style.backgroundImage = "url(images/" + (i + 1) + ".jpg)"; // 鼠标进入 li[i].onmouseover = fn1; // 鼠标离开 li[i].onmouseout = fn2; function fn1() &#123; for (let j = 0; j &lt; li.length; j++) &#123; fn(li[j], &#123; "width": 100 &#125;); //动画效果 &#125; fn(this, &#123; "width": 800 &#125;) &#125; function fn2() &#123; for (let j = 0; j &lt; li.length; j++) &#123; fn(li[j], &#123; "width": 235 &#125;); //动画效果 &#125; &#125; &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取计算后的样式/封装变速移动函数]]></title>
    <url>%2F2018%2F09%2F01%2F2018-09-02%2F</url>
    <content type="text"><![CDATA[重点：获取计算后函数1.获取计算后的 css 样式（返回值为 css 的一个对象包含所有的 css 元素）2.封装兼容代码兼容：谷歌,火狐支持console.log(window.getComputedStyle(dv,null).left);IE8 支持console.log(dv.currentStyle.left); 封装变速移动函数1.理清思路2.传入元素，对象，函数3.判断 opacity 和 zindex4.获取元素位置等数据5.可以设置移动，大小，透明度，层级6.配合获取后样式用，未优化 封装代码获取计算后样式代码123456// 判断浏览器是否自持方法，得到css返回值// 未设置的css样式会返回auto或者0function getStyle(element, attr) &#123; //判断浏览器是否支持这个方法 return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr];&#125; 封装变速移动函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 判断浏览器是否自持方法，得到css返回值function getStyle(element, attr) &#123; //判断浏览器是否支持这个方法 return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr];&#125;// 封装点击事件移动函数//设置任意的一个元素,移动到指定的目标位置fn = (element, json, fn1) =&gt; &#123; clearInterval(element.timeId); //定时器的id值存储到对象的一个属性中 element.timeId = setInterval(function () &#123; let flag = true; //判断目标到达 for (const attr in json) &#123; //判断这个属性attr中是不是opacity if (attr == "opacity") &#123; //获取元素的当前的透明度，放大一百倍 var current = getStyle(element, attr) * 100; // 当前属性对应的目标值,放大一百倍 var target = json[attr] * 100; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //当前移动到位置 current += step; element.style[attr] = current / 100; &#125; else if (attr == "zIndex") &#123; //判断这个属性attr中是不是zIndex element.style[attr] = json[attr]; &#125; else &#123; //获取元素的当前的位置,数字类型 var current = parseInt(getStyle(element, attr)); // 当前属性对应的目标值 var target = json[attr]; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //当前移动到位置 current += step; element.style[attr] = current + "px"; &#125; if (current != target) &#123; flag = false; &#125; console.log("测试代码：当前元素" + attr + "当前位置" + current + " 目标值" + target); &#125; if (flag) &#123; //清理定时器 clearInterval(element.timeId); // 所有属性到达目标后才能使用，并且用户有输入函数 if (fn1) &#123; fn1(); &#125; &#125; &#125;, 20);&#125; 小案例代码获取计算后样式Css1234567.dv &#123; width: 200px; height: 200px; position: absolute; left: 100px; background-color: pink;&#125; Html1234&lt;input type="button" value="点击"&gt;&lt;div class="dv"&gt;&lt;/div&gt; Js1234567891011121314151617181920212223let btn = document.querySelector("input");let dv = document.querySelector(".dv");// //谷歌,火狐支持// //console.log(window.getComputedStyle(dv,null).left);//// //console.log(window.getComputedStyle(dv,null)["left"]);// //IE8支持// //console.log(dv.currentStyle.left);// 判断浏览器是否自持方法，得到css返回值// 未设置的css样式会返回auto或者0function getStyle(element, attr) &#123; //判断浏览器是否支持这个方法 return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr];&#125;btn.onclick = () =&gt; &#123; console.log(getStyle(dv,"left")); console.log(getStyle(dv,"backgroundColor"));&#125; 封装变速移动小案例Css12345678910111213141516171819* &#123; padding: 0; margin: 0;&#125;div &#123; position: absolute; top: 0; left: 0; width: 200px; height: 200px; background-color: pink;&#125;input &#123; z-index: 10; position: absolute; top: 0; left: 0;&#125; Html1234&lt;input type="button" value="移动"&gt;&lt;div&gt;&lt;/div&gt; Js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107let btn = document.querySelector("input"); let dv = document.querySelector("div"); // 判断浏览器是否自持方法，得到css返回值 function getStyle(element, attr) &#123; //判断浏览器是否支持这个方法 return window.getComputedStyle ? window.getComputedStyle(element, null)[attr] : element.currentStyle[attr]; &#125; // 封装点击事件移动函数 //设置任意的一个元素,移动到指定的目标位置 fn = (element, json, fn1) =&gt; &#123; clearInterval(element.timeId); //定时器的id值存储到对象的一个属性中 element.timeId = setInterval(function () &#123; let flag = true; //判断目标到达 for (const attr in json) &#123; //判断这个属性attr中是不是opacity if (attr == "opacity") &#123; //获取元素的当前的透明度，放大一百倍 var current = getStyle(element, attr) * 100; // 当前属性对应的目标值,放大一百倍 var target = json[attr] * 100; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //当前移动到位置 current += step; element.style[attr] = current / 100; &#125; else if (attr == "zIndex") &#123; //判断这个属性attr中是不是zIndex element.style[attr] = json[attr]; &#125; else &#123; //获取元素的当前的位置,数字类型 var current = parseInt(getStyle(element, attr)); // 当前属性对应的目标值 var target = json[attr]; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); //当前移动到位置 current += step; element.style[attr] = current + "px"; &#125; if (current != target) &#123; flag = false; &#125; console.log("测试代码：当前元素" + attr + "当前位置" + current + " 目标值" + target); &#125; if (flag) &#123; //清理定时器 clearInterval(element.timeId); // 所有属性到达目标后才能使用，并且用户有输入函数 if (fn1) &#123; fn1(); &#125; &#125; &#125;, 20); &#125; btn.onclick = () =&gt; &#123; let json = &#123; width: 800, height: 400, left: 500, top: 600, opacity: 0.2 &#125; let json1 = &#123; width: 20, height: 40, left: 0, top: 0, opacity: 0.8, zIndex:1000 &#125; // fn(dv, json) // let date1 = &#123; // "width": 800, // "height": 400, // "left": 500, // "top": 600 // &#125;; // fn(dv, date1, () =&gt; &#123; // let date2 = &#123; // "width": 80, // "height": 40, // "left": 50, // "top": 60 // &#125; // fn(dv, date2, () =&gt; &#123; // let date3 = &#123; // "width": 400, // "height": 200, // "left": 300, // "top": 100 // &#125; // fn(dv, date3) // &#125;) // &#125;); fn(dv, json, () =&gt; &#123; fn(dv,json1) &#125;) &#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[固定导航栏/筋斗云案例]]></title>
    <url>%2F2018%2F09%2F01%2F2018-09-01%2F</url>
    <content type="text"><![CDATA[重点难点/功能:一、固定导航栏1.获取页面向上向下卷曲的距离值2.兼容性3.window 的滚动事件4.更改样式5.判断向上卷曲出去的距离和最上面的 div 的高度对比6.设置后面的元素值防止有跳的效果7.回值时的元素设置8.固定浏览器在向下滑动时标题栏还在顶部，随着浏览器的上下滑动而改变 二、筋斗云1.循环遍历给元素添加事件（鼠标进出，点击）2.调用封装的函数3.es6 写法与 es5 写法的小问题4.鼠标进入时使用变速动画快速的滑动到鼠标位置5.鼠标离开时自动回复到上一次的位子6.当鼠标点击时就会记录位子最为父级位置返回去 效果图固定导航栏图 筋斗云图 素材固定导航栏 筋斗云 固定导航栏案例代码Css123456789101112131415161718192021* &#123; margin: 0; padding: 0&#125;img &#123; vertical-align: top;&#125;.main &#123; margin: 0 auto; width: 1000px; margin-top: 10px;&#125;.fixed &#123; position: fixed; top: 0; left: 0;&#125; Html123456789&lt;div class="top" id="topPart"&gt; &lt;img src="images/top.png" alt="" /&gt;&lt;/div&gt;&lt;div class="nav" id="navBar"&gt; &lt;img src="images/nav.png" alt="" /&gt;&lt;/div&gt;&lt;div class="main" id="mainPart"&gt; &lt;img src="images/main.png" alt="" /&gt;&lt;/div&gt; Js123456789101112131415161718192021222324 let topPart = document.querySelector("#topPart");let navBar = document.querySelector("#navBar");//获取页面向上或者向左卷曲出去的距离的值getScroll = () =&gt; &#123; return &#123; left: window.pageXOffset || document.documentElement.scrollLeft || document.body.scrollLeft || 0, top: window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0 &#125;;&#125;// 滚动事件window.onscroll = () =&gt; &#123; //向上卷曲出去的距离和最上面的div的高度对比 if (getScroll().top &gt;= topPart.offsetHeight) &#123; //设置第二个div的类样式 navBar.className = "nav fixed" //设置第三个div的marginTop的值 topPart.style.marginTop = navBar.offsetHeight + "px"; &#125; else &#123; navBar.className = "nav" topPart.style.marginTop = 10 + "px"; &#125;&#125; 筋斗云案例代码Css1234567891011121314151617181920212223242526272829303132333435363738394041424344* &#123; margin: 0; padding: 0&#125;ul &#123; list-style: none&#125;body &#123; background-color: #333;&#125;.nav &#123; width: 800px; height: 42px; margin: 100px auto; background: url(images/rss.png) right center no-repeat; background-color: #fff; border-radius: 10px; position: relative;&#125;.nav li &#123; width: 83px; height: 42px; text-align: center; line-height: 42px; float: left; cursor: pointer;&#125;.nav span &#123; position: absolute; top: 0; left: 0; width: 83px; height: 42px; background: url(images/cloud.gif) no-repeat;&#125;ul &#123; position: relative;&#125; Html12345678910111213&lt;div class="nav"&gt; &lt;span id="cloud"&gt;&lt;/span&gt; &lt;ul id="navBar"&gt; &lt;li&gt;北京校区&lt;/li&gt; &lt;li&gt;上海校区&lt;/li&gt; &lt;li&gt;广州校区&lt;/li&gt; &lt;li&gt;深圳校区&lt;/li&gt; &lt;li&gt;武汉校区&lt;/li&gt; &lt;li&gt;关于我们&lt;/li&gt; &lt;li&gt;联系我们&lt;/li&gt; &lt;li&gt;招贤纳士&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; Js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556let cloud = document.querySelector("#cloud");let li = document.querySelectorAll("#navBar li");// es6 es6中的this调用的是windwo并不是调用当前的this// mouseoverHandle = () =&gt; &#123;// fn(cloud, this.offsetLeft)// console.log(this);// console.log(this.offsetLeft);// &#125;// es5function mouseoverHandle() &#123; fn(cloud, this.offsetLeft)&#125;let last = 0;function clickHandle() &#123; last = this.offsetLeft;&#125;function mouseoutHandle() &#123; fn(cloud, last);&#125;for (let i = 0; i &lt; li.length; i++) &#123; // 鼠标移入 li[i].onmouseover = mouseoverHandle; // 鼠标点击 li[i].onclick = clickHandle; // 鼠标离开 li[i].onmouseout = mouseoutHandle;&#125;// 封装点击事件移动函数//设置任意的一个元素,移动到指定的目标位置fn = (element, target) =&gt; &#123; clearInterval(element.timeId); //定时器的id值存储到对象的一个属性中 element.timeId = setInterval(function () &#123; //获取元素的当前的位置,数字类型 var current = element.offsetLeft; //每次移动的距离 var step = (target - current) / 10; step = step &gt; 0 ? Math.ceil(step) : Math.floor(step); current += step; if (Math.abs(current - target) &gt; Math.abs(step)) &#123; element.style.left = current + "px"; &#125; else &#123; //清理定时器 clearInterval(element.timeId); //直接到达目标 element.style.left = target + "px"; &#125; &#125;, 20);&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动轮播图]]></title>
    <url>%2F2018%2F08%2F30%2F2018-08-30%2F</url>
    <content type="text"><![CDATA[重点：1.获取相应的元素2.给元素添加上相应的事件3.给事件添加相应的功能4.封装函数5.定时器的运用 案例效果图 素材 案例代码Css12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758.wrap &#123; width: 500px; height: 200px; border: 5px solid black; position: relative; overflow: hidden; margin: 0 auto; &#125; .inner &#123; width: 600%; position: relative; &#125; img &#123; float: left; &#125; .wrap:hover .left, .wrap:hover .right &#123; opacity: 1; &#125; .left, .right &#123; position: absolute; top: 50%; color: pink; font-size: 30px; transform: translateY(-50%); cursor: pointer; opacity: 0; &#125; .right &#123; right: 0; &#125; .an &#123; position: absolute; top: 170px; left: 50%; transform: translateX(-50%); &#125; span &#123; width: 10px; height: 10px; /* display: inline; */ border-radius: 50%; background-color: #000; float: left; margin-left: 5px; &#125; .sc &#123; background-color: red; &#125; Html123456789101112131415161718192021&lt;div class="wrap"&gt; &lt;div class="inner"&gt; &lt;img src="images/1.jpg" alt=""&gt; &lt;img src="images/2.jpg" alt=""&gt; &lt;img src="images/3.jpg" alt=""&gt; &lt;img src="images/4.jpg" alt=""&gt; &lt;img src="images/5.jpg" alt=""&gt; &lt;img src="images/1.jpg" alt=""&gt; &lt;/div&gt; &lt;div class="left"&gt; &lt; &lt;/div&gt; &lt;div class="right"&gt; &gt; &lt;/div&gt; &lt;div class="an"&gt; &lt;span class="sc"&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; JavaScript12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// 获取左按钮let l = document.querySelector(".left");// 获取右按钮let r = document.querySelector(".right");// 图片父级let inner = document.querySelector(".inner");// 获取span按钮let span = document.querySelectorAll("span");// 获取框架let wrap = document.querySelector(".wrap");// 记录第几个let index = 0;// 右点击事件r.onclick = () =&gt; &#123; index++; if (index &gt;= 6) &#123; index = 1; inner.style.left = 0 + "px"; &#125; chang()&#125;// 左点击事件l.onclick = () =&gt; &#123; index--; if (index &lt; 0) &#123; inner.style.left = -2500 + "px"; index = 4; &#125; chang()&#125;// 循环给sapn按钮添加点击事件for (let i = 0; i &lt; span.length; i++) &#123; span[i].num = i; span[i].onclick = () =&gt; &#123; index = span[i].num; chang(); &#125;&#125;// 每3秒自动播放let zd = setInterval(r.onclick, 3000);// 鼠标进入停止播放事件wrap.onmouseover = () =&gt; &#123; clearInterval(zd);&#125;// 鼠标离开继续开启鼠标点击事件wrap.onmouseout = () =&gt; &#123; zd = setInterval(r.onclick, 3000);&#125;// 给按钮添加遍历和调用移动函数chang = () =&gt; &#123; for (let i = 0; i &lt; span.length; i++) &#123; span[i].className = ""; &#125; let n = index == 5 ? 0 : index; span[n].className = "sc"; fn(inner, -index * 500);&#125;// 封装点事件移动函数//设置任意的一个元素,移动到指定的目标位置fn = (element, target) =&gt; &#123; clearInterval(element.timeId); //定时器的id值存储到对象的一个属性中 element.timeId = setInterval(function () &#123; //获取元素的当前的位置,数字类型 var current = element.offsetLeft; //每次移动的距离 var step = 20; step = current &lt; target ? step : -step; //当前移动到位置 current += step; if (Math.abs(current - target) &gt; Math.abs(step)) &#123; element.style.left = current + "px"; &#125; else &#123; //清理定时器 clearInterval(element.timeId); //直接到达目标 element.style.left = target + "px"; &#125; &#125;, 20);&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协议按钮/定时器小案例]]></title>
    <url>%2F2018%2F08%2F29%2F2018-08-29%2F</url>
    <content type="text"><![CDATA[重点：1.协议按钮2.div 渐变3.div 变宽4.div 移动 //div要移动,要脱离文档流—position:absolute//如果样式的代码是在style的标签中设置,外面是获取不到//如果样式的代码是在style的属性设置,外面是可以获取//获取div的当前位置//console.log(div.offsetLeft); 协议按钮Html1234&lt;textarea name="texta" id="" cols="30" rows="10"&gt; 这个世界就是这么疯狂，你不同意我就不给你注册&lt;/textarea&gt;&lt;input type="button" value="请仔细阅读协议(5)" disabled&gt; Js1234567891011let btn = document.querySelector("input");let time = 5;let tim = setInterval(() =&gt; &#123; time--; btn.value = "请仔细阅读协议(" + time + ")"; if (time &lt;= 0) &#123; clearInterval(tim); btn.disabled = false; btn.value = "同意协议"; &#125;&#125;, 1000) 渐变Css12345div &#123; width: 300px; height: 200px; background-color: pink;&#125; Html1234&lt;div&gt;&lt;/div&gt;&lt;input type="button" value="透明"&gt; Js123456789101112let dv = document.querySelector("div"); let btn = document.querySelector("input"); let opacity = 10; btn.onclick = () =&gt; &#123; let time = setInterval(() =&gt; &#123; opacity--; dv.style.opacity = opacity / 10; if (opacity&lt;=0) &#123; clearInterval(time);//清理定时器 &#125; &#125;, 200) &#125; 变宽Css12345678910* &#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 100px; background-color: pink; &#125; Html12345678&lt;input type="button" value="变宽"&gt;&lt;input type="button" value="停止变宽"&gt;&lt;input type="button" value="变窄"&gt;&lt;hr&gt;&lt;input type="button" value="变长"&gt;&lt;input type="button" value="停止变长"&gt;&lt;input type="button" value="变短"&gt;&lt;div&gt;&lt;/div&gt; Js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071let btn = document.querySelectorAll("input");let dv = document.querySelector("div");let w = 200;let h = 100;let time = null;let time1 = null;let bol = false;let bol1 = false;btn[0].onclick = () =&gt; &#123; if (bol) &#123; return; &#125; bol = true; time = setInterval(() =&gt; &#123; w++; dv.style.width = w + "px"; &#125;, 20)&#125;btn[1].onclick = () =&gt; &#123; bol = false; clearInterval(time);&#125;btn[2].onclick = () =&gt; &#123; if (bol) &#123; return; &#125; bol = true; time = setInterval(() =&gt; &#123; w--; dv.style.width = w + "px"; if (w &lt;= 0) &#123; bol = false; clearInterval(time); &#125; &#125;, 20)&#125;btn[3].onclick = () =&gt; &#123; if (bol1) &#123; return; &#125; bol1 = true; time1 = setInterval(() =&gt; &#123; h++; dv.style.height = h + "px"; &#125;, 20)&#125;btn[4].onclick = () =&gt; &#123; bol1 = false; clearInterval(time1);&#125;btn[5].onclick = () =&gt; &#123; if (bol1) &#123; return; &#125; bol1 = true; time1 = setInterval(() =&gt; &#123; h--; dv.style.height = h + "px"; if (h &lt;= 0) &#123; bol1 = false; clearInterval(time1); &#125; &#125;, 20)&#125; 移动Css123456789101112* &#123; margin: 0; padding: 0;&#125;div &#123; width: 200px; height: 100px; background-color: pink; position: absolute; top: 40px; left: 0;&#125; Html1234567&lt;input type="button" value="向右移动600px"&gt;&lt;input type="button" value="向左移动600px"&gt;&lt;input type="button" value="向上移动600px"&gt;&lt;input type="button" value="向下移动600px"&gt;&lt;div&gt;&lt;/div&gt; Js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253let btn = document.querySelectorAll("input");let dv = document.querySelector("div");let time = null;let bol = false;let x = "x";let y = "y";let d;fn = (t, h, l) =&gt; &#123; if (bol) &#123; return; &#125; bol = true; if (t == x) &#123; d = dv.offsetLeft; &#125; else &#123; d = dv.offsetTop; &#125; time = setInterval(() =&gt; &#123; if (h == 0) &#123; d++; &#125; else if (h == 1) &#123; d--; &#125; if (t == x) &#123; dv.style.left = d + "px"; &#125; else &#123; dv.style.top = d + "px"; &#125; if (d % l == 0 || d &lt;= 0) &#123; clearInterval(time); bol = false; &#125; else if (t == y &amp;&amp; d &lt;= 40) &#123; clearInterval(time); bol = false; &#125; &#125;, 20)&#125;btn[0].onclick = () =&gt; &#123; fn(x, 0, 600);&#125;btn[1].onclick = () =&gt; &#123; fn(x, 1, 600);&#125;btn[2].onclick = () =&gt; &#123; fn(y, 1, 600);&#125;btn[3].onclick = () =&gt; &#123; fn(y, 0, 600);&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM 浏览器]]></title>
    <url>%2F2018%2F08%2F28%2F2018-08-28%2F</url>
    <content type="text"><![CDATA[重点：1.location 主机2.history3.navigator 判断浏览器所在系统4.window.onload 页面加载完成5.定时器 history1234567891011121314151617window.onload = function () &#123; let btn = document.querySelectorAll("input"); btn[0].onclick = function () &#123; window.location.href = "9_tui.html"; &#125; // 方法一 // btn[1].onclick = function () &#123; // window.history.forward(); // &#125; // 方法二 btn[1].onclick = function () &#123; window.history.go(1); &#125;&#125; 123456789101112window.onload = function () &#123; let btn = document.querySelector("input"); // 方法一 // btn.onclick = function () &#123; // window.history.back(); // &#125; // 方法二 btn.onclick = function () &#123; window.history.go(-1); &#125;&#125; navigator1234// 通过 platform 可以判断浏览器所在打系统平台类型console.log(window.navigator.platform);//console.log(window.navigator.userAgent); 定时器一123456789//定义开启定时器 setIntervallet time = setInterval(function () &#123; console.log("ss");&#125;,1000)//关闭定时器 clearIntervalbtn.onclick = function () &#123; window.clearInterval(time);&#125; 定时器二 一次性定时器123456789let btn = document.querySelector("input");// 一次性定时器let time = setTimeout(() =&gt; &#123; alert("你好");&#125;, 1000);// 清理定时器btn.onclick = () =&gt; &#123; clearTimeout(time)&#125; 小案例11234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; div &#123; width: 600px; height: 600px; border: 2px solid pink; background-color: #000; position: relative; &#125; span &#123; font-size: 30px; color: yellow; position: absolute; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;亮起来&quot;&gt; &lt;div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; let btn = document.querySelector(&quot;input&quot;); let div = document.querySelector(&quot;div&quot;); let time = null; btn.onclick = function () &#123; div.innerHTML = &quot;&lt;span&gt;⭐️&lt;/span&gt;&quot;; time = setInterval(function () &#123; let x = parseInt(Math.random() * 600 + 1); let y = parseInt(Math.random() * 600 + 1); div.firstElementChild.style.left = x + &quot;px&quot;; div.firstElementChild.style.top = y + &quot;px&quot;; &#125;, 500); &#125;&lt;/script&gt;&lt;/html&gt; 小案例2123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; span &#123; font-size: 30px; color: red; position: absolute; top: 500px &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;img src=&quot;&quot; alt=&quot;&quot;&gt; &lt;div class=&quot;dv&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; f1 = () =&gt; &#123; let dv = document.querySelector(&quot;.dv&quot;); let span = document.querySelector(&quot;span&quot;); let dt = new Date(); let img = document.querySelector(&quot;img&quot;); let nian = dt.getFullYear(); //获取完整的年份(4位,1970-????) let yue = dt.getMonth() + 1; //获取当前月份(0-11,0代表1月) let ri = dt.getDate(); //获取当前日(1-31) let hour = dt.getHours(); //获取当前小时数(0-23) let fen = dt.getMinutes(); //获取当前分钟数(0-59) let second = dt.getSeconds(); //获取当前秒数(0-59) yue = yue &lt; 10 ? &quot;0&quot; + yue : yue; ri = ri &lt; 10 ? &quot;0&quot; + ri : ri; fen = fen &lt; 10 ? &quot;0&quot; + fen : fen; hour = hour &lt; 10 ? &quot;0&quot; + hour : hour; second = second &lt; 10 ? &quot;0&quot; + second : second; img.src = &quot;meimei/&quot; + hour + &quot;_&quot; + second + &quot;.jpg&quot;; let aa = nian + &quot;年&quot; + yue + &quot;月&quot; + ri + &quot;日&quot; + hour + &quot;时&quot; + fen + &quot;分&quot; + second + &quot;秒&quot;; span.innerText = aa; // dv.innerHTML = &quot;&lt;span&gt;ss&lt;/span&gt;&quot; console.log(aa); &#125; setInterval(f1, 1000);&lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟百度搜索]]></title>
    <url>%2F2018%2F08%2F27%2F2018-08-27%2F</url>
    <content type="text"><![CDATA[重点：1.创建元素，添加元素，移除元素 document.createElement(“p”) 上级名.removeChild(删除的元素名); 添加到的元素名例（arr数组等）.push(追加元素)2.判读获取文本框内容与数组对比 indexOf()3.判断元素是否为空不为空删除4.遍历数组 Html1234&lt;div class="box"&gt; &lt;input type="text" class="txt"&gt; &lt;input class="btn" type="submit" value="搜索"&gt;&lt;/div&gt; Css1234567891011121314151617181920212223242526* &#123; padding: 0; margin: 0;&#125;.box &#123; position: relative; left: 50%; top: 200px;&#125;.txt &#123; width: 300px; height: 30px;&#125;.btn &#123; width: 100px; height: 35px; border: 1px solid #000; background-color: #fff;&#125;p &#123; margin: 5px 0;&#125; js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// 获取数据let box = document.querySelector(".box");let txt = document.querySelector(".txt");let btn = document.querySelector(".btn");// 数组记录数据// 本应后台获取// 前端测试用数组代替let keyWords = ["我是你爸爸", "我是你爸爸", "我是你爸爸", "我是你爸爸", "我的你爸爸", "儿子","小杨才是最纯洁的", "小杨才是最帅的", "小段是最猥琐的", "小超是最龌龊的", "传智播客是一个培训机构", "传说在传智有个很帅很纯洁的小杨", "苹果好吃", "苹果此次召回还是没有中国"];// 文本框键盘抬起函数txt.onkeyup = function () &#123; // 判断是否有新创建id为obj的div元素，有就清除 if ((document.querySelector("#obj"))) &#123; box.removeChild((document.querySelector("#obj"))); &#125; // 定义现在文本框的内容 let text = this.value; // 临时数组记录数据 let arr = []; for (let i = 0; i &lt; keyWords.length; i++) &#123; // 是否是最开始出现 if (keyWords[i].indexOf(text) == 0) &#123; arr.push(keyWords[i]); //追加到临时数组 &#125; &#125; // 判断文本框或者临时数组为空时，在判断创建id为obj的div元素，有就清除，并且停止后面的代码运行 if (this.value.length == 0 || arr.length == 0) &#123; if ((document.querySelector("#obj"))) &#123; box.removeChild((document.querySelector("#obj"))); &#125; return; &#125; // 创建div，加入到box中 let obj = document.createElement("div"); // 添加到类名为box的div中 box.appendChild(obj); // 设置id为obj obj.id = "obj"; // 设置样式 obj.style.width = "300px"; obj.style.border = "1px solid red"; // 循环遍历临时数组，并创建p标签输出数组的内容 for (let i = 0; i &lt; arr.length; i++) &#123; let p = document.createElement("p"); obj.appendChild(p); p.innerText = arr[i]; // 定义p标签的鼠标进入和离开事件，改变背景颜色 p.onmouseover = function () &#123; this.style.backgroundColor = "yellow"; &#125; p.onmouseout = function () &#123; this.style.backgroundColor = ""; &#125; &#125;&#125; 效果]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js 事件绑/解 阻止事件冒泡]]></title>
    <url>%2F2018%2F08%2F25%2F2018-08-25%2F</url>
    <content type="text"><![CDATA[绑/解事件绑定事件的区别addEventListener();attachEvent()相同点: 都可以为元素绑定事件不同点: 1.方法名不一样 2.参数个数不一样 addEventListener 三个参数,attachEvent 两个参数3.addEventListener 谷歌,火狐,IE11 支持,IE8 不支持attachEvent 谷歌火狐不支持,IE11 不支持,IE8 支持4.this 不同,addEventListener 中的 this 是当前绑定事件的对象attachEvent 中的 this 是 window5.addEventListener 中事件的类型(事件的名字)没有 onattachEvent 中的事件的类型(事件的名字)有 on 解绑事件注意注意:用什么方式绑定事件,就应该用对应的方式解绑事件 1.解绑事件对象.on 事件名字=事件处理函数—&gt;绑定事件对象.on 事件名字=null; 2.解绑事件对象.addEventListener(“没有 on 的事件类型”,命名函数,false);—绑定事件对象.removeEventListener(“没有 on 的事件类型”,函数名字,false); 3.解绑事件对象.attachEvent(“on 事件类型”,命名函数);—绑定事件对象.detachEvent(“on 事件类型”,函数名字); 绑定事件1234567btn.addEventListener("click",function () &#123; console.log(this);&#125;,false);btn.attachEvent("onclick",function () &#123; console.log(this);&#125;); 解绑事件123456789101112131415161718192021222324252627282930313233let btn = document.querySelectorAll("input");// btn[0].onclick = function () &#123;// console.log("我是你爸");// &#125;// btn[1].onclick = function () &#123;// // 1.解绑事件// btn[0].onclick = null;// &#125;// 解绑2function f1() &#123; console.log("11");&#125;function f2() &#123; console.log("22");&#125;// btn[0].addEventListener("click",f1,false);// btn[0].addEventListener("click",f2,false);// btn[1].onclick = function () &#123;// // 2.解绑事件// btn[0].removeEventListener("click",f1,false);// &#125;// 解绑3 btn[0].attachEvent("onclick",f1); btn[0].attachEvent("onclick",f2); btn[1].onclick = function () &#123; btn[0].detachEvent("onclick",f1); &#125; 绑/解兼容写法12345678910111213141516171819202122232425262728293031323334353637383940// 获取按钮let btn = document.querySelectorAll("input");// 事件函数function f1() &#123; console.log("11");&#125;function f2() &#123; console.log("22");&#125;// 绑定function addEventListener(element, type, fn) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; else if (element.attachEvent) &#123; element.attachEvent("on" + type, fn) &#125; else &#123; element["on" + type] = fn; &#125;&#125;// 解绑function removeEventListener(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; else if (element.detachEvent) &#123; element.detachEvent("on" + type, fn) &#125; else &#123; element["on" + type] = fn; &#125;&#125;// 调用addEventListener(btn[0], "click", f1)addEventListener(btn[0], "click", f2)btn[1].onclick = function () &#123; removeEventListener(btn[0],"click",f1)&#125; 阻止事件冒泡1234567891011121314151617181920212223242526//事件冒泡:多个元素嵌套,有层次关系,这些元素都注册了相同的事件,如果里面的元素的事件触发了,外面的元素的该事件自动的触发了.//事件冒泡,阻止事件冒泡,//如何阻止事件冒泡: window.event.cancelBubble=true; IE特有的,谷歌支持,火狐不支持// e.stopPropagation(); 谷歌和火狐支持let d1 = document.querySelector(".d1");let d2 = document.querySelector(".d2");let d3 = document.querySelector(".d3");// 事件冒泡d1.onclick = function () &#123; console.log(this.className);&#125;d2.onclick = function () &#123; console.log(this.className); // window.event.cancelBubble = true;&#125;// 事件处理参数对象d3.onclick = function (e) &#123; console.log(this.className); // 阻止事件冒泡 // window.event.cancelBubble = true; e.stopPropagation();&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo]]></title>
    <url>%2F2018%2F08%2F25%2Fhexo%2F</url>
    <content type="text"><![CDATA[hexo使用12$ hexo n //创建笔记 简写$ hexo new 12$ hexo s //开启服务 简写$ hexo server 12$ hexo g //打包笔记输出到public文件中，可上传至github中 简写$ hexo generate ##在hexo中插入图片图片文件夹放在source下就可以了123![“图片描述”](/文件夹/图片名) //方法一&lt;img src=&quot;/media/Unofficial_JavaScript_logo_2.svg.png&quot; width=&quot;400&quot; alt=&quot;&quot;&gt; //方法二]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yhf]]></title>
    <url>%2F2018%2F08%2F24%2Fyhf%2F</url>
    <content type="text"><![CDATA[yhf测试文章123function show()&#123; console.log('hello world');&#125;]]></content>
      <categories>
        <category>个人</category>
      </categories>
      <tags>
        <tag>个人</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F08%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2F2017%2F12%2F06%2F01-JavaScript%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[学习目标: 掌握编程的基本思维 掌握编程的基本语法typora-copy-images-to: media JavaScript基础HTML和CSS 京东 课前娱乐众人皆笑我疯癫,我笑尔等看不穿 ##课前说明目标： 掌握编程的基本思想掌握JavaScript的基础语法,使用常见API(备注)完成相应案例及练习和作业培养独立解决问题能力遇到问题先独立调试(牛X从规范和调试开始)能够独立写出所有案例代码 注意： 以大多数同学的接受能力为基准，稳准狠的前行 注重基础，以最简单的案例说明问题，并以企业项目案例进行实践 课上思考，课下提问。不需要深究的地方不要钻牛角尖。 必须完成作业,基础坚挺的同学低调,基础薄弱同学多问一句话送给大家:当你要放弃的时候想想当初为什么坚持到现在！笔记和代码是”大家的”,自己写的才是自己的.复制代码者,没有”男朋友”不写代码者,没有”女朋友” ##阶段说明JavaScript基础Web APIJavaScript高级 ##第一天重点内容变量的声明及使用数据类型类型转换运算符 ##课外提示1.敲代码用指法,指法配图，坚持一周者即可熟练2.码农不需要练就一阳指或者二指禅3.可以使用金山打字通，此处并非打广告,个人建议，天天敲代码，不停的反复的敲练习和作业，速度和基本功的快速提升奉劝各位:保护好自己的手控制自己的右手windows中的常用快捷键 ##浏览器说明浏览器是指可以显示网页服务器或者文件系统的HTML文件内容，并让用户与这些文件交互的一种软件。通俗的讲:可以显示页面的一个软件,国内网民计算机上常见的网页浏览器有，QQ浏览器、Internet Explorer、Firefox、Safari，Opera、Google Chrome、百度浏览器、搜狗浏览器、猎豹浏览器、360浏览器、UC浏览器、傲游浏览器、世界之窗浏览器等，浏览器是最经常使用到的客户端程序。常用的五大浏览器：chrome，firefox，Safari，ie，opera我们用chrome(谷歌浏览器) 网页、网站和应用程序网页：单独的一个页面网站：一些列相关的页面组成到一起应用程序：可以和用户产生交互，并实现某种功能。 演示JavaScript的强大http://impress.github.io/impress.js/http://naotu.baidu.com/https://codecombat.com/https://ide.codemao.cn/ 需要翻墙https://developers.google.com/blockly/blockly迷宫https://blockly-games.appspot.com blockly迷宫不需要翻墙https://blockly.uieee.com/ JavaScript介绍JavaScript是什么HTML CSS JavaScript 编程语言 流程控制 Netscape在最初将其脚本语言命名为LiveScript，后来Netscape在与Sun合作之后将其改名为JavaScript。JavaScript最初受Java启发而开始设计的，目的之一就是“看上去像Java”，因此语法上有类似之处，一些名称和命名规范也借自Java。JavaScript与Java名称上的近似，是当时Netscape为了营销考虑与Sun微系统达成协议的结果。Java和JavaScript的关系就像张雨和张雨生的关系，只是名字很像。 ​ Java 服务器端的编程语言 ​ JavaScript 运行在客户端(浏览器)的编程语言 JavaScript是一种运行在客户端 的脚本语言JavaScript的解释器被称为JavaScript引擎，为浏览器的一部分，广泛用于客户端的脚本语言，最早是在HTML（标准通用标记语言下的一个应用）网页上使用，用来给HTML网页增加动态功能。 JavaScript最初的目的演示：http://baixiu.uieee.com/admin/login.php最初的目的是为了处理表单的验证操作。 JavaScript现在的意义(应用场景)JavaScript 发展到现在几乎无所不能。 网页特效 服务端开发(Node.js) 命令行工具(Node.js) 桌面程序(Electron) App(Cordova) 控制硬件-物联网(Ruff) 游戏开发(cocos2d-js) JavaScript和HTML、CSS的区别 HTML：提供网页的结构，提供网页中的内容 CSS: 用来美化网页 JavaScript: 可以用来控制网页内容，给网页增加动态的效果 JavaScript的组成 ECMAScript - JavaScript的核心ECMA 欧洲计算机制造联合会 网景：JavaScript 微软：JScript 定义了JavaScript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 JavaScript初体验CSS：行内样式、嵌入样式、外部样式 JavaScript的书写位置 写在行内 1&lt;input type="button" value="按钮" onclick="alert('Hello World')" /&gt; 写在script标签中 12345&lt;head&gt; &lt;script&gt; alert('Hello World!'); &lt;/script&gt;&lt;/head&gt; 写在外部js文件中，在页面引入 1&lt;script src="main.js"&gt;&lt;/script&gt; 注意点 引用外部js文件的script标签中不可以写JavaScript代码 计算机组成软件 应用软件：浏览器(Chrome/IE/Firefox)、QQ、Sublime、Word 系统软件：Windows、Linux、mac OSX 硬件 三大件：CPU、内存、硬盘 – 主板 输入设备：鼠标、键盘、手写板、摄像头等 输出设备：显示器、打印机、投影仪等 变量什么是变量 什么是变量 变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量 使用变量可以方便的获取或者修改内存中的数据 如何使用变量 var声明变量 1var age; 变量的赋值 12var age;age = 18; 同时声明多个变量 123var age, name, sex;age = 10;name = 'zs'; 同时声明多个变量并赋值 1var age = 10, name = 'zs'; 变量在内存中的存储1var age = 18; 变量的命名规则和规范 规则 - 必须遵守的，不遵守会报错 由字母、数字、下划线、$符号组成，不能以数字开头 不能是关键字和保留字，例如：for、while。 区分大小写 规范 - 建议遵守的，不遵守不会报错 变量名必须有意义 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。例如：userName、userPassword 下面哪些变量名不合法 123456789a 1age1818agename$name_sex&amp;sextheworld theWorld 案例 交换两个变量的值 不使用临时变量，交换两个数值变量的值 数据类型简单数据类型Number、String、Boolean、Undefined、Null Number类型 数值字面量：数值的固定值的表示法 110 1024 60.5 进制 123456789101112十进制truevar num = 9;true进行算数计算时，八进制和十六进制表示的数值最终都将被转换成十进制数值。十六进制truevar num = 0xA;true数字序列范围：0~9以及A~F八进制 var num1 = 07; // 对应十进制的7 var num2 = 019; // 对应十进制的19 var num3 = 08; // 对应十进制的8 数字序列范围：0~7 如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析 浮点数 浮点数的精度问题 123456浮点数truevar n = 5e-324; // 科学计数法 5乘以10的-324次方 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数 var result = 0.1 + 0.2; // 结果不是 0.3，而是：0.30000000000000004 console.log(0.07 * 100); 不要判断两个浮点数是否相等 数值范围 1234最小值：Number.MIN_VALUE，这个值为： 5e-324最大值：Number.MAX_VALUE，这个值为： 1.7976931348623157e+308无穷大：Infinity无穷小：-Infinity 数值判断 NaN：not a number NaN 与任何值都不相等，包括他本身 isNaN: is not a number String类型‘abc’ “abc” 字符串字面量 ‘程序猿’，’程序媛’, “黑马程序猿” ​ 思考：如何打印以下字符串。我是一个”正直”的人我很喜欢”黑马’程序猿’” 转义符 字符串长度 length属性用来获取字符串的长度 12var str = '黑马程序猿 Hello World';console.log(str.length); 字符串拼接 字符串拼接使用 + 连接 12345console.log(11 + 11);console.log('hello' + ' world');console.log('100' + '100');console.log('11' + 11);console.log('male:' + true); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 Boolean类型 Boolean字面量： true和false，区分大小写 计算机内部存储：true为1，false为0 Undefined和Null undefined表示一个声明了没有赋值的变量，变量只声明的时候值默认是undefined null表示一个空，变量的值如果想为null，必须手动设置 复杂数据类型​ Object 获取变量的类型typeof 12var age = 18;console.log(typeof age); // 'number' 字面量在源代码中一个固定值的表示法。 数值字面量：8, 9, 10 字符串字面量：’黑马程序员’, “大前端” 布尔字面量：true，false 注释单行注释用来描述下面一个或多行代码的作用 12// 这是一个变量var name = 'hm'; 多行注释用来注释多条代码 12345/*var age = 18;var name = 'zs';console.log(name, age);*/ 数据类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的 转换成字符串类型 toString() 12var num = 5;console.log(num.toString()); String() 1String()函数存在的意义：有些值没有toString()，这个时候可以使用String()。比如：undefined和null 拼接字符串方式 num + “”，当 + 两边一个操作符是字符串类型，一个操作符是其它类型的时候，会先把其它类型转换成字符串再进行字符串拼接，返回字符串 转换成数值类型 Number() 1Number()可以把任意值转换成数值，如果要转换的字符串中有一个不是数值的字符，返回NaN parseInt() 12var num1 = parseInt("12.3abc"); // 返回12，如果第一个字符是数字会解析知道遇到非数字结束var num2 = parseInt("abc123"); // 返回NaN，如果第一个字符不是数字或者符号就返回NaN parseFloat() 1234parseFloat()把字符串转换成浮点数parseFloat()和parseInt非常相似，不同之处在与trueparseFloat会解析第一个. 遇到第二个.或者非数字结束true如果解析的内容里只有整数，解析成整数 +，-0等运算 1234var str = '500';console.log(+str); // 取正console.log(-str); // 取负console.log(str - 0); 转换成布尔类型 Boolean() 0 ‘’(空字符串) null undefined NaN 会转换成false 其它都会转换成true 操作符运算符 operator 5 + 6 表达式 组成 操作数和操作符，会有一个结果 算术运算符1+ - * / % 一元运算符一元运算符：只有一个操作数的运算符 5 + 6 两个操作数的运算符 二元运算符 ++ 自身加1 – 自身减1 前置++ 12345var num1 = 5;++ num1; var num2 = 6;console.log(num1 + ++ num2); 后置++ 1234var num1 = 5;num1 ++; var num2 = 6 console.log(num1 + num2 ++); 猜猜看 1234var a = 1; var b = ++a + ++a; console.log(b); var a = 1; var b = a++ + ++a; console.log(b); var a = 1; var b = a++ + a++; console.log(b); var a = 1; var b = ++a + a++; console.log(b); 总结前置++：先加1，后参与运算后置++：先参与运算，后加1上面两个理解后，下面两个自通前置– ：先减1，后参与运算后置– ：先参与运算，后减1​ 逻辑运算符(布尔运算符)&amp;&amp; 与 两个操作数同时为true，结果为true，否则都是false || 或 两个操作数有一个为true，结果为true，否则为false ! 非 取反 关系运算符(比较运算符)&lt; &gt; &gt;= &lt;= == != === !== 12345==与===的区别：==只进行值得比较，===类型和值同时相等，则相等var result = '55' == 55; // truevar result = '55' === 55; // false 值相等，类型不相等var result = 55 === 55; // true 赋值运算符= += -= *= /= %=123例如：var num = 0;num += 5; //相当于 num = num + 5; 运算符的优先级优先级从高到底 1. () 优先级最高 2. 一元运算符 ++ -- ! 3. 算数运算符 先* / % 后 + - 4. 关系运算符 &gt; &gt;= &lt; &lt;= 5. 相等运算符 == != === !== 6. 逻辑运算符 先&amp;&amp; 后|| 7. 赋值运算符 12345// 练习1：4 &gt;= 6 || '人' != '阿凡达' &amp;&amp; !(12 * 2 == 144) &amp;&amp; true// 练习2：var num = 10;5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === '22' 表达式和语句表达式 一个表达式可以产生一个值，有可能是运算、函数调用、有可能是字面量。表达式可以放在任何需要值的地方。 语句 语句可以理解为一个行为，循环语句和判断语句就是典型的语句。一个程序有很多个语句组成，一般情况下;分割一个一个的语句 流程控制 程序的三种基本结构 顺序结构 从上到下执行的代码就是顺序结构 程序默认就是由上到下顺序执行的 分支结构根据不同的情况，执行对应代码 循环结构循环结构：重复做一件事情 分支结构if语句语法结构 12345678910111213141516171819if (/* 条件表达式 */) &#123; // 执行语句&#125;if (/* 条件表达式 */)&#123; // 成立执行语句&#125; else &#123; // 否则执行语句&#125;if (/* 条件1 */)&#123; // 成立执行语句&#125; else if (/* 条件2 */)&#123; // 成立执行语句&#125; else if (/* 条件3 */)&#123; // 成立执行语句&#125; else &#123; // 最后默认执行语句&#125; 案例： 求两个数的最大数 判断一个数是偶数还是奇数 分数转换，把百分制转换成ABCDE &lt;60 E 60-70 D 70-80 C 80-90 B 90 - 100 A作业： 判断一个年份是闰年还是平年 闰年：能被4整除，但不能被100整除的年份 或者 能被400整除的年份 判断一个人的年龄是否满18岁(是否成年) 三元运算符表达式1 ? 表达式2 : 表达式3 是对if……else语句的一种简化写法 案例： 是否年满18岁 从两个数中找最大值 switch语句语法格式:123456789101112131415161718switch (expression) &#123; case 常量1: 语句; break; case 常量2: 语句; break; case 常量3: 语句; break; … case 常量n: 语句; break; default: 语句; break;&#125; break可以省略，如果省略，代码会继续执行下一个case switch 语句在比较值时使用的是全等操作符, 因此不会发生类型转换（例如，字符串&apos;10&apos; 不等于数值 10） 案例： 显示星期几 素质教育（把分数变成ABCDE）千万不要写100个case哟 布尔类型的隐式转换流程控制语句会把后面的值隐式转换成布尔类型 转换为true 非空字符串 非0数字 true 任何对象 转换成false 空字符串 0 false null undefined 12// 结果是什么？var a = !!'123'; 案例12345var message;// 会自动把message转换成falseif (message) &#123; // todo...&#125; 循环结构 在javascript中，循环语句有三种，while、do..while、for循环。 while语句基本语法： 12345// 当循环条件为true时，执行循环体，// 当循环条件为false时，结束循环。while (循环条件) &#123; //循环体&#125; 代码示例： 123456789101112// 计算1-100之间所有数的和// 初始化变量var i = 1;var sum = 0;// 判断条件while (i &lt;= 100) &#123; // 循环体 sum += i; // 自增 i++;&#125;console.log(sum); 案例： 打印100以内 7的倍数 打印100以内所有偶数 打印100以内所有偶数的和作业： 打印100以内的奇数 打印100以内的奇数的和 do…while语句 do..while循环和while循环非常像，二者经常可以相互替代，但是do..while的特点是不管条件成不成立，都会执行一次。 基础语法： 123do &#123; // 循环体;&#125; while (循环条件); 代码示例： 1234567// 初始化变量var i = 1;var sum = 0;do &#123; sum += i;//循环体 i++;//自增&#125; while (i &lt;= 100);//循环条件 案例： 12求100以内所有3的倍数的和使用do-while循环：输出询问“我爱你，嫁给我吧？”，选择“你喜欢我吗？(y/n):&quot;，如果输入为y则打印”我们形影不离“，若输入为n,则继续询问 for语句 while和do…while一般用来解决无法确认次数的循环。for循环一般在循环次数确定的时候比较方便 for循环语法： 1234// for循环的表达式之间用的是;号分隔的，千万不要写成,for (初始化表达式1; 判断表达式2; 自增表达式3) &#123; // 循环体4&#125; 执行顺序：1243 —- 243 —–243(直到循环条件变成false) 初始化表达式 判断表达式 自增表达式 循环体 案例： 123456789101112131415161718192021222324252627282930313233343536打印1-100之间所有数求1-100之间所有数的和求1-100之间所有数的平均值求1-100之间所有偶数的和同时求1-100之间所有偶数和奇数的和打印正方形// 使用拼字符串的方法的原因// console.log 输出重复内容的问题// console.log 默认输出内容介绍后有换行var start = &apos;&apos;;for (var i = 0; i &lt; 10; i++) &#123; for (var j = 0; j &lt; 10; j++) &#123; start += &apos;* &apos;; &#125; start += &apos;\n&apos;;&#125;console.log(start);打印直角三角形var start = &apos;&apos;;for (var i = 0; i &lt; 10; i++) &#123; for (var j = i; j &lt; 10; j++) &#123; start += &apos;* &apos;; &#125; start += &apos;\n&apos;;&#125;console.log(start);打印9*9乘法表var str = &apos;&apos;;for (var i = 1; i &lt;= 9; i++) &#123; for (var j = i; j &lt;=9; j++) &#123; str += i + &apos; * &apos; + j + &apos; = &apos; + i * j + &apos;\t&apos;; &#125; str += &apos;\n&apos;;&#125;console.log(str); 作业： 1234567求1-100之间所有数的乘积求1-100之间所有奇数的和计算1-100之间能3整除的数的和计算1-100之间不能被7整除的数的和// 讲解思路。如果不会写程序，可以先把数学公式准备好本金10000元存入银行，年利率是千分之三，每过1年，将本金和利息相加作为新的本金。计算5年后，获得的本金是多少？有个人想知道，一年之内一对兔子能繁殖多少对？于是就筑了一道围墙把一对兔子关在里面。已知一对兔子每个月可以生一对小兔子，而一对兔子从出生后第3个月起每月生一对小兔子。假如一年内没有发生死亡现象，那么，一对兔子一年内（12个月）能繁殖成多少对？（兔子的规律为数列，1，1，2，3，5，8，13，21） continue和break break:立即跳出整个循环，即循环结束，开始执行循环后面的内容（直接跳到大括号） continue:立即跳出当前循环，继续下一次循环（跳到i++的地方） 案例： 12求整数1～100的累加值，但要求碰到个位为3的数则停止累加求整数1～100的累加值，但要求跳过所有个位为3的数 作业： 求1-100之间不能被7整除的整数的和（用continue）求200-300之间所有的奇数的和（用continue）求200-300之间第一个能被7整数的数（break） 调试 过去调试JavaScript的方式 alert() console.log() 断点调试 断点调试是指自己在程序的某一行设置一个断点，调试时，程序运行到这一行就会停住，然后你可以一步一步往下调试，调试过程中可以看各个变量当前的值，出错的话，调试到出错的代码行即显示错误，停下。 调试步骤 1浏览器中按F12--&gt;sources--&gt;找到需要调试的文件--&gt;在程序的某一行设置断点 调试中的相关操作 123Watch: 监视，通过watch可以监视变量的值的变化，非常的常用。F10: 程序单步执行，让程序一行一行的执行，这个时候，观察watch中变量的值的变化。F8：跳到下一个断点处，如果后面没有断点了，则程序执行结束。 tips: 监视变量，不要监视表达式，因为监视了表达式，那么这个表达式也会执行。 代码调试的能力非常重要，只有学会了代码调试，才能学会自己解决bug的能力。初学者不要觉得调试代码麻烦就不去调试，知识点花点功夫肯定学的会，但是代码调试这个东西，自己不去练，永远都学不会。 今天学的代码调试非常的简单，只要求同学们记住代码调试的这几个按钮的作用即可，后面还会学到很多的代码调试技巧。 数组为什么要学习数组 之前学习的数据类型，只能存储一个值(比如：Number/String。我们想存储班级中所有学生的姓名，此时该如何存储？ 数组的概念 所谓数组，就是将多个元素（通常是同一类型）按一定顺序排列放到一个集合中，那么这个集合我们就称之为数组。 数组的定义 数组是一个有序的列表，可以在数组中存放任意的数据，并且数组的长度可以动态的调整。 通过数组字面量创建数组 1234567891011// 创建一个空数组var arr1 = []; // 创建一个包含3个数值的数组，多个数组项以逗号隔开var arr2 = [1, 3, 4]; // 创建一个包含2个字符串的数组var arr3 = ['a', 'c']; // 可以通过数组的length属性获取数组的长度console.log(arr3.length);// 可以设置length属性改变数组中元素的个数arr3.length = 0; 获取数组元素数组的取值 123456// 格式：数组名[下标] 下标又称索引// 功能：获取数组对应下标的那个值，如果下标不存在，则返回undefined。var arr = ['red',, 'green', 'blue'];arr[0]; // redarr[2]; // bluearr[3]; // 这个数组的最大下标为2,因此返回undefined 遍历数组 遍历：遍及所有，对数组的每一个元素都访问一次就叫遍历。 数组遍历的基本语法： 123for(var i = 0; i &lt; arr.length; i++) &#123;true// 数组遍历的固定结构&#125; 数组中新增元素数组的赋值 1234567// 格式：数组名[下标/索引] = 值;// 如果下标有对应的值，会把原来的值覆盖，如果下标不存在，会给数组新增一个元素。var arr = ["red", "green", "blue"];// 把red替换成了yellowarr[0] = "yellow";// 给数组新增加了一个pink的值arr[3] = "pink"; 案例123456求一组数中的所有数的和和平均值求一组数中的最大值和最小值，以及所在位置将字符串数组用|或其他符号分割要求将数组中的0项去掉，将不为0的值存入一个新的数组，生成新的数组翻转数组冒泡排序，从小到大 函数为什么要有函数 如果要在多个地方求1-100之间所有数的和，应该怎么做？ 什么是函数 把一段相对独立的具有特定功能的代码块封装起来，形成一个独立实体，就是函数，起个名字（函数名），在后续开发中可以反复调用 函数的作用就是封装一段代码，将来可以重复使用 函数的定义 函数声明 123function 函数名()&#123; // 函数体&#125; 函数表达式 123var fn = function() &#123; // 函数体&#125; 特点： 函数声明的时候，函数体并不会执行，只要当函数被调用的时候才会执行。函数一般都用来干一件事情，需用使用动词+名词，表示做一件事情 tellStory sayHello等 函数的调用 调用函数的语法： 1函数名(); 特点： 函数体只有在调用的时候才会执行，调用需要()进行调用。可以调用多次(重复使用) 代码示例： 1234567891011121314151617// 声明函数function sayHi() &#123; console.log("吃了没？");&#125;// 调用函数sayHi();// 求1-100之间所有数的和function getSum() &#123; var sum = 0; for (var i = 0; i &lt; 100; i++) &#123; sum += i; &#125; console.log(sum);&#125;// 调用getSum(); 函数的参数 为什么要有参数 12345678910function getSum() &#123; var sum = 0; for (var i = 1; i &lt;= 100; i++) &#123; sum += i; &#125; console.log();&#125;// 虽然上面代码可以重复调用，但是只能计算1-100之间的值// 如果想要计算n-m之间所有数的和，应该怎么办呢？ 语法： 12345678// 函数内部是一个封闭的环境，可以通过参数的方式，把外部的值传递给函数内部// 带参数的函数声明function 函数名(形参1, 形参2, 形参...)&#123; // 函数体&#125;// 带参数的函数调用函数名(实参1, 实参2, 实参3); 形参和实参 形式参数：在声明一个函数的时候，为了函数的功能更加灵活，有些值是固定不了的，对于这些固定不了的值。我们可以给函数设置参数。这个参数没有具体的值，仅仅起到一个占位置的作用，我们通常称之为形式参数，也叫形参。 实际参数：如果函数在声明时，设置了形参，那么在函数调用的时候就需要传入对应的参数，我们把传入的参数叫做实际参数，也叫实参。 123456var x = 5, y = 6;fn(x,y); function fn(a, b) &#123; console.log(a + b);&#125;//x,y实参，有具体的值。函数执行的时候会把x,y复制一份给函数内部的a和b，函数内部的值是复制的新值，无法修改外部的x,y 案例 求1-n之间所有数的和 求n-m之间所有数额和 圆的面积 求2个数中的最大值 求3个数中的最大值 判断一个数是否是素数 函数的返回值 当函数执行完的时候，并不是所有时候都要把结果打印。我们期望函数给我一些反馈（比如计算的结果返回进行后续的运算），这个时候可以让函数返回一些东西。也就是返回值。函数通过return返回一个返回值 返回值语法： 12345678//声明一个带返回值的函数function 函数名(形参1, 形参2, 形参...)&#123; //函数体 return 返回值;&#125;//可以通过变量来接收这个返回值var 变量 = 函数名(实参1, 实参2, 实参3); 函数的调用结果就是返回值，因此我们可以直接对函数调用结果进行操作。 返回值详解： 如果函数没有显示的使用 return语句 ，那么函数有默认的返回值：undefined 如果函数使用 return语句，那么跟再return后面的值，就成了函数的返回值 如果函数使用 return语句，但是return后面没有任何值，那么函数的返回值也是：undefined 函数使用return语句后，这个函数会在执行完 return 语句之后停止并立即退出，也就是说return后面的所有其他代码都不会再执行。 推荐的做法是要么让函数始终都返回一个值，要么永远都不要返回值。 案例 求阶乘 求1!+2!+3!+….+n! 求一组数中的最大值 求一组数中的最小值 arguments的使用 JavaScript中，arguments对象是比较特别的一个对象，实际上是当前函数的一个内置属性。也就是说所有函数都内置了一个arguments对象，arguments对象中存储了传递的所有的实参。arguments是一个伪数组，因此及可以进行遍历 案例12求任意个数的最大值求任意个数的和 案例12345求斐波那契数列Fibonacci中的第n个数是多少？ 1 1 2 3 5 8 13 21...翻转数组，返回一个新数组对数组排序，从小到大输入一个年份，判断是否是闰年[闰年：能被4整数并且不能被100整数，或者能被400整数]输入某年某月某日，判断这一天是这一年的第几天？ 函数其它匿名函数 匿名函数：没有名字的函数 匿名函数如何使用： 将匿名函数赋值给一个变量，这样就可以通过变量进行调用 匿名函数自调用 关于自执行函数（匿名函数自调用）的作用：防止全局变量污染。 自调用函数 匿名函数不能通过直接调用来执行，因此可以通过匿名函数的自调用的方式来执行123(function () &#123; alert(123);&#125;)(); 函数是一种数据类型12function fn() &#123;&#125;console.log(typeof fn); 函数作为参数 因为函数也是一种类型，可以把函数作为两一个函数的参数，在两一个函数中调用 函数做为返回值 因为函数是一种类型，所以可以把函数可以作为返回值从函数内部返回，这种用法在后面很常见。 1234567function fn(b) &#123; var a = 10; return function () &#123; alert(a+b); &#125;&#125;fn(15)(); 代码规范1.命名规范 2.变量规范 var name = &apos;zs&apos;; 3.注释规范 // 这里是注释 4.空格规范 5.换行规范 var arr = [1, 2, 3, 4]; if (a &gt; b) { } for(var i = 0; i &lt; 10; i++) { } function fn() { } 作用域作用域：变量可以起作用的范围 全局变量和局部变量 全局变量 ​在任何地方都可以访问到的变量就是全局变量，对应全局作用域 局部变量 ​只在固定的代码片段内可访问到的变量，最常见的例如函数内部。对应局部作用域(函数作用域) 12不使用var声明的变量是全局变量，不推荐使用。变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁 块级作用域任何一对花括号（｛和｝）中的语句集都属于一个块，在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。在es5之前没有块级作用域的的概念,只有函数作用域，现阶段可以认为JavaScript没有块级作用域 词法作用域变量的作用域是在定义时决定而不是执行时决定，也就是说词法作用域取决于源码，通过静态分析就能确定，因此词法作用域也叫做静态作用域。 在 js 中词法作用域规则: 函数允许访问函数外的数据. 整个代码结构中只有函数可以限定作用域. 作用域规则首先使用提升规则分析 如果当前作用规则中有名字了, 就不考虑外面的名字 12345678910var num = 123;function foo() &#123; console.log( num );&#125;foo();if ( false ) &#123; var num = 123;&#125;console.log( num ); // undefiend 作用域链只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。 将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。 1234567891011// 案例1：function f1() &#123; function f2() &#123; &#125;&#125;var num = 456;function f3() &#123; function f4() &#123; &#125;&#125; 12345678910// 案例2function f1() &#123; var num = 123; function f2() &#123; console.log( num ); &#125; f2();&#125;var num = 456;f1(); 预解析 JavaScript代码的执行是由浏览器中的JavaScript解析器来执行的。JavaScript解析器执行JavaScript代码的时候，分为两个过程：预解析过程和代码执行过程 预解析过程： 把变量的声明提升到当前作用域的最前面，只会提升声明，不会提升赋值。 把函数的声明提升到当前作用域的最前面，只会提升声明，不会提升调用。 先提升var，在提升function JavaScript的执行过程 12345678910111213var a = 25;function abc ()&#123; alert(a);//undefined var a = 10;&#125;abc();// 如果变量和函数同名的话，函数优先console.log(a);function a() &#123; console.log('aaaaa');&#125;var a = 1;console.log(a); 全局解析规则函数内部解析规则变量提升 变量提升 定义变量的时候，变量的声明会被提升到作用域的最上面，变量的赋值不会提升。 函数提升 JavaScript解析器首先会把当前作用域的函数声明提前到整个作用域的最前面 123456789101112131415161718192021222324252627// 1、-----------------------------------var num = 10;fun();function fun() &#123; console.log(num); var num = 20;&#125;//2、-----------------------------------var a = 18;f1();function f1() &#123; var b = 9; console.log(a); console.log(b); var a = '123';&#125;// 3、-----------------------------------f1();console.log(c);console.log(b);console.log(a);function f1() &#123; var a = b = c = 9; console.log(a); console.log(b); console.log(c);&#125; 对象为什么要有对象1234567function printPerson(name, age, sex....) &#123;&#125;// 函数的参数如果特别多的话，可以使用对象简化function printPerson(person) &#123; console.log(person.name); ……&#125; 什么是对象12345现实生活中：万物皆对象，对象是一个具体的事物，一个具体的事物就会有行为和特征。举例： 一部车，一个手机车是一类事物，门口停的那辆车才是对象true特征：红色、四个轮子true行为：驾驶、刹车 JavaScript中的对象123456JavaScript中的对象其实就是生活中对象的一个抽象JavaScript的对象是无序属性的集合。true其属性可以包含基本值、对象或函数。对象就是一组没有顺序的值。我们可以把JavaScript中的对象想象成键值对，其中值可以是数据和函数。对象的行为和特征true特征---属性true行为---方法 事物的特征在对象中用属性来表示。 事物的行为在对象中用方法来表示。 对象字面量 字面量：11 ‘abc’ true [] {}等 12345678var o = &#123; name: 'zs, age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; 思考： 1如何把学生对象、老师对象、英雄对象改写成字面量的方式 对象创建方式 对象字面量 12345678var o = &#123; name: 'zs', age: 18, sex: true, sayHi: function () &#123; console.log(this.name); &#125;&#125;; new Object()创建对象 1234567var person = new Object(); person.name = 'lisi'; person.age = 35; person.job = 'actor'; person.sayHi = function()&#123; console.log('Hello,everyBody');&#125; 工厂函数创建对象 1234567891011function createPerson(name, age, job) &#123; var person = new Object(); person.name = name; person.age = age; person.job = job; person.sayHi = function()&#123; console.log('Hello,everyBody'); &#125; return person;&#125;var p1 = createPerson('张三', 22, 'actor'); 自定义构造函数 123456789function Person(name,age,job)&#123; this.name = name; this.age = age; this.job = job; this.sayHi = function()&#123; console.log('Hello,everyBody'); &#125;&#125;var p1 = new Person('张三', 22, 'actor'); 属性和方法如果一个变量属于一个对象所有，那么该变量就可以称之为该对象的一个属性，属性一般是名词，用来描述事物的特征 如果一个函数属于一个对象所有，那么该函数就可以称之为该对象的一个方法，方法是动词，描述事物的行为和功能 new关键字 构造函数 ，是一种特殊的函数。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 构造函数用于创建一类对象，首字母要大写。 构造函数要和new一起使用才有意义。 new在执行时会做四件事情 1234new会在内存中创建一个新的空对象new 会让this指向这个新的对象执行构造函数 目的：给这个新对象加属性和方法new会返回这个新对象 this详解JavaScript中的this指向问题，有时候会让人难以捉摸，随着学习的深入，我们可以逐渐了解 现在我们需要掌握函数内部的this几个特点 1. 函数在定义的时候this是不确定的，只有在调用的时候才可以确定 2. 一般函数直接执行，内部this指向全局window 3. 函数作为一个对象的方法，被该对象所调用，那么this指向的是该对象 4. 构造函数中的this其实是一个隐式对象，类似一个初始化的模型，所有方法和属性都挂载到了这个隐式对象身上，后续通过new关键字来调用，从而实现实例化 对象的使用遍历对象的属性 通过for..in语法可以遍历一个对象 1234567var obj = &#123;&#125;;for (var i = 0; i &lt; 10; i++) &#123; obj[i] = i * 2;&#125;for(var key in obj) &#123; console.log(key + "==" + obj[key]);&#125; 删除对象的属性1234567function fun() &#123; this.name = 'mm';&#125;var obj = new fun(); console.log(obj.name); // mm delete obj.name;console.log(obj.name); // undefined 简单类型和复杂类型的区别 基本类型又叫做值类型，复杂类型又叫做引用类型 值类型：简单数据类型，基本数据类型，在存储时，变量中存储的是值本身，因此叫做值类型。 引用类型：复杂数据类型，在存储是，变量中存储的仅仅是地址（引用），因此叫做引用数据类型。 堆和栈 123堆栈空间分配区别： 1、栈（操作系统）：由操作系统自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈； 2、堆（操作系统）： 存储复杂类型(对象)，一般由程序员分配释放， 若程序员不释放，由垃圾回收机制回收，分配方式倒是类似于链表。 注意：JavaScript中没有堆和栈的概念，此处我们用堆和栈来讲解，目的方便理解和方便以后的学习。 基本类型在内存中的存储 复杂类型在内存中的存储 基本类型作为函数的参数 复杂类型作为函数的参数 123456789101112131415// 下面代码输出的结果function Person(name,age,salary) &#123; this.name = name; this.age = age; this.salary = salary;&#125;function f1(person) &#123; person.name = "ls"; person = new Person("aa",18,10);&#125;var p = new Person("zs",18,1000);console.log(p.name);f1(p);console.log(p.name); 思考： 1234567891011121314151617181920212223242526272829303132//1. var num1 = 10;var num2 = num1;num1 = 20;console.log(num1);console.log(num2);//2. var num = 50;function f1(num) &#123; num = 60; console.log(num);&#125;f1(num);console.log(num);//3. var num1 = 55;var num2 = 66;function f1(num, num1) &#123; num = 100; num1 = 100; num2 = 100; console.log(num); console.log(num1); console.log(num2);&#125;f1(num1, num2);console.log(num1);console.log(num2);console.log(num); 内置对象JavaScript中的对象分为3种：内置对象、浏览器对象、自定义对象 JavaScript 提供多个内置对象：Math/Array/Number/String/Boolean… 对象只是带有属性和方法的特殊数据类型。 学习一个内置对象的使用，只要学会其常用的成员的使用（通过查文档学习） 可以通过MDN/W3C来查询 内置对象的方法很多，我们只需要知道内置对象提供的常用方法，使用的时候查询文档。 MDNMozilla 开发者网络（MDN）提供有关开放网络技术（Open Web）的信息，包括 HTML、CSS 和万维网及 HTML5 应用的 API。 MDN 通过查询MDN学习Math对象的random()方法的使用 如何学习一个方法？ 方法的功能 参数的意义和类型 返回值意义和类型 demo进行测试 Math对象Math对象不是构造函数，它具有数学常数和函数的属性和方法，都是以静态成员的方式提供 跟数学相关的运算来找Math中的成员（求绝对值，取整） Math 演示：Math.PI、Math.random()、Math.floor()/Math.ceil()、Math.round()、Math.abs() 、Math.max() 123456789Math.PI // 圆周率Math.random() // 生成随机数Math.floor()/Math.ceil() // 向下取整/向上取整Math.round() // 取整，四舍五入Math.abs() // 绝对值Math.max()/Math.min() // 求最大和最小值Math.sin()/Math.cos() // 正弦/余弦Math.power()/Math.sqrt() // 求指数次幂/求平方根 案例 求10-20之间的随机数 随机生成颜色RGB 模拟实现max()/min() Date对象创建 Date 实例用来处理日期和时间。Date 对象基于1970年1月1日（世界标准时间）起的毫秒数。 12345678// 获取当前时间，UTC世界时间，距1970年1月1日（世界标准时间）起的毫秒数var now = new Date();console.log(now.valueOf()); // 获取距1970年1月1日（世界标准时间）起的毫秒数Date构造函数的参数1. 毫秒数 1498099000356 new Date(1498099000356)2. 日期格式字符串 '2015-5-1' new Date('2015-5-1')3. 年、月、日…… new Date(2015, 4, 1) // 月份从0开始 获取日期的毫秒形式 123456789var now = new Date();// valueOf用于获取对象的原始值console.log(date.valueOf()) // HTML5中提供的方法，有兼容性问题var now = Date.now(); // 不支持HTML5的浏览器，可以用下面这种方式var now = + new Date(); // 调用 Date对象的valueOf() 日期格式化方法 1234567toString() // 转换成字符串valueOf() // 获取毫秒值// 下面格式化日期的方法，在不同浏览器可能表现不一致，一般不用toDateString()toTimeString()toLocaleDateString()toLocaleTimeString() 获取日期指定部分 123456789getTime() // 返回毫秒数和valueOf()结果一样，valueOf()内部调用的getTime()getMilliseconds() getSeconds() // 返回0-59getMinutes() // 返回0-59getHours() // 返回0-23getDay() // 返回星期几 0周日 6周6getDate() // 返回当前月的第几天getMonth() // 返回月份，***从0开始***getFullYear() //返回4位的年份 如 2016 案例 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式 123456789101112131415161718function formatDate(d) &#123; //如果date不是日期对象，返回 if (!date instanceof Date) &#123; return; &#125; var year = d.getFullYear(), month = d.getMonth() + 1, date = d.getDate(), hour = d.getHours(), minute = d.getMinutes(), second = d.getSeconds(); month = month &lt; 10 ? '0' + month : month; date = date &lt; 10 ? '0' + date : date; hour = hour &lt; 10 ? '0' + hour : hour; minute = minute &lt; 10 ? '0' + minute:minute; second = second &lt; 10 ? '0' + second:second; return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;&#125; 计算时间差，返回相差的天/时/分/秒 123456789101112131415function getInterval(start, end) &#123; var day, hour, minute, second, interval; interval = end - start; interval /= 1000; day = Math.round(interval / 60 /60 / 24); hour = Math.round(interval / 60 /60 % 24); minute = Math.round(interval / 60 % 60); second = Math.round(interval % 60); return &#123; day: day, hour: hour, minute: minute, second: second &#125;&#125; Array对象 创建数组对象的两种方式 字面量方式 new Array() 1234567891011121314// 1. 使用构造函数创建数组对象// 创建了一个空数组var arr = new Array();// 创建了一个数组，里面存放了3个字符串var arr = new Array('zs', 'ls', 'ww');// 创建了一个数组，里面存放了4个数字var arr = new Array(1, 2, 3, 4);// 2. 使用字面量创建数组对象var arr = [1, 2, 3];// 获取数组中元素的个数console.log(arr.length); 检测一个对象是否是数组 instanceof Array.isArray() HTML5中提供的方法，有兼容性问题 函数的参数，如果要求是一个数组的话，可以用这种方式来进行判断 toString()/valueOf() toString() 把数组转换成字符串，逗号分隔每一项 valueOf() 返回数组对象本身 数组常用方法 演示：push()、shift()、unshift()、reverse()、sort()、splice()、indexOf() 123456789101112131415161718192021// 1 栈操作(先进后出)push()pop() //取出数组中的最后一项，修改length属性// 2 队列操作(先进先出)push()shift() //取出数组中的第一个元素，修改length属性unshift() //在数组最前面插入项，返回数组的长度// 3 排序方法reverse() //翻转数组sort(); //即使是数组sort也是根据字符，从小到大排序// 带参数的sort是如何实现的？// 4 操作方法concat() //把参数拼接到当前数组slice() //从当前数组中截取一个新的数组，不影响原来的数组，参数start从0开始,end从1开始splice() //删除或替换当前数组的某些项目，参数start, deleteCount, options(要替换的项目)// 5 位置方法indexOf()、lastIndexOf() //如果没找到返回-1// 6 迭代方法 不会修改原数组(可选)every()、filter()、forEach()、map()、some()// 7 方法将数组的所有元素连接到一个字符串中。join() 清空数组 123456// 方式1 推荐 arr = [];// 方式2 arr.length = 0;// 方式3arr.splice(0, arr.length); 案例 将一个字符串数组输出为|分割的形式，比如“刘备|张飞|关羽”。使用两种方式实现 12345678910111213141516function myJoin(array, seperator) &#123; seperator = seperator || ','; array = array || []; if (array.length == 0)&#123; return ''; &#125; var str = array[0]; for (var i = 1; i &lt; array.length; i++) &#123; str += seperator + array[i]; &#125; return str;&#125;var array = [6, 3, 5, 6, 7, 8, 0];console.log(myJoin(array, '-'));console.log(array.join('-')) 将一个字符串数组的元素的顺序进行反转。[“a”, “b”, “c”, “d”] -&gt; [ “d”,”c”,”b”,”a”]。使用两种种方式实现。提示：第i个和第length-i-1个进行交换 12345678910111213141516function myReverse(arr) &#123; if (!arr || arr.length == 0) &#123; return []; &#125; for (var i = 0; i &lt; arr.length / 2; i++) &#123; var tmp = arr[i]; arr[i] = arr[this.length - i - 1]; arr[arr.length - i - 1] = tmp; &#125; return arr;&#125;var array = ['a', 'b', 'c'];console.log(myReverse(array));console.log(array.reverse()); 工资的数组[1500, 1200, 2000, 2100, 1800],把工资超过2000的删除 123456789101112131415161718// 方式1var array = [1500,1200,2000,2100,1800];var tmpArray = [];for (var i = 0; i &lt; array.length; i++) &#123; if(array[i] &lt; 2000) &#123; tmpArray.push(array[i]); &#125;&#125;console.log(tmpArray);// 方式2var array = [1500, 1200, 2000, 2100, 1800];array = array.filter(function (item, index) &#123; if (item &lt; 2000) &#123; return true; &#125; return false;&#125;);console.log(array); [“c”, “a”, “z”, “a”, “x”, “a”]找到数组中每一个a出现的位置 1234567var array = ['c', 'a', 'z', 'a', 'x', 'a'];do &#123; var index = array.indexOf('a',index + 1); if (index != -1)&#123; console.log(index); &#125;&#125; while (index &gt; 0); 编写一个方法去掉一个数组的重复元素 12345678910111213141516171819202122232425var array = ['c', 'a', 'z', 'a', 'x', 'a'];function clear() &#123; var o = &#123;&#125;; for (var i = 0; i &lt; array.length; i++) &#123; var item = array[i]; if (o[item]) &#123; o[item]++; &#125;else&#123; o[item] = 1; &#125; &#125; var tmpArray = []; for(var key in o) &#123; if (o[key] == 1) &#123; tmpArray.push(key); &#125;else&#123; if(tmpArray.indexOf(key) == -1)&#123; tmpArray.push(key); &#125; &#125; &#125; returm tmpArray;&#125;console.log(clear(array)); 基本包装类型为了方便操作基本数据类型，JavaScript还提供了三个特殊的引用类型：String/Number/Boolean 123456789// 下面代码的问题？// s1是基本类型，基本类型是没有方法的var s1 = 'zhangsan';var s2 = s1.substring(5);// 当调用s1.substring(5)的时候，先把s1包装成String类型的临时对象，再调用substring方法，最后销毁临时对象, 相当于：var s1 = new String('zhangsan');var s2 = s1.substring(5);s1 = null; 1234567// 创建基本包装类型的对象var num = 18; //数值，基本类型var num = Number('18'); //类型转换var num = new Number(18); //基本包装类型，对象// Number和Boolean基本包装类型基本不用，使用的话可能会引起歧义。例如：var b1 = new Boolean(false);var b2 = b1 &amp;&amp; true; // 结果是什么 String对象 字符串的不可变 12345var str = 'abc';str = 'hello';// 当重新给str赋值的时候，常量'abc'不会被修改，依然在内存中// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题 创建字符串对象 1234var str = new String('Hello World');// 获取字符串中字符的个数console.log(str.length); 字符串对象的常用方法 字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串 1234567891011121314151617181920212223// 1 字符方法charAt() //获取指定位置处字符charCodeAt() //获取指定位置处字符的ASCII码str[0] //HTML5，IE8+支持 和charAt()等效// 2 字符串操作方法concat() //拼接字符串，等效于+，+更常用slice() //从start位置开始，截取到end位置，end取不到substring() //从start位置开始，截取到end位置，end取不到substr() //从start位置开始，截取length个字符// 3 位置方法indexOf() //返回指定内容在元字符串中的位置lastIndexOf() //从后往前找，只找第一个匹配的// 4 去除空白 trim() //只能去除字符串前后的空白// 5 大小写转换方法to(Locale)UpperCase() //转换大写to(Locale)LowerCase() //转换小写// 6 其它search()replace()split()fromCharCode()// String.fromCharCode(101, 102, 103); //把ASCII码转换成字符串 案例 截取字符串”我爱中华人民共和国”，中的”中华” 123var s = "我爱中华人民共和国";s = s.substr(2,2);console.log(s); “abcoefoxyozzopp”查找字符串中所有o出现的位置 123456789var s = 'abcoefoxyozzopp';var array = [];do &#123; var index = s.indexOf('o', index + 1); if (index != -1) &#123; array.push(index); &#125;&#125; while (index &gt; -1);console.log(array); 把字符串中所有的o替换成! 1234567var s = 'abcoefoxyozzopp';do &#123; s = s.replace('o', '');&#125; while (s.indexOf('o') &gt; -1);console.log(s);console.log(s.replace(/o/ig, '')); 判断一个字符串中出现次数最多的字符，统计这个次数 1234567891011121314151617181920212223var s = 'abcoefoxyozzopp';var o = &#123;&#125;;for (var i = 0; i &lt; s.length; i++) &#123; var item = s.charAt(i); if (o[item]) &#123; o[item] ++; &#125;else&#123; o[item] = 1; &#125;&#125;var max = 0;var char ;for(var key in o) &#123; if (max &lt; o[key]) &#123; max = o[key]; char = key; &#125;&#125;console.log(max);console.log(char); 作业12345678给定一个字符串如：“abaasdffggghhjjkkgfddsssss3444343”问题如下： 1、 字符串的长度 2、 取出指定位置的字符，如：0,3,5,9等 3、 查找指定字符是否在以上字符串中存在，如：i，c ，b等 4、 替换指定的字符，如：g替换为22,ss替换为b等操作方法 5、 截取指定开始位置到结束位置的字符串，如：取得1-5的字符串6、 找出以上字符串中出现次数最多的字符和出现的次数 7、 遍历字符串，并将遍历出的字符两头添加符号“@”输出至当前的文档页面。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js api]]></title>
    <url>%2F2017%2F12%2F06%2F02-Web%20API%2F</url>
    <content type="text"><![CDATA[学习目标: 掌握API和Web API的概念 掌握常见的浏览器提供的API的调用方式 能通过API开发常见的页面交互功能 能够利用搜索引擎解决问题typora-copy-images-to: media Web APIWeb API介绍API的概念API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，目的是提供应用程序与开发人员基于某软件或硬件得以访问一组例程的能力，而又无需访问源码，或理解内部工作机制的细节。 任何开发语言都有自己的API API的特征输入和输出(I/O) API的使用方法(console.log()) Web API的概念浏览器提供的一套操作浏览器功能和页面元素的API(BOM和DOM) 此处的Web API特指浏览器提供的API(一组方法)，Web API在后面的课程中有其它含义 掌握常见的浏览器提供的API的调用方式MDN-Web API JavaScript的组成 ECMAScript - JavaScript的核心定义了javascript的语法规范 JavaScript的核心，描述了语言的基本语法和数据类型，ECMAScript是一套标准，定义了一种语言的标准与具体实现无关 BOM - 浏览器对象模型一套操作浏览器功能的API 通过BOM可以操作浏览器窗口，比如：弹出框、控制浏览器跳转、获取分辨率等 DOM - 文档对象模型一套操作页面元素的API DOM可以把HTML看做是文档树，通过DOM提供的API可以对树上的节点进行操作 BOMBOM的概念BOM(Browser Object Model) 是指浏览器对象模型，浏览器对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。 我们在浏览器中的一些操作都可以使用BOM的方式进行编程处理， 比如：刷新浏览器、后退、前进、在浏览器中输入URL等 BOM的顶级对象windowwindow是浏览器的顶级对象，当调用window下的属性和方法时，可以省略window注意：window下一个特殊的属性 window.name 对话框 alert() prompt() confirm() 页面加载事件 onload 1234window.onload = function () &#123; // 当页面加载完成执行 // 当页面完全加载所有内容（包括图像、脚本文件、CSS 文件等）执行&#125; onunload 123window.onunload = function () &#123; // 当用户退出页面时执行&#125; 定时器setTimeout()和clearTimeout()在指定的毫秒数到达之后执行指定的函数，只执行一次 1234567// 创建一个定时器，1000毫秒后执行，返回定时器的标示var timerId = setTimeout(function () &#123; console.log('Hello World');&#125;, 1000);// 取消定时器的执行clearTimeout(timerId); setInterval()和clearInterval()定时调用的函数，可以按照给定的时间(单位毫秒)周期调用函数 12345678// 创建一个定时器，每隔1秒调用一次var timerId = setInterval(function () &#123; var date = new Date(); console.log(date.toLocaleTimeString());&#125;, 1000);// 取消定时器的执行clearInterval(timerId); location对象location对象是window对象下的一个属性，时候的时候可以省略window对象 location可以获取或者设置浏览器地址栏的URL URL统一资源定位符 (Uniform Resource Locator, URL) URL的组成 12345678910111213scheme://host:port/path?query#fragmentscheme:通信协议true常用的http,ftp,maito等host:主机true服务器(计算机)域名系统 (DNS) 主机名或 IP 地址。port:端口号true整数，可选，省略时使用方案的默认端口，如http的默认端口为80。path:路径true由零或多个&apos;/&apos;符号隔开的字符串，一般用来表示主机上的一个目录或文件地址。query:查询true可选，用于给动态网页传递参数，可有多个参数，用&apos;&amp;&apos;符号隔开，每个参数的名和值用&apos;=&apos;符号隔开。例如：name=zsfragment:信息片断true字符串，锚点. location有哪些成员？ 使用chrome的控制台查看 查MDN MDN 成员 assign()/reload()/replace() hash/host/hostname/search/href…… 案例解析URL中的query，并返回对象的形式 1234567891011121314151617function getQuery(queryStr) &#123; var query = &#123;&#125;; if (queryStr.indexOf('?') &gt; -1) &#123; var index = queryStr.indexOf('?'); queryStr = queryStr.substr(index + 1); var array = queryStr.split('&amp;'); for (var i = 0; i &lt; array.length; i++) &#123; var tmpArr = array[i].split('='); if (tmpArr.length === 2) &#123; query[tmpArr[0]] = tmpArr[1]; &#125; &#125; &#125; return query;&#125;console.log(getQuery(location.search));console.log(getQuery(location.href)); history对象 back() forward() go() navigator对象 userAgent 通过userAgent可以判断用户浏览器的类型 platform 通过platform可以判断浏览器所在的系统平台类型. DOMDOM的概念文档对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标志语言的标准编程接口。在网页上，组织页面（或文档）的对象被组织在一个树形结构中，用来表示文档中对象的标准模型就称为DOM。Document Object Model的历史可以追溯至1990年代后期微软与Netscape的“浏览器大战”，双方为了在JavaScript与JScript一决生死，于是大规模的赋予浏览器强大的功能。微软在网页技术上加入了不少专属事物，既有VBScript、ActiveX、以及微软自家的DHTML格式等，使不少网页使用非微软平台及浏览器无法正常显示。DOM即是当时蕴酿出来的杰作。 DOM又称为文档树模型 文档：一个网页可以称为文档 节点：网页中的所有内容都是节点（标签、属性、文本、注释等） 元素：网页中的标签 属性：标签的属性 模拟文档树结构 12345678910111213141516171819202122232425262728293031323334353637383940function Element(option) &#123; this.id = option.id || ''; this.nodeName = option.nodeName || ''; this.nodeValue = option.nodeValue || ''; this.nodeType = 1; this.children = option.children || [];&#125;var doc = new Element(&#123; nodeName: 'html'&#125;);var head = new Element(&#123; nodeName: 'head'&#125;);var body = new Element(&#123; nodeName: 'body'&#125;)doc.children.push(head);doc.children.push(body);var div = new Element(&#123; nodeName: 'div', nodeValue: 'haha',&#125;);var p = new Element(&#123; nodeName: 'p', nodeValue: '段落'&#125;)body.children.push(div);body.children.push(p);function getChildren(ele) &#123; for(var i = 0; i &lt; ele.children.length; i++) &#123; var child = ele.children[i]; console.log(child.nodeName); getChildren(child); &#125;&#125;getChildren(doc); DOM经常进行的操作 获取元素 动态创建元素 对元素进行操作(设置其属性或调用其方法) 事件(什么时机做相应的操作) 获取页面元素##案例1.点击按钮弹出对话框2.点击按钮修改超链接的地址和热点文字3.点击(每个)图片弹出对话框4.点击图片设置自身宽和高5.点击按钮修改每个图片的title属性6.点击按钮显示哈哈(排他功能)7.点击按钮显示和隐藏div8.显示和隐藏二维码9.点击按钮修改所有p标签内容10.点击按钮修改所有文本框内容11.点击按钮切换图片12.点击超链接停止跳转页面13.点击小图显示大图14.美女相册15点击按钮选中性别和兴趣 为什么要获取页面元素例如：我们想要操作页面上的某部分(显示/隐藏，动画)，需要先获取到该部分对应的元素，才进行后续操作 根据id获取元素12345var div = document.getElementById('main');console.log(div);// 获取到的数据类型 HTMLDivElement，对象都是有类型的// HTMLDivElement &lt;-- HTMLElement &lt;-- Element &lt;-- Node &lt;-- EventTarget 注意：由于id名具有唯一性，部分浏览器支持直接使用id名访问元素，但不是标准方式，不推荐使用。 根据标签名获取元素12345var divs = document.getElementsByTagName('div');for (var i = 0; i &lt; divs.length; i++) &#123; var div = divs[i]; console.log(div);&#125; 根据name获取元素*12345var inputs = document.getElementsByName('hobby');for (var i = 0; i &lt; inputs.length; i++) &#123; var input = inputs[i]; console.log(input);&#125; 根据类名获取元素12345var mains = document.getElementsByClassName('main');for (var i = 0; i &lt; mains.length; i++) &#123; var main = mains[i]; console.log(main);&#125; 根据选择器获取元素12345678var text = document.querySelector('#text');console.log(text);var boxes = document.querySelectorAll('.box');for (var i = 0; i &lt; boxes.length; i++) &#123; var box = boxes[i]; console.log(box);&#125; 总结 12345678掌握truegetElementById()truegetElementsByTagName()了解truegetElementsByName()truegetElementsByClassName()truequerySelector()truequerySelectorAll() 事件事件：触发-响应机制 Event接口表示在DOM中发生的任何事件，一些是用户生成的（例如鼠标或键盘事件），而其他由API生成。 事件三要素 事件源:触发(被)事件的元素 事件类型:事件的触发方式(例如鼠标点击或键盘点击) 事件处理程序:事件触发后要执行的代码(函数形式) 事件的基本使用1234var box = document.getElementById('box');box.onclick = function() &#123; console.log('代码会在box被点击后执行'); &#125;; 案例 点击按钮弹出提示框 点击按钮修改元素的样式 属性操作非表单元素的属性href、title、id、src、className 123456var link = document.getElementById('link');console.log(link.href);console.log(link.title);var pic = document.getElementById('pic');console.log(pic.src); 案例： ​ 点击按钮，切换img标签里的图片 ​ 点击按钮显示隐藏div innerHTML和innerText 12345var box = document.getElementById('box');box.innerHTML = '我是文本&lt;p&gt;我会生成为标签&lt;/p&gt;';console.log(box.innerHTML);box.innerText = '我是文本&lt;p&gt;我不会生成为标签&lt;/p&gt;';console.log(box.innerText); HTML转义符 1234567&quot; &amp;quot;‘ &amp;apos;&amp; &amp;amp;&lt; &amp;lt; //less than 小于&gt; &amp;gt; // greater than 大于空格 &amp;nbsp;© &amp;copy; innerHTML和innerText的区别 innerText的兼容性处理 表单元素属性 value 用于大部分表单元素的内容获取(option除外) type 可以获取input标签的类型(输入框或复选框等) disabled 禁用属性 checked 复选框选中属性 selected 下拉菜单选中属性 案例 给文本框赋值，获取文本框的值 点击按钮禁用文本框 搜索文本框 检测用户名是否是3-6位，密码是否是6-8位，如果不满足要求高亮显示文本框 设置下拉框中的选中项 全选反选 自定义属性操作 getAttribute() 获取标签行内属性 setAttribute() 设置标签行内属性 removeAttribute() 移除标签行内属性 与element.属性的区别: 上述三个方法用于获取任意的行内属性。 样式操作 使用style方式设置的样式显示在标签行内 1234var box = document.getElementById('box');box.style.width = '100px';box.style.height = '100px';box.style.backgroundColor = 'red'; 注意 通过样式属性设置宽高、位置的属性类型是字符串，需要加上px 类名操作 修改标签的className属性相当于直接修改标签的类名12var box = document.getElementById('box');box.className = 'clearfix'; 案例 开关灯 点击按钮变色 图片切换二维码案例 当前输入的文本框高亮显示 点击按钮改变div的大小和位置 列表隔行变色、高亮显示 京东商品展示 tab选项卡切换 创建元素的三种方式document.write()1document.write('新设置的内容&lt;p&gt;标签也可以生成&lt;/p&gt;'); innerHTML12var box = document.getElementById('box');box.innerHTML = '新内容&lt;p&gt;新标签&lt;/p&gt;'; document.createElement()12var div = document.createElement('div');document.body.appendChild(div); 性能问题 innerHTML方法由于会对字符串进行解析，需要避免在循环内多次使用。 可以借助字符串或数组的方式进行替换，再设置给innerHTML 优化后与document.createElement性能相近 案例 动态创建列表，高亮显示 根据数据动态创建表格 模拟百度搜索文本框 节点操作1234567891011var body = document.body;var div = document.createElement('div');body.appendChild(div);var firstEle = body.children[0];body.insertBefore(div,firstEle);body.removeChild(firstEle);var text = document.createElement('p');body.replaceChild(text, div); 案例： ​ 权限选择 节点层级重点讲父子属性，兄弟属性画图讲解 12345678var box = document.getElementById('box');console.log(box.parentNode);console.log(box.childNodes);console.log(box.children);console.log(box.nextSibling);console.log(box.previousSibling);console.log(box.firstChild);console.log(box.lastChild); 注意 childNodes和children的区别，childNodes获取的是子节点，children获取的是子元素 nextSibling和previousSibling获取的是节点，获取元素对应的属性是nextElementSibling和previousElementSibling获取的是元素 ​ nextElementSibling和previousElementSibling有兼容性问题，IE9以后才支持 总结 1234567891011节点操作，方法trueappendChild()trueinsertBefore()trueremoveChild()truereplaceChild()节点层次，属性trueparentNodetruechildNodestruechildrentruenextSibling/previousSiblingtruefirstChild/lastChild 事件详解注册/移除事件的三种方式123456789101112131415var box = document.getElementById('box');box.onclick = function () &#123; console.log('点击后执行');&#125;;box.onclick = null;box.addEventListener('click', eventCode, false);box.removeEventListener('click', eventCode, false);box.attachEvent('onclick', eventCode);box.detachEvent('onclick', eventCode);function eventCode() &#123; console.log('点击后执行');&#125; 兼容代码12345678910111213141516171819function addEventListener(element, type, fn) &#123; if (element.addEventListener) &#123; element.addEventListener(type, fn, false); &#125; else if (element.attachEvent)&#123; element.attachEvent('on' + type,fn); &#125; else &#123; element['on'+type] = fn; &#125;&#125;function removeEventListener(element, type, fn) &#123; if (element.removeEventListener) &#123; element.removeEventListener(type, fn, false); &#125; else if (element.detachEvent) &#123; element.detachEvent('on' + type, fn); &#125; else &#123; element['on'+type] = null; &#125;&#125; 事件的三个阶段 捕获阶段 当前目标阶段 冒泡阶段 事件对象.eventPhase属性可以查看事件触发时所处的阶段 事件对象的属性和方法 event.type 获取事件类型 clientX/clientY 所有浏览器都支持，窗口位置 pageX/pageY IE8以前不支持，页面位置 event.target || event.srcElement 用于获取触发事件的元素 event.preventDefault() 取消默认行为 案例 跟着鼠标飞的天使 鼠标点哪图片飞到哪里 获取鼠标在div内的坐标 阻止事件传播的方式 标准方式 event.stopPropagation(); IE低版本 event.cancelBubble = true; 标准中已废弃 常用的鼠标和键盘事件 onmouseup 鼠标按键放开时触发 onmousedown 鼠标按键按下触发 onmousemove 鼠标移动触发 onkeyup 键盘按键按下触发 onkeydown 键盘按键抬起触发 特效偏移量 offsetParent用于获取定位的父级元素 offsetParent和parentNode的区别 123456var box = document.getElementById('box');console.log(box.offsetParent);console.log(box.offsetLeft);console.log(box.offsetTop);console.log(box.offsetWidth);console.log(box.offsetHeight); 客户区大小12345var box = document.getElementById('box');console.log(box.clientLeft);console.log(box.clientTop);console.log(box.clientWidth);console.log(box.clientHeight); 滚动偏移12345var box = document.getElementById('box');console.log(box.scrollLeft)console.log(box.scrollTop)console.log(box.scrollWidth)console.log(box.scrollHeight) 案例 匀速动画函数 变速动画函数 回到顶部 无缝轮播图 模拟滚动条 拖拽案例 放大镜案例 附录元素的类型]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js高级]]></title>
    <url>%2F2017%2F12%2F06%2F03-JavaScript%E9%AB%98%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[学习目标: 理解面向对象开发思想 掌握 JavaScript 面向对象开发相关模式 掌握在 JavaScript 中使用正则表达式 typora-copy-images-to: media JavaScript 高级 课程介绍课程大纲在线地址：JavaScript 高级 目标 理解面向对象开发思想 掌握 JavaScript 面向对象开发相关模式 掌握在 JavaScript 中使用正则表达式 案例演示 贪吃蛇 基本概念复习 由于 JavaScript 高级还是针对 JavaScript 语言本身的一个进阶学习，所以在开始之前我们先对以前所学过的 JavaScript 相关知识点做一个快速复习总结。 重新介绍 JavaScriptJavaScript 是什么 解析执行：轻量级解释型的，或是 JIT 编译型的程序设计语言 语言特点：动态，头等函数 (First-class Function) 又称函数是 JavaScript 中的一等公民 执行环境：在宿主环境（host environment）下运行，浏览器是最常见的 JavaScript 宿主环境 但是在很多非浏览器环境中也使用 JavaScript ，例如 node.js 编程范式：基于原型、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如：函数式编程）编程风格 JavaScript 与浏览器的关系 JavaScript 的组成 组成部分 说明 Ecmascript 描述了该语言的语法和基本对象 DOM 描述了处理网页内容的方法和接口 BOM 描述了与浏览器进行交互的方法和接口 JavaScript 可以做什么 Any application that can be written in JavaScript, will eventually be written in JavaScript.凡是能用 JavaScript 写出来的，最终都会用 JavaScript 写出来 知乎 - JavaScript 能做什么，该做什么？ 最流行的编程语言 JavaScript 能做什么？ JavaScript 发展历史 JavaScript 标准参考教程 - JavaScript 语言的历史 JavaScript 的诞生 JavaScript 与 Ecmascript 的关系 JavaScript 与 Java 的关系 JavaScript 的版本 JavaScript 周边大事记 小结基本概念 本小节快速过即可，主要是对学过的内容做知识点梳理。 语法 区分大小写 标识符 注释 严格模式 语句 关键字和保留字 变量 数据类型 typeof 操作符 Undefined Null Boolean Number String Object 操作符 流程控制语句 函数 JavaScript 中的数据类型JavaScript 有 5 种简单数据类型：Undefined、Null、Boolean、Number、String 和 1 种复杂数据类型 Object 。 基本类型（值类型） Undefined Null Boolean Number String 复杂类型（引用类型） Object Array Date RegExp Function 基本包装类型 Boolean Number String 单体内置对象 Global Math 类型检测 typeof instanceof Object.prototype.toString.call() 值类型和引用类型在内存中的存储方式（画图说明） 值类型按值存储 引用类型按引用存储 值类型复制和引用类型复制（画图说明） 值类型按值复制 引用类型按引用复制 值类型和引用类型参数传递（画图说明） 值类型按值传递 引用类型按引用传递 值类型与引用类型的差别 基本类型在内存中占据固定大小的空间，因此被保存在栈内存中 从一个变量向另一个变量复制基本类型的值，复制的是值的副本 引用类型的值是对象，保存在堆内存 包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针 从一个变量向另一个变量复制引用类型的值的时候，复制是引用指针，因此两个变量最终都指向同一个对象 小结 类型检测方式 值类型和引用类型的存储方式 值类型复制和引用类型复制 方法参数中 值类型数据传递 和 引用类型数据传递 JavaScript 执行过程JavaScript 运行分为两个阶段： 预解析 全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高） 函数内部预解析（所有的变量、函数和形参都会参与预解析） 函数 形参 普通变量 执行 先预解析全局作用域，然后执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。 JavaScript 面向对象编程 面向对象介绍什么是对象 Everything is object （万物皆对象） 对象到底是什么，我们可以从两次层次来理解。 (1) 对象是单个事物的抽象。 一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。 (2) 对象是一个容器，封装了属性（property）和方法（method）。 属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为animal对象，使用“属性”记录具体是那一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。 在实际开发中，对象是一个抽象的概念，可以将其简单理解为：数据集或功能集。 ECMAScript-262 把对象定义为：无序属性的集合，其属性可以包含基本值、对象或者函数。严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。 提示：每个对象都是基于一个引用类型创建的，这些类型可以是系统内置的原生类型，也可以是开发人员自定义的类型。 什么是面向对象 面向对象不是新的东西，它只是过程式代码的一种高度封装，目的在于提高代码的开发效率和可维护性。 面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。 在面向对象程序开发思想中，每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。 面向对象与面向过程： 面向过程就是亲力亲为，事无巨细，面面俱到，步步紧跟，有条不紊 面向对象就是找一个对象，指挥得结果 面向对象将执行者转变成指挥者 面向对象不是面向过程的替代，而是面向过程的封装 面向对象的特性： 封装性 继承性 [多态性] 扩展阅读： 维基百科 - 面向对象程序设计 知乎：如何用一句话说明什么是面向对象思想？ 知乎：什么是面向对象编程思想？ 程序中面向对象的基本体现在 JavaScript 中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（ Class ）的概念。 我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处。 假设我们要处理学生的成绩表，为了表示一个学生的成绩，面向过程的程序可以用一个对象表示： 12var std1 = &#123; name: 'Michael', score: 98 &#125;var std2 = &#123; name: 'Bob', score: 81 &#125; 而处理学生成绩可以通过函数实现，比如打印学生的成绩： 123function printScore (student) &#123; console.log('姓名：' + student.name + ' ' + '成绩：' + student.score)&#125; 如果采用面向对象的程序设计思想，我们首选思考的不是程序的执行流程，而是 Student 这种数据类型应该被视为一个对象，这个对象拥有 name 和 score 这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 printScore 消息，让对象自己把自己的数据打印出来。 抽象数据行为模板（Class）： 12345678function Student (name, score) &#123; this.name = name this.score = score&#125;Student.prototype.printScore = function () &#123; console.log('姓名：' + this.name + ' ' + '成绩：' + this.score)&#125; 根据模板创建具体实例对象（Instance）： 12var std1 = new Student('Michael', 98)var std2 = new Student('Bob', 81) 实例对象具有自己的具体行为（给对象发消息）： 12std1.printScore() // =&gt; 姓名：Michael 成绩：98std2.printScore() // =&gt; 姓名：Bob 成绩 81 面向对象的设计思想是从自然界中来的，因为在自然界中，类（Class）和实例（Instance）的概念是很自然的。Class 是一种抽象概念，比如我们定义的 Class——Student ，是指学生这个概念，而实例（Instance）则是一个个具体的 Student ，比如， Michael 和 Bob 是两个具体的 Student 。 所以，面向对象的设计思想是： 抽象出 Class 根据 Class 创建 Instance 指挥 Instance 得结果 面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。 创建对象简单方式我们可以直接通过 new Object() 创建： 1234567var person = new Object()person.name = 'Jack'person.age = 18person.sayName = function () &#123; console.log(this.name)&#125; 每次创建通过 new Object() 比较麻烦，所以可以通过它的简写形式对象字面量来创建： 1234567var person = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125; 对于上面的写法固然没有问题，但是假如我们要生成两个 person 实例对象呢？ 123456789101112131415var person1 = &#123; name: 'Jack', age: 18, sayName: function () &#123; console.log(this.name) &#125;&#125;var person2 = &#123; name: 'Mike', age: 16, sayName: function () &#123; console.log(this.name) &#125;&#125; 通过上面的代码我们不难看出，这样写的代码太过冗余，重复性太高。 简单方式的改进：工厂函数我们可以写一个函数，解决代码重复问题： 123456789function createPerson (name, age) &#123; return &#123; name: name, age: age, sayName: function () &#123; console.log(this.name) &#125; &#125;&#125; 然后生成实例对象： 12var p1 = createPerson('Jack', 18)var p2 = createPerson('Mike', 18) 这样封装确实爽多了，通过工厂模式我们解决了创建多个相似对象代码冗余的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。 构造函数内容引导： 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 普通函数调用和构造函数调用的区别 构造函数的返回值 构造函数的静态成员和实例成员 函数也是对象 实例成员 静态成员 构造函数的问题 更优雅的工厂函数：构造函数一种更优雅的工厂函数就是下面这样，构造函数： 12345678910111213function Person (name, age) &#123; this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125;&#125;var p1 = new Person('Jack', 18)p1.sayName() // =&gt; Jackvar p2 = new Person('Mike', 23)p2.sayName() // =&gt; Mike 解析构造函数代码的执行在上面的示例中，Person() 函数取代了 createPerson() 函数，但是实现效果是一样的。这是为什么呢？ 我们注意到，Person() 中的代码与 createPerson() 有以下几点不同之处： 没有显示的创建对象 直接将属性和方法赋给了 this 对象 没有 return 语句 函数名使用的是大写的 Person 而要创建 Person 实例，则必须使用 new 操作符。以这种方式调用构造函数会经历以下 4 个步骤： 创建一个新对象 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） 执行构造函数中的代码 返回新对象 下面是具体的伪代码： 12345678910111213141516function Person (name, age) &#123; // 当使用 new 操作符调用 Person() 的时候，实际上这里会先创建一个对象 // var instance = &#123;&#125; // 然后让内部的 this 指向 instance 对象 // this = instance // 接下来所有针对 this 的操作实际上操作的就是 instance this.name = name this.age = age this.sayName = function () &#123; console.log(this.name) &#125; // 在函数的结尾处会将 this 返回，也就是 instance // return this&#125; 构造函数和实例对象的关系使用构造函数的好处不仅仅在于代码的简洁性，更重要的是我们可以识别对象的具体类型了。在每一个实例对象中的__proto__中同时有一个 constructor 属性，该属性指向创建该实例的构造函数： 123console.log(p1.constructor === Person) // =&gt; trueconsole.log(p2.constructor === Person) // =&gt; trueconsole.log(p1.constructor === p2.constructor) // =&gt; true 对象的 constructor 属性最初是用来标识对象类型的，但是，如果要检测对象的类型，还是使用 instanceof 操作符更可靠一些： 12console.log(p1 instanceof Person) // =&gt; trueconsole.log(p2 instanceof Person) // =&gt; true 总结： 构造函数是根据具体的事物抽象出来的抽象模板 实例对象是根据抽象的构造函数模板得到的具体实例对象 每一个实例对象都具有一个 constructor 属性，指向创建该实例的构造函数 注意： constructor 是实例的属性的说法不严谨，具体后面的原型会讲到 可以通过实例的 constructor 属性判断实例和构造函数之间的关系 注意：这种方式不严谨，推荐使用 instanceof 操作符，后面学原型会解释为什么 构造函数的问题使用构造函数带来的最大的好处就是创建对象更方便了，但是其本身也存在一个浪费内存的问题： 1234567891011function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = function () &#123; console.log('hello ' + this.name) &#125;&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16) 在该示例中，从表面上好像没什么问题，但是实际上这样做，有一个很大的弊端。那就是对于每一个实例对象，type 和 sayHello 都是一模一样的内容，每一次生成一个实例，都必须为重复的内容，多占用一些内存，如果实例对象很多，会造成极大的内存浪费。 1console.log(p1.sayHello === p2.sayHello) // =&gt; false 对于这种问题我们可以把需要共享的函数定义到构造函数外部： 123456789101112131415function sayHello = function () &#123; console.log('hello ' + this.name)&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = sayHello&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; true 这样确实可以了，但是如果有多个需要共享的函数的话就会造成全局命名空间冲突的问题。 你肯定想到了可以把多个函数放到一个对象中用来避免全局命名空间冲突的问题： 12345678910111213141516171819202122var fns = &#123; sayHello: function () &#123; console.log('hello ' + this.name) &#125;, sayAge: function () &#123; console.log(this.age) &#125;&#125;function Person (name, age) &#123; this.name = name this.age = age this.type = 'human' this.sayHello = fns.sayHello this.sayAge = fns.sayAge&#125;var p1 = new Person('lpz', 18)var p2 = new Person('Jack', 16)console.log(p1.sayHello === p2.sayHello) // =&gt; trueconsole.log(p1.sayAge === p2.sayAge) // =&gt; true 至此，我们利用自己的方式基本上解决了构造函数的内存浪费问题。但是代码看起来还是那么的格格不入，那有没有更好的方式呢？ 小结 构造函数语法 分析构造函数 构造函数和实例对象的关系 实例的 constructor 属性 instanceof 操作符 构造函数的问题 原型内容引导： 使用 prototype 原型对象解决构造函数的问题 分析 构造函数、prototype 原型对象、实例对象 三者之间的关系 属性成员搜索原则：原型链 实例对象读写原型对象中的成员 原型对象的简写形式 原生对象的原型 Object Array String … 原型对象的问题 构造的函数和原型对象使用建议 更好的解决方案： prototypeJavascript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。这个对象的所有属性和方法，都会被构造函数的实例继承。 这也就意味着，我们可以把所有对象实例需要共享的属性和方法直接定义在 prototype 对象上。 1234567891011121314151617function Person (name, age) &#123; this.name = name this.age = age&#125;console.log(Person.prototype)Person.prototype.type = 'human'Person.prototype.sayName = function () &#123; console.log(this.name)&#125;var p1 = new Person(...)var p2 = new Person(...)console.log(p1.sayName === p2.sayName) // =&gt; true 这时所有实例的 type 属性和 sayName() 方法，其实都是同一个内存地址，指向 prototype 对象，因此就提高了运行效率。 构造函数、实例、原型三者之间的关系 任何函数都具有一个 prototype 属性，该属性是一个对象。 123456function F () &#123;&#125;console.log(F.prototype) // =&gt; objectF.prototype.sayHi = function () &#123; console.log('hi!')&#125; 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数。 1console.log(F.constructor === F) // =&gt; true 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__。 12var instance = new F()console.log(instance.__proto__ === F.prototype) // =&gt; true __proto__ 是非标准属性。 实例对象可以直接访问原型对象成员。 1instance.sayHi() // =&gt; hi! 总结： 任何函数都具有一个 prototype 属性，该属性是一个对象 构造函数的 prototype 对象默认都有一个 constructor 属性，指向 prototype 对象所在函数 通过构造函数得到的实例对象内部会包含一个指向构造函数的 prototype 对象的指针 __proto__ 所有实例都直接或间接继承了原型对象的成员 属性成员的搜索原则：原型链了解了 构造函数-实例-原型对象 三者之间的关系后，接下来我们来解释一下为什么实例对象可以访问原型对象中的成员。 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性 搜索首先从对象实例本身开始 如果在实例中找到了具有给定名字的属性，则返回该属性的值 如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性 如果在原型对象中找到了这个属性，则返回该属性的值 也就是说，在我们调用 person1.sayName() 的时候，会先后执行两次搜索： 首先，解析器会问：“实例 person1 有 sayName 属性吗？”答：“没有。 ”然后，它继续搜索，再问：“ person1 的原型有 sayName 属性吗？”答：“有。 ”于是，它就读取那个保存在原型对象中的函数。 当我们调用 person2.sayName() 时，将会重现相同的搜索过程，得到相同的结果。 而这正是多个对象实例共享原型所保存的属性和方法的基本原理。 总结： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 实例对象读写原型对象成员读取： 先在自己身上找，找到即返回 自己身上找不到，则沿着原型链向上查找，找到即返回 如果一直到原型链的末端还没有找到，则返回 undefined 值类型成员写入（实例对象.值类型成员 = xx）： 当实例期望重写原型对象中的某个普通数据成员时实际上会把该成员添加到自己身上 也就是说该行为实际上会屏蔽掉对原型对象成员的访问 引用类型成员写入（实例对象.引用类型成员 = xx）： 同上 复杂类型修改（实例对象.成员.xx = xx）： 同样会先在自己身上找该成员，如果自己身上找到则直接修改 如果自己身上找不到，则沿着原型链继续查找，如果找到则修改 如果一直到原型链的末端还没有找到该成员，则报错（实例对象.undefined.xx = xx） 更简单的原型语法我们注意到，前面例子中每添加一个属性和方法就要敲一遍 Person.prototype 。为减少不必要的输入，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象： 1234567891011function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 在该示例中，我们将 Person.prototype 重置到了一个新的对象。这样做的好处就是为 Person.prototype 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 constructor 成员。 所以，我们为了保持 constructor 的指向正确，建议的写法是： 123456789101112function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; constructor: Person, // =&gt; 手动将 constructor 指向正确的构造函数 type: 'human', sayHello: function () &#123; console.log('我叫' + this.name + '，我今年' + this.age + '岁了') &#125;&#125; 原生对象的原型 所有函数都有 prototype 属性对象。 Object.prototype Function.prototype Array.prototype String.prototype Number.prototype Date.prototype … 练习：为数组对象和字符串对象扩展原型方法。 原型对象的问题 共享数组 共享对象 如果真的希望可以被实例对象之间共享和修改这些共享数据那就不是问题。但是如果不希望实例之间共享和修改这些共享数据则就是问题。 一个更好的建议是，最好不要让实例之间互相共享这些数组或者对象成员，一旦修改的话会导致数据的走向很不明确而且难以维护。 原型对象使用建议 私有成员（一般就是非函数成员）放到构造函数中 共享成员（一般就是函数）放到原型对象中 如果重置了 prototype 记得修正 constructor 的指向 案例：随机方块 面向对象游戏案例：贪吃蛇案例相关源码以上传到 GitHub ：https://github.com/lipengzhou/new-snake 案例介绍游戏演示在线演示地址：贪吃蛇 案例目标游戏的目的是用来体会js高级语法的使用 不需要具备抽象对象的能力，使用面向对象的方式分析问题，需要一个漫长的过程。 功能实现搭建页面放一个容器盛放游戏场景 div#map，设置样式 123456#map &#123; width: 800px; height: 600px; background-color: #ccc; position: relative;&#125; 分析对象 游戏对象 蛇对象 食物对象 创建食物对象 Food 属性 x y width height color 方法 render 随机创建一个食物对象，并输出到map上 创建Food的构造函数，并设置属性 1234567891011var position = 'absolute';var elements = [];function Food(x, y, width, height, color) &#123; this.x = x || 0; this.y = y || 0; // 食物的宽度和高度(像素) this.width = width || 20; this.height = height || 20; // 食物的颜色 this.color = color || 'green';&#125; 通过原型设置render方法，实现随机产生食物对象，并渲染到map上 12345678910111213141516Food.prototype.render = function (map) &#123; // 随机食物的位置，map.宽度/food.宽度，总共有多少分food的宽度，随机一下。然后再乘以food的宽度 this.x = parseInt(Math.random() * map.offsetWidth / this.width) * this.width; this.y = parseInt(Math.random() * map.offsetHeight / this.height) * this.height; // 动态创建食物对应的div var div = document.createElement('div'); map.appendChild(div); div.style.position = position; div.style.left = this.x + 'px'; div.style.top = this.y + 'px'; div.style.width = this.width + 'px'; div.style.height = this.height + 'px'; div.style.backgroundColor = this.color; elements.push(div);&#125; 通过自调用函数，进行封装，通过window暴露Food对象 1window.Food = Food; 创建蛇对象 Snake 属性 width 蛇节的宽度 默认20 height 蛇节的高度 默认20 body 数组，蛇的头部和身体，第一个位置是蛇头 direction 蛇运动的方向 默认right 可以是 left top bottom 方法 render 把蛇渲染到map上 Snake构造函数 1234567891011121314var position = 'absolute';var elements = [];function Snake(width, height, direction) &#123; // 设置每一个蛇节的宽度 this.width = width || 20; this.height = height || 20; // 蛇的每一部分, 第一部分是蛇头 this.body = [ &#123;x: 3, y: 2, color: 'red'&#125;, &#123;x: 2, y: 2, color: 'red'&#125;, &#123;x: 1, y: 2, color: 'red'&#125; ]; this.direction = direction || 'right';&#125; render方法 12345678910111213Snake.prototype.render = function(map) &#123; for(var i = 0; i &lt; this.body.length; i++) &#123; var obj = this.body[i]; var div = document.createElement('div'); map.appendChild(div); div.style.left = obj.x * this.width + 'px'; div.style.top = obj.y * this.height + 'px'; div.style.position = position; div.style.backgroundColor = obj.color; div.style.width = this.width + 'px'; div.style.height = this.height + 'px'; &#125;&#125; 在自调用函数中暴露Snake对象 1window.Snake = Snake; 创建游戏对象游戏对象，用来管理游戏中的所有对象和开始游戏 Game 属性 food snake map 方法 start 开始游戏（绘制所有游戏对象） 构造函数 12345function Game(map) &#123; this.food = new Food(); this.snake = new Snake(); this.map = map;&#125; 开始游戏，渲染食物对象和蛇对象 1234Game.prototype.start = function () &#123; this.food.render(this.map); this.snake.render(this.map);&#125; 游戏的逻辑写蛇的move方法 在蛇对象(snake.js)中，在Snake的原型上新增move方法 让蛇移动起来，把蛇身体的每一部分往前移动一下 蛇头部分根据不同的方向决定 往哪里移动 1234567891011121314151617181920212223Snake.prototype.move = function (food, map) &#123; // 让蛇身体的每一部分往前移动一下 var i = this.body.length - 1; for(; i &gt; 0; i--) &#123; this.body[i].x = this.body[i - 1].x; this.body[i].y = this.body[i - 1].y; &#125; // 根据移动的方向，决定蛇头如何处理 switch(this.direction) &#123; case 'left': this.body[0].x -= 1; break; case 'right': this.body[0].x += 1; break; case 'top': this.body[0].y -= 1; break; case 'bottom': this.body[0].y += 1; break; &#125;&#125; 在game中测试 12this.snake.move(this.food, this.map);this.snake.render(this.map); 让蛇自己动起来 私有方法 1234什么是私有方法？ 不能被外部访问的方法如何创建私有方法？ 使用自调用函数包裹 在game.js中 添加runSnake的私有方法，开启定时器调用蛇的move和render方法，让蛇动起来 判断蛇是否撞墙 1234567891011121314151617181920212223function runSnake() &#123; var timerId = setInterval(function() &#123; this.snake.move(this.food, this.map); // 在渲染前，删除之前的蛇 this.snake.render(this.map); // 判断蛇是否撞墙 var maxX = this.map.offsetWidth / this.snake.width; var maxY = this.map.offsetHeight / this.snake.height; var headX = this.snake.body[0].x; var headY = this.snake.body[0].y; if (headX &lt; 0 || headX &gt;= maxX) &#123; clearInterval(timerId); alert('Game Over'); &#125; if (headY &lt; 0 || headY &gt;= maxY) &#123; clearInterval(timerId); alert('Game Over'); &#125; &#125;.bind(that), 150);&#125; 在snake中添加删除蛇的私有方法，在render中调用 12345678910function remove() &#123; // 删除渲染的蛇 var i = elements.length - 1; for(; i &gt;= 0; i--) &#123; // 删除页面上渲染的蛇 elements[i].parentNode.removeChild(elements[i]); // 删除elements数组中的元素 elements.splice(i, 1); &#125;&#125; 在game中通过键盘控制蛇的移动方向 12345678910111213141516171819202122function bindKey() &#123; document.addEventListener('keydown', function(e) &#123; switch (e.keyCode) &#123; case 37: // left this.snake.direction = 'left'; break; case 38: // top this.snake.direction = 'top'; break; case 39: // right this.snake.direction = 'right'; break; case 40: // bottom this.snake.direction = 'bottom'; break; &#125; &#125;.bind(that), false);&#125; 在start方法中调用 1bindKey(); 判断蛇是否吃到食物123456789101112131415161718// 在Snake的move方法中// 在移动的过程中判断蛇是否吃到食物// 如果蛇头和食物的位置重合代表吃到食物// 食物的坐标是像素，蛇的坐标是几个宽度，进行转换var headX = this.body[0].x * this.width;var headY = this.body[0].y * this.height;if (headX === food.x &amp;&amp; headY === food.y) &#123; // 吃到食物，往蛇节的最后加一节 var last = this.body[this.body.length - 1]; this.body.push(&#123; x: last.x, y: last.y, color: last.color &#125;) // 把现在的食物对象删除，并重新随机渲染一个食物对象 food.render(map);&#125; 其它处理把html中的js代码放到index.js中避免html中出现js代码 自调用函数的参数1234(function (window, undefined) &#123; var document = window.document;&#125;(window, undefined)) 传入window对象 将来代码压缩的时候，可以吧 function (window) 压缩成 function (w) 传入undefined 在将来会看到别人写的代码中会把undefined作为函数的参数(当前案例没有使用)因为在有的老版本的浏览器中 undefined可以被重新赋值，防止undefined 被重新赋值 整理代码现在的代码结构清晰，谁出问题就找到对应的js文件即可。通过自调用函数，已经防止了变量命名污染的问题 但是，由于js文件数较多，需要在页面上引用，会产生文件依赖的问题(先引入那个js，再引入哪个js)将来通过工具把js文件合并并压缩。现在手工合并js文件演示 问题1 1234567891011121314// 如果存在多个自调用函数要用分号分割，否则语法错误// 下面代码会报错(function () &#123;&#125;())(function () &#123;&#125;())// 所以代码规范中会建议在自调用函数之前加上分号// 下面代码没有问题;(function () &#123;&#125;());(function () &#123;&#125;()) 问题2 123456789// 当自调用函数 前面有函数声明时，会把自调用函数作为参数// 所以建议自调用函数前，加上;var a = function () &#123; alert('11');&#125; (function () &#123; alert('22');&#125;()) 继承什么是继承 现实生活中的继承 程序中的继承 构造函数的属性继承：借用构造函数12345678910111213function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;function Student (name, age) &#123; // 借用构造函数继承属性成员 Person.call(this, name, age)&#125;var s1 = Student('张三', 18)console.log(s1.type, s1.name, s1.age) // =&gt; human 张三 18 构造函数的原型方法继承：拷贝继承（for-in）12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 原型对象拷贝继承原型对象成员for(var key in Person.prototype) &#123; Student.prototype[key] = Person.prototype[key]&#125;var s1 = Student('张三', 18)s1.sayName() // =&gt; hello 张三 另一种继承方式：原型继承12345678910111213141516171819202122function Person (name, age) &#123; this.type = 'human' this.name = name this.age = age&#125;Person.prototype.sayName = function () &#123; console.log('hello ' + this.name)&#125;function Student (name, age) &#123; Person.call(this, name, age)&#125;// 利用原型的特性实现继承Student.prototype = new Person()var s1 = Student('张三', 18)console.log(s1.type) // =&gt; humans1.sayName() // =&gt; hello 张三 函数进阶函数的定义方式 函数声明 函数表达式 new Function 函数声明123function foo () &#123;&#125; 函数表达式123var foo = function () &#123;&#125; 函数声明与函数表达式的区别 函数声明必须有名字 函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用 函数表达式类似于变量赋值 函数表达式可以没有名字，例如匿名函数 函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用 下面是一个根据条件定义函数的例子： 123456789if (true) &#123; function f () &#123; console.log(1) &#125;&#125; else &#123; function f () &#123; console.log(2) &#125;&#125; 以上代码执行结果在不同浏览器中结果不一致。 不过我们可以使用函数表达式解决上面的问题： 1234567891011var fif (true) &#123; f = function () &#123; console.log(1) &#125;&#125; else &#123; f = function () &#123; console.log(2) &#125;&#125; 函数的调用方式 普通函数 构造函数 对象方法 函数内 this 指向的不同场景函数的调用方式决定了 this 指向的不同： 调用方式 非严格模式 备注 普通函数调用 window 严格模式下是 undefined 构造函数调用 实例对象 原型方法中 this 也是实例对象 对象方法调用 该方法所属对象 紧挨着的对象 事件绑定方法 绑定事件对象 定时器函数 window 这就是对函数内部 this 指向的基本整理，写代码写多了自然而然就熟悉了。 函数也是对象 所有函数都是 Function 的实例 call、apply、bind那了解了函数 this 指向的不同场景之后，我们知道有些情况下我们为了使用某种特定环境的 this 引用，这时候时候我们就需要采用一些特殊手段来处理了，例如我们经常在定时器外部备份 this 引用，然后在定时器函数内部使用外部 this 的引用。然而实际上对于这种做法我们的 JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。这就是接下来我们要学习的 call、apply、bind 三个函数方法。 callcall() 方法调用一个函数, 其具有一个指定的 this 值和分别地提供的参数(参数的列表)。 注意：该方法的作用和 apply() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.call(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 在 fun 函数运行时指定的 this 值 如果指定了 null 或者 undefined 则内部 this 指向 window arg1, arg2, ... 指定的参数列表 applyapply() 方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的参数。 注意：该方法的作用和 call() 方法类似，只有一个区别，就是 call() 方法接受的是若干个参数的列表，而 apply() 方法接受的是一个包含多个参数的数组。 语法： 1fun.apply(thisArg, [argsArray]) 参数： thisArg argsArray apply() 与 call() 非常相似，不同之处在于提供参数的方式。apply() 使用参数数组而不是一组参数列表。例如： 1fun.apply(this, ['eat', 'bananas']) bindbind() 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函数体（在 ECMAScript 5 规范中内置的call属性）。当目标函数被调用时 this 值绑定到 bind() 的第一个参数，该参数不能被重写。绑定函数被调用时，bind() 也接受预设的参数提供给原函数。一个绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。提供的 this 值被忽略，同时调用时的参数被提供给模拟函数。 语法： 1fun.bind(thisArg[, arg1[, arg2[, ...]]]) 参数： thisArg 当绑定函数被调用时，该参数会作为原函数运行时的 this 指向。当使用new 操作符调用绑定函数时，该参数无效。 arg1, arg2, … 当绑定函数被调用时，这些参数将置于实参之前传递给被绑定的方法。 返回值： 返回由指定的this值和初始化参数改造的原函数拷贝。 示例1： 123456789101112131415this.x = 9; var module = &#123; x: 81, getX: function() &#123; return this.x; &#125;&#125;;module.getX(); // 返回 81var retrieveX = module.getX;retrieveX(); // 返回 9, 在这种情况下，"this"指向全局作用域// 创建一个新函数，将"this"绑定到module对象// 新手可能会被全局的x变量和module里的属性x所迷惑var boundGetX = retrieveX.bind(module);boundGetX(); // 返回 81 示例2： 12345678910111213141516function LateBloomer() &#123; this.petalCount = Math.ceil(Math.random() * 12) + 1;&#125;// Declare bloom after a delay of 1 secondLateBloomer.prototype.bloom = function() &#123; window.setTimeout(this.declare.bind(this), 1000);&#125;;LateBloomer.prototype.declare = function() &#123; console.log('I am a beautiful flower with ' + this.petalCount + ' petals!');&#125;;var flower = new LateBloomer();flower.bloom(); // 一秒钟后, 调用'declare'方法 小结 call 和 apply 特性一样 都是用来调用函数，而且是立即调用 但是可以在调用函数的同时，通过第一个参数指定函数内部 this 的指向 call 调用的时候，参数必须以参数列表的形式进行传递，也就是以逗号分隔的方式依次传递即可 apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递 如果第一个参数指定了 null 或者 undefined 则内部 this 指向 window bind 可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数 它和 call、apply 最大的区别是：bind 不会调用 bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递 在 bind 的同时，以参数列表的形式进行传递 在调用的时候，以参数列表的形式进行传递 那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准 两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部 函数的其它成员 arguments 实参集合 caller 函数的调用者 length 形参的个数 name 函数的名称 12345678910111213function fn(x, y, z) &#123; console.log(fn.length) // =&gt; 形参的个数 console.log(arguments) // 伪数组实参参数集合 console.log(arguments.callee === fn) // 函数本身 console.log(fn.caller) // 函数的调用者 console.log(fn.name) // =&gt; 函数的名字&#125;function f() &#123; fn(10, 20, 30)&#125;f() 高阶函数 函数可以作为参数 函数可以作为返回值 作为参数12345678910function eat (callback) &#123; setTimeout(function () &#123; console.log('吃完了') callback() &#125;, 1000)&#125;eat(function () &#123; console.log('去唱歌')&#125;) 作为返回值1234567891011function genFun (type) &#123; return function (obj) &#123; return Object.prototype.toString.call(obj) === type &#125;&#125;var isArray = genFun('[object Array]')var isObject = genFun('[object Object]')console.log(isArray([])) // =&gt; trueconsole.log(isArray(&#123;&#125;)) // =&gt; true 函数闭包1234567891011121314151617function fn () &#123; var count = 0 return &#123; getCount: function () &#123; console.log(count) &#125;, setCount: function () &#123; count++ &#125; &#125;&#125;var fns = fn()fns.getCount() // =&gt; 0fns.setCount()fns.getCount() // =&gt; 1 作用域、作用域链、预解析 全局作用域 函数作用域 没有块级作用域 12345678910&#123; var foo = 'bar'&#125;console.log(foo)if (true) &#123; var a = 123&#125;console.log(a) 作用域链示例代码： 123456789101112131415161718var a = 10function fn () &#123; var b = 20 function fn1 () &#123; var c = 30 console.log(a + b + c) &#125; function fn2 () &#123; var d = 40 console.log(c + d) &#125; fn1() fn2()&#125; 内层作用域可以访问外层作用域，反之不行 什么是闭包闭包就是能够读取其他函数内部变量的函数，由于在 Javascript 语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成 “定义在一个函数内部的函数”。所以，在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。 闭包的用途： 可以在函数外部读取函数内部成员 让函数内成员始终存活在内存中 一些关于闭包的例子示例1： 123456var arr = [10, 20, 30]for(var i = 0; i &lt; arr.length; i++) &#123; arr[i] = function () &#123; console.log(i) &#125;&#125; 示例2： 12345678console.log(111)for(var i = 0; i &lt; 3; i++) &#123; setTimeout(function () &#123; console.log(i) &#125;, 0)&#125;console.log(222) 示例3：投票 示例4：判断类型 示例5：沙箱模式 闭包的思考题思考题 1： 1234567891011var name = "The Window";var object = &#123; name: "My Object", getNameFunc: function () &#123; return function () &#123; return this.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 思考题 2： 1234567891011var name = "The Window"; var object = &#123; name: "My Object", getNameFunc: function () &#123; var that = this; return function () &#123; return that.name; &#125;; &#125;&#125;;console.log(object.getNameFunc()()) 小结函数递归递归执行模型123456789101112131415161718192021222324function fn1 () &#123; console.log(111) fn2() console.log('fn1')&#125;function fn2 () &#123; console.log(222) fn3() console.log('fn2')&#125;function fn3 () &#123; console.log(333) fn4() console.log('fn3')&#125;function fn4 () &#123; console.log(444) console.log('fn4')&#125;fn1() 举个栗子：计算阶乘的递归函数1234567function factorial (num) &#123; if (num &lt;= 1) &#123; return 1 &#125; else &#123; return num * factorial(num - 1) &#125;&#125; 递归应用场景 深拷贝 菜单树 遍历 DOM 树 正则表达式 了解正则表达式基本语法 能够使用JavaScript的正则对象 正则表达式简介什么是正则表达式正则表达式：用于匹配规律规则的表达式，正则表达式最初是科学家对人类神经系统的工作原理的早期研究，现在在编程语言中有广泛的应用。正则表通常被用来检索、替换那些符合某个模式(规则)的文本。正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。 正则表达式的作用 给定的字符串是否符合正则表达式的过滤逻辑(匹配) 可以通过正则表达式，从字符串中获取我们想要的特定部分(提取) 强大的字符串替换能力(替换) 正则表达式的特点 灵活性、逻辑性和功能性非常的强 可以迅速地用极简单的方式达到字符串的复杂控制 对于刚接触的人来说，比较晦涩难懂 正则表达式的测试 在线测试正则 工具中使用正则表达式 sublime/vscode/word 演示替换所有的数字 正则表达式的组成 普通字符 特殊字符(元字符)：正则表达式中有特殊意义的字符 示例演示： \d 匹配数字 ab\d 匹配 ab1、ab2 元字符串通过测试工具演示下面元字符的使用 常用元字符串 元字符 说明 \d 匹配数字 \D 匹配任意非数字的字符 \w 匹配字母或数字或下划线 \W 匹配任意不是字母，数字，下划线 \s 匹配任意的空白符 \S 匹配任意不是空白符的字符 . 匹配除换行符以外的任意单个字符 ^ 表示匹配行首的文本(以谁开始) $ 表示匹配行尾的文本(以谁结束) 限定符 限定符 说明 * 重复零次或更多次 + 重复一次或更多次 ? 重复零次或一次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 其它1234567[] 字符串用中括号括起来，表示匹配其中的任一字符，相当于或的意思[^] 匹配除中括号以内的内容\ 转义符| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱() 从两个直接量中选择一个，分组 eg：gr(a|e)y匹配gray和grey[\u4e00-\u9fa5] 匹配汉字 案例验证手机号： 1^\d&#123;11&#125;$ 验证邮编： 1^\d&#123;6&#125;$ 验证日期 2012-5-01 1^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$ 验证邮箱 xxx@itcast.cn： 1^\w+@\w+\.\w+$ 验证IP地址 192.168.1.10 1^\d&#123;1,3&#125;\(.\d&#123;1,3&#125;)&#123;3&#125;$ JavaScript 中使用正则表达式创建正则对象方式1： 12var reg = new Regex('\d', 'i');var reg = new Regex('\d', 'gi'); 方式2： 12var reg = /\d/i;var reg = /\d/gi; 参数 标志 说明 i 忽略大小写 g 全局匹配 gi 全局匹配+忽略大小写 正则匹配1234// 匹配日期var dateStr = '2015-10-10';var reg = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/console.log(reg.test(dateStr)); ###匹配正则表达式// console.log(/./.test(“除了回车换行以为的任意字符”));//true// console.log(/.*/.test(“0个到多个”));//true// console.log(/.+/.test(“1个到多个”));//true// console.log(/.?/.test(“哈哈”));//true// console.log(/[0-9]/.test(“9527”));//true// console.log(/[a-z]/.test(“what”));//true// console.log(/[A-Z]/.test(“Are”));//true// console.log(/[a-zA-Z]/.test(“干啥子”));//false// console.log(/[0-9a-zA-Z]/.test(“9ebg”));//true// console.log(/b|(ara)/.test(“abra”));//true// console.log(/[a-z]{2,3}/.test(“arfsf”));//true console.log(/\d/.test(&quot;998&quot;));//true console.log(/\d*/.test(&quot;998&quot;));//true console.log(/\d+/.test(&quot;998&quot;));//true console.log(/\d{0,}/.test(&quot;998&quot;));//true console.log(/\d{2,3}/.test(&quot;998&quot;));//true console.log(/\D/.test(&quot;eat&quot;));//true console.log(/\s/.test(&quot; &quot;));//true console.log(/\S/.test(&quot;嘎嘎&quot;));//true console.log(/\w/.test(&quot;_&quot;));//true console.log(/\W/.test(&quot;_&quot;));//true ###正则表达式案例1.验证密码强弱2.验证邮箱：[0-9a-zA-Z_.-]+[@][0-9a-zA-Z._-]+([.][a-zA-Z]+){1,2}3.验证中文名字[\u4e00-\u9fa5] 正则提取123456789101112131415161718192021222324252627// 1. 提取工资var str = "张三：1000，李四：5000，王五：8000。";var array = str.match(/\d+/g);console.log(array);// 2. 提取email地址var str = "123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com...";var array = str.match(/\w+@\w+\.\w+(\.\w+)?/g);console.log(array);// 3. 分组提取 // 3. 提取日期中的年部分 2015-5-10var dateStr = '2016-1-5';// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取var reg = /(\d&#123;4&#125;)-\d&#123;1,2&#125;-\d&#123;1,2&#125;/;if (reg.test(dateStr)) &#123; console.log(RegExp.$1);&#125;// 4. 提取邮件中的每一部分var reg = /(\w+)@(\w+)\.(\w+)(\.\w+)?/;var str = "123123@xx.com";if (reg.test(str)) &#123; console.log(RegExp.$1); console.log(RegExp.$2); console.log(RegExp.$3);&#125; 正则替换123456789// 1. 替换所有空白var str = " 123AD asadf asadfasf adf ";str = str.replace(/\s/g,"xx");console.log(str);// 2. 替换所有,|，var str = "abc,efg,123，abc,123，a";str = str.replace(/,|，/g, ".");console.log(str); 案例：表单验证12345QQ号：&lt;input type="text" id="txtQQ"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;邮箱：&lt;input type="text" id="txtEMail"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;手机：&lt;input type="text" id="txtPhone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;生日：&lt;input type="text" id="txtBirthday"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;姓名：&lt;input type="text" id="txtName"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 12345678910111213141516171819202122232425262728293031323334353637383940//获取文本框var txtQQ = document.getElementById("txtQQ");var txtEMail = document.getElementById("txtEMail");var txtPhone = document.getElementById("txtPhone");var txtBirthday = document.getElementById("txtBirthday");var txtName = document.getElementById("txtName");//txtQQ.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\d&#123;5,12&#125;$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的QQ号"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;;//txtEMailtxtEMail.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; var reg = /^\w+@\w+\.\w+(\.\w+)?$/; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = "请输入正确的EMail地址"; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125;&#125;; 表单验证部分，封装成函数： 12345678910111213141516171819var regBirthday = /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/;addCheck(txtBirthday, regBirthday, "请输入正确的出生日期");//给文本框添加验证function addCheck(element, reg, tip) &#123; element.onblur = function () &#123; //获取当前文本框对应的span var span = this.nextElementSibling; //判断验证是否成功 if(!reg.test(this.value) )&#123; //验证不成功 span.innerText = tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125;;&#125; 通过给元素增加自定义验证属性对表单进行验证： 1234567&lt;form id="frm"&gt; QQ号：&lt;input type="text" name="txtQQ" data-rule="qq"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 邮箱：&lt;input type="text" name="txtEMail" data-rule="email"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 手机：&lt;input type="text" name="txtPhone" data-rule="phone"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 生日：&lt;input type="text" name="txtBirthday" data-rule="date"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt; 姓名：&lt;input type="text" name="txtName" data-rule="cn"&gt;&lt;span&gt;&lt;/span&gt;&lt;br&gt;&lt;/form&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// 所有的验证规则var rules = [ &#123; name: 'qq', reg: /^\d&#123;5,12&#125;$/, tip: "请输入正确的QQ" &#125;, &#123; name: 'email', reg: /^\w+@\w+\.\w+(\.\w+)?$/, tip: "请输入正确的邮箱地址" &#125;, &#123; name: 'phone', reg: /^\d&#123;11&#125;$/, tip: "请输入正确的手机号码" &#125;, &#123; name: 'date', reg: /^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;$/, tip: "请输入正确的出生日期" &#125;, &#123; name: 'cn', reg: /^[\u4e00-\u9fa5]&#123;2,4&#125;$/, tip: "请输入正确的姓名" &#125;];addCheck('frm');//给文本框添加验证function addCheck(formId) &#123; var i = 0, len = 0, frm =document.getElementById(formId); len = frm.children.length; for (; i &lt; len; i++) &#123; var element = frm.children[i]; // 表单元素中有name属性的元素添加验证 if (element.name) &#123; element.onblur = function () &#123; // 使用dataset获取data-自定义属性的值 var ruleName = this.dataset.rule; var rule =getRuleByRuleName(rules, ruleName); var span = this.nextElementSibling; //判断验证是否成功 if(!rule.reg.test(this.value) )&#123; //验证不成功 span.innerText = rule.tip; span.style.color = "red"; &#125;else&#123; //验证成功 span.innerText = ""; span.style.color = ""; &#125; &#125; &#125; &#125;&#125;// 根据规则的名称获取规则对象function getRuleByRuleName(rules, ruleName) &#123; var i = 0, len = rules.length; var rule = null; for (; i &lt; len; i++) &#123; if (rules[i].name == ruleName) &#123; rule = rules[i]; break; &#125; &#125; return rule;&#125; 补充伪数组和数组在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。 对象与数组的关系在说区别之前，需要先提到另外一个知识，就是 JavaScript 的原型继承。所有 JavaScript 的内置构造函数都是继承自 Object.prototype 。在这个前提下，可以理解为使用 new Array() 或 [] 创建出来的数组对象，都会拥有 Object.prototype 的属性值。 1234var obj = &#123;&#125;;// 拥有 Object.prototype 的属性值var arr = [];//使用数组直接量创建的数组，由于 Array.prototype 的属性继承自 Object.prototype，//那么，它将同时拥有 Array.prototype 和 Object.prototype 的属性值 可以得到对象和数组的第一个区别：对象没有数组 Array.prototype 的属性值。 什么是数组数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码： 12345678910var obj = &#123;&#125;;var arr = []; obj[2] = 'a';arr[2] = 'a'; console.log(obj[2]); // =&gt; aconsole.log(arr[2]); // =&gt; aconsole.log(obj.length); // =&gt; undefinedconsole.log(arr.length); // =&gt; 3 obj[2]输出’a’，是因为对象就是普通的键值对存取数据 而arr[2]输出’a’ 则不同，数组是通过索引来存取数据，arr[2]之所以输出’a’，是因为数组arr索引2的位置已经存储了数据 obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined 而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值 为什么arr.length输出3，而不是1 在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数 什么是伪数组 拥有 length 属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解) 不具有数组所具有的方法 伪数组，就是像数组一样有 length 属性，也有 0、1、2、3 等属性的对象，看起来就像数组一样，但不是数组，比如: 123456789101112var fakeArray = &#123; "0": "first", "1": "second", "2": "third", length: 3&#125;; for (var i = 0; i &lt; fakeArray.length; i++) &#123; console.log(fakeArray[i]);&#125; Array.prototype.join.call(fakeArray,'+'); 常见的伪数组有： 函数内部的 arguments DOM 对象列表（比如通过 document.getElementsByTags 得到的列表） jQuery 对象（比如 $(&quot;div&quot;) ） 伪数组是一个 Object，而真实的数组是一个 Array。 伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多方法，比如： 123456789101112var arr = Array.prototype.slice.call(arguments); Array.prototype.forEach.call(arguments, function(v) &#123; // 循环arguments对象&#125;);// push// some// every// filter// map// ... 以上在借用数组的原型方法的时候都可以通过数组直接量来简化使用： 1234567891011121314var obj = &#123; 0: 'a', 1: 'b', 2: 'c', length: 3&#125;;[].push.call(obj, 'd')console.log([].slice.call(obj));[].forEach.call(obj, function (num, index) &#123; console.log(num)&#125;) 小结 对象没有数组 Array.prototype 的属性值，类型是 Object ，而数组类型是 Array 数组是基于索引的实现， length 会自动更新，而对象是键值对 使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法 JavaScript 垃圾回收机制JavaScript 运行机制：Event LoopObject静态成员 Object.assign() Object.create() Object.keys() Object.defineProperty() 实例成员 constructor hasOwnProperty() isPrototypeOf propertyIsEnumerable() toString() valueOf() 附录A 代码规范代码风格 JavaScript Standard Style Airbnb JavaScript Style Guide() { 校验工具 JSLint JSHint ESLint B Chrome 开发者工具C 文档相关工具 电子文档制作工具: docute 流程图工具：DiagramDesigner]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>js笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JD案例]]></title>
    <url>%2F2017%2F08%2F07%2Fjd%2F</url>
    <content type="text"><![CDATA[学习目标: 掌握京东项目流程体系 掌握网站三大标签优化 掌握京东头部和尾部制作 掌握京导航栏制作 掌握京东焦点图制作 了解网站三大标签优化 理解BFC 了解渐进增强和优雅降级 typora-copy-images-to: media 京东项目(一)京东项目介绍项目名称：京东网项目描述：京东首页公共部分的头部和尾部制作，京东首页中间部分。 项目背景现阶段电商类网站很流行，很多同学毕业之后会进入电商类企业工作，同时电商类网站需要的技术也是较为复杂的，这里用京东电商网站复习、总结、提高前面所学布局技术。其实，最主要的原因还是，为啥写京东？ 因为刘强东，赚了我们的钱，抢了我们的女神， 我们也要学刘强东，赚别人的钱，抢别人..额，自己的女神。。。 设计目标 保证浏览器 ie7及以上, 火狐, 360, safari，chrome等。谁让我再测ie6，就跟谁急。。 熟悉CSS+DIV布局，页面的搭建工作 了解常用电商类网站的布局模式 为后期京东移动端做铺垫 几点思考(1). 开发工具 sublime 、fireworks（ps）、各种浏览器(ie6.7 要测看心情) (2). CSS Rest 类库,为跨浏览器兼容做准备(也可以直接运用jd网站的初始化) 1234567891011normalize.css 只是一个很小的CSS文件，但它在默认的HTML元素样式上提供了跨浏览器的高度一致性。相比于传统的CSS reset，Normalize.css是一种现代的、为HTML5准备的优质替代方案。Normalize.css现在已经被用于Twitter Bootstrap、HTML5 Boilerplate、GOV.UK、Rdio、CSS Tricks 以及许许多多其他框架、工具和网站上。 你值得拥有。。 - 保护有用的浏览器默认样式而不是完全去掉它们- 一般化的样式：为大部分HTML元素提供- 修复浏览器自身的bug并保证各浏览器的一致性- 优化CSS可用性：用一些小技巧- 解释代码：用注释和详细的文档来 (3). 技术栈 1HTML5 结构 + CSS3 布局 (因为我们就会这些。。。嘻嘻) (4). 低版本浏览器 单独制作一个跳转页面 (都是孩子，也舍不得打，舍不得扔) https://h5.m.jd.com/dev/3dm8aE4LDBNMkDfcCaRxLnVQ7rqo/index.html 目录说明要实现结构和样式相分离的设计思想。 根目录下有这4个文件（目录）。 名称 说明 css 用于存放CSS文件 images 用于存放图片 index 京东首页 HTML js 用于后期存放javascript文件 运用知识点引入ico图标 代码： &lt;link rel=&quot;shortcut icon&quot; href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot;/&gt; 注意： 她(它)不是iconfont字体哦。 位置是放到 head 标签中间。 后面的type=”image/x-icon” 属性可以省略。（我相信你也愿意省略。） 为了兼容性，请将favicon.ico 这个图标放到根目录下。（我们就不要任性了，听话放位置，省很多麻烦。。你好，我也好） 转换ico图标我们可以自己做的图片，转换为 ico图标，以便放到我们站点里面。 http://www.bitbug.net/ 网站优化三大标签SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”！SEO是指通过对网站进行站内优化、网站结构调整、网站内容建设、网站代码优化等)和站外优化，从而提高网站的关键词排名以及公司产品的曝光度。 简单的说就是，把产品做好，搜索引擎就会介绍客户来。 我们现在阶段主要进行站内优化。网站优化，我们应该要懂。。。 网页title 标题title具有不可替代性，是我们的内页第一个重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。 建议： 首页标题：网站名（产品名）- 网站的介绍 例如： 京东(JD.COM)-综合网购首选-正品低价、品质保障、配送及时、轻松购物！ 小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站 Description 网站说明对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的。我们提倡，Description作为网站的总体业务和主题概括，多采用“我们是…”“我们提供…”“×××网作为…”“电话：010…”之类语句。 京东网： &lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot; /&gt; 注意点： 描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击。 同样遵循简短原则，字符数含空格在内不要超过 120 个汉字。 补充在 title 和 keywords 中未能充分表述的说明. 用英文逗号 关键词1,关键词2 1&lt;meta name=&quot;description&quot; content=&quot;小米商城直营小米公司旗下所有产品，囊括小米手机系列小米MIX、小米Note 2，红米手机系列红米Note 4、红米4，智能硬件，配件及小米生活周边，同时提供小米客户服务及售后支持。&quot; /&gt; Keywords 关键字Keywords是页面关键词，是搜索引擎关注点之一。Keywords应该限制在6～8个关键词左右，电商类网站可以多 少许。 京东网： &lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot; /&gt; 小米网： &lt;meta name=&quot;keywords&quot; content=&quot;小米,小米6,红米Note4,小米MIX,小米商城&quot; /&gt; 顶部（快捷菜单）所用知识点 知识点 说明 通栏的盒子 不用给宽度 默认为 100% &nbsp;但是加了浮动和定位的盒子需要 添加 100% 盒子居中对齐 margin: auto; 注意必须有宽度的块级元素，文字水平居中对齐是 text-align:center; 行高会继承 文字性质的，比如 颜色、文字大小、字体、行高等会继承父级元素 浮动元素、固定定位，绝对定位会模式转换 具有行内块特性，比如一行放多个，有高度和宽度，如果没有指定宽度，则会根据内容多少撑开。 logo 和搜索 header 区域所用知识点网页布局稳定性 宽度剩余法： 知识点 说明 浮动元素特性 1. 浮动可以让多个元素同一行显示 2. 浮动的元素是顶部对齐 logo优化 text-indent: -20000px; 隐藏文字， 背景图片 清除浮动 清除浮动的目的就是为了解决父亲高度为0的问题 鼠标样式 cursor: pointer; 小手 cursor: move; 四角箭头 cursor: text; 插入光标 cursor: default; 小白 不允许换行 white-space: nowrap; nav导航栏所用知识点 名称 说明 边框底侧 border-bottom: 2px solid #ccc; 定位重点 绝对定位不占位置 相对定位占有位置 标签语义化dl dl也是块级元素 dt 是 定义标题 dd 是定义描述，dd是围绕这dt来描述的，也就是说，dd算是dt 的解释说明详细分解。 标题标签h 尽量少用h1，可以多用h2和h3等标签 页面底部所用知识点 名称 说明 绝对定位的盒子居中对齐 盒子 left 50% 然后通过 margin 负值自己的宽度一半（固定定位也是如此） 固定定位的盒子靠近版心右侧对齐跟绝对定位的盒子居中对齐原理差不多。 left 50% 然后 margin-left 版心宽度一半。 学习目标: 掌握京东中间部分制作 理解BFC使用 了解优雅降级和渐进增强 了解CSS压缩和验证工具 typora-copy-images-to: /media 京东项目(二)nav导航栏所用知识点 名称 说明 边框底侧 border-bottom: 2px solid #ccc; 定位重点 绝对定位不占位置 相对定位占有位置 标签语义化dl dl也是块级元素 dt 是 定义标题 dd 是定义描述，dd是围绕这dt来描述的，也就是说，dd算是dt 的解释说明详细分解。 标题标签h 尽量少用h1，可以多用h2和h3等标签 固定定位的盒子靠近版心右侧对齐跟绝对定位的盒子居中对齐原理差不多。 left 50% 然后 margin-left 版心宽度一半。 焦点图部分所用知识点 名称 说明 圆角矩形 border-radius: 左上角 右上角 右下角 左下角。 负值自己的宽度一半（固定定位也是如此） 背景半透明1.强烈推荐： background: rgba(r,g,b,alpha); ​ r,g,b 是红绿蓝的颜色， alpha 是透明度的意思，取值范围是 0~1 之间。 2.了解ie低版本浏览器 半透明 filter:Alpha(opacity=50) ； // opacity值为0 到 100 但是 此属性是盒子半透明，不是背景半透明哦，因为里面的内容也一起半透明了 因此，低版本的 ie6.7浏览器，我们不需要透明了，直接采用优雅降级的做法。 background: gary; background: rgba(0,0,0,.2); 写上两句 背景， 低版本ie只执行gray， 其他浏览器执行 半透明下面这一句。 BFC(块级格式化上下文)BFC(Block formatting context) 直译为”块级格式化上下文”。 元素的显示模式我们前面讲过 元素的显示模式 display。 分为 块级元素 行内元素 行内块元素 ，其实，它还有很多其他显示模式。 那些元素会具有BFC的条件不是所有的元素模式都能产生BFC，w3c 规范： display 属性为 block, list-item, table 的元素，会产生BFC. 大家有么有发现这个三个都是用来布局最为合理的元素，因为他们就是用来可视化布局。 注意其他的，display属性，比如 line 等等，他们创建的是 IFC ，我们暂且不研究。 这个BFC 有着具体的布局特性： 有宽度和高度 ， 有 外边距margin 有内边距padding 有边框 border。 就好比，你有了练习武术的体格了。 有潜力，有资质。 什么情况下可以让元素产生BFC以上盒子具有BFC条件了，就是说有资质了，但是怎样触发才会产生BFC，从而创造这个封闭的环境呢？ 在好比，你光有资质还不行，你需要一定额外效果才能出发的武学潜力，要么你掉到悬崖下面，捡到了一本九阴真经，要么你学习葵花宝典，欲练此功必先…. 同样，要给这些元素添加如下属性就可以触发BFC。 -float属性不为none -position为absolute或fixed -display为inline-block, table-cell, table-caption, flex, inline-flex -overflow不为visible。 BFC元素所具有的特性BFC布局规则特性： 1.在BFC中，盒子从顶端开始垂直地一个接一个地排列. 2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠 3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。 计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。 它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 白话文： 孩子在家里愿意怎么折腾都行，但是出了家门口，你就的乖乖的，不能影响外面的任何人。 BFC的主要用途BFC能用来做什么？ (1) 清除元素内部浮动 只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。 主要用到 1计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。 (2) 解决外边距合并问题 外边距合并的问题。 主要用到 1盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠 属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。 (3) 制作右侧自适应的盒子问题 主要用到 1普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文 BFC 总结BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。包括浮动，和外边距合并等等，因此，有了这个特性，我们布局的时候就不会出现意外情况了。 优雅降级和渐进增强什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？ 渐进增强 progressive enhancement： 针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 类似 爬山，由低出往高处爬 优雅降级 graceful degradation： 一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 类似蹦极，由高处往低处下落 区别：渐进增强是向上兼容，优雅降级是向下兼容。 个人建议： 现在互联网发展很快， 连微软公司都抛弃了ie浏览器，转而支持 edge这样的高版本浏览器，我们很多情况下没有必要再时刻想着低版本浏览器了，而是一开始就构建完整的效果，根据实际情况，修补低版本浏览器问题。 浏览器前缀 浏览器前缀 浏览器 -webkit- Google Chrome, Safari, Android Browser -moz- Firefox -o- Opera -ms- Internet Explorer, Edge -khtml- Konqueror 后面我们会有 常用的解决H5和C3 的兼容解决文件， 我们这里暂且不涉及。 背景渐变在线性渐变过程中，颜色沿着一条直线过渡：从左侧到右侧、从右侧到左侧、从顶部到底部、从底部到顶部或着沿任何任意轴。如果你曾使用过制作图件，比如说Photoshop，你对线性渐变并不会陌生。 兼容性问题很严重，我们这里之讲解线性渐变 语法格式： 1background:-webkit-linear-gradient(渐变的起始位置， 起始颜色， 结束颜色)； 1background:-webkit-linear-gradient(渐变的起始位置， 颜色 位置， 颜色位置....)； CSS W3C 统一验证工具CssStats 是一个在线的 CSS 代码分析工具 1网址是： http://www.cssstats.com/ 如果你想要更全面的，这个神奇，你值得拥有： W3C 统一验证工具： http://validator.w3.org/unicorn/ ☆☆☆☆☆ 因为它可以检测本地文件哦！！ CSS 压缩通过上面的检测没有错误，为了提高加载速度和节约空间（相对来说，css量很少的情况下，几乎没啥区别），可以通过css压缩工具把css进行压缩。 w3c css压缩 http://tool.chinaz.com/Tools/CssFormat.aspx 网速比较慢 还可以去站长之家进行快速压缩。 http://tool.chinaz.com/Tools/CssFormat.aspx 旋转轮播图 这个效果我们需要用到 透视 过渡还有 子元素 preserve-3d transform-styletransform-style属性是3D空间一个重要属性，指定嵌套元素如何在3D空间中呈现。他主要有两个属性值：flat和preserve-3d。 其中flat值为默认值，表示所有子元素在2D平面呈现。preserve-3d表示所有子元素在3D空间中呈现。 12345678910111213141516171819202122232425262728293031323334353637383940414243body &#123; perspective: 1000px; &#125;truesection &#123;truetruewidth: 300px;truetrueheight: 200px;truetruemargin: 100px auto;truetruebackground: url(images/img-1.jpg) no-repeat;truetruebackground-size: cover;truetrueposition: relative;truetruetransform-style: preserve-3d; /* 让父盒子里面的子盒子以3d效果显示 */truetruetransition: 5s linear; /* 匀速 all 是可以省略的， 省略默认的all*/true&#125;truesection:hover &#123;truetruetransform: rotateY(360deg);true&#125;truesection div &#123;truetruewidth: 100%;truetrueheight: 100%;truetruebackground: url(images/dog.gif) no-repeat;truetruebackground-size: cover;truetrueposition: absolute;truetruetop: 0;truetrueleft: 0;true&#125;truesection div:nth-child(1) &#123;truetruetransform: rotateY(0deg) translateZ(400px);true&#125;truesection div:nth-child(2) &#123;truetruetransform: rotateY(60deg) translateZ(400px);true&#125;truesection div:nth-child(3) &#123;truetruetransform: rotateY(120deg) translateZ(400px);true&#125;truesection div:nth-child(4) &#123;truetruetransform: rotateY(180deg) translateZ(400px);true&#125;truesection div:nth-child(5) &#123;truetruetransform: rotateY(240deg) translateZ(400px);true&#125;truesection div:nth-child(6) &#123;truetruetransform: rotateY(300deg) translateZ(400px);true&#125;]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css笔记/案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css1]]></title>
    <url>%2F2017%2F08%2F07%2FCSS(1)%2F</url>
    <content type="text"><![CDATA[课程目标: 学会使用CSS选择器 熟记CSS样式和外观属性 熟练掌握CSS各种选择器 熟练掌握CSS各种选择器 熟练掌握CSS三种显示模式 熟练掌握CSS背景属性 熟练掌握CSS三大特性 熟练掌握CSS盒子模型 熟练掌握CSS浮动10.熟练掌握CSS定位11.熟练掌握CSS高级技巧强化CSS typora-copy-images-to: mediaCSS的发展历程从HTML被发明开始，样式就以各种形式存在。不同的浏览器结合它们各自的样式语言为用户提供页面效果的控制。最初的HTML只包含很少的显示属性。随着HTML的成长，为了满足页面设计者的要求，HTML添加了很多显示功能。但是随着这些功能的增加，HTML变的越来越杂乱，而且HTML页面也越来越臃肿。于是CSS便诞生了。 CSS 网页的美容师CSS的出现，拯救了混乱的HTML，当让更加拯救了我们web开发者。 让我们的网页更加丰富多彩。 CSS的最大贡献就是： 让 HTML 从样式中解脱苦海， 实现了 HTML 专注去做 结构呈现。 而样式交给 CSS 后，你完全可以放心的早点洗洗睡了！ 而且。。。。。 CSS 做的很出色，如果JavaScript是网页的魔法师，那么CSS它是我们网页的美容师，不信，你看: ps: 你跟Angelababy只差了一个妆容的距离 来个更直观的认识吧： 有人说， 没有不漂亮的女人，只有不会打扮的女人。 我想说， 没有不好看的网页，只有不会CSS的前端。 网页添加 CSS和不添加CSS 的对比： 带有CSS的页面 没有CSS的页面 CSS初识CSS(Cascading Style Sheets) CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 CSS样式规则使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，具体格式如下： 12345678在上面的样式规则中:1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。2.属性和属性值以“键值对”的形式出现。3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。4.属性和属性值之间用英文“:”连接。5.多个“键值对”之间用英文“;”进行区分。可以用段落 和 表格的对齐的演示。 CSS字体样式属性font-size:字号大小font-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。具体如下： font-family:字体font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑，可以使用如下CSS样式代码： p{ font-family:”微软雅黑”;} 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。 常用技巧： 1234561. 现在网页中普遍使用14px+。2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。3. 各种字体之间必须使用英文状态下的逗号隔开。4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 CSS Unicode字体在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。 方案一： 你可以使用英文来替代。 比如 font-family:”Microsoft Yahei”。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。font-family: “\5FAE\8F6F\96C5\9ED1”，表示设置字体为“微软雅黑”。 可以通过escape() 来测试属于什么字体。 字体名称 英文名称 Unicode 编码 宋体 SimSun \5B8B\4F53 新宋体 NSimSun \65B0\5B8B\4F53 黑体 SimHei \9ED1\4F53 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 楷体_GB2312 KaiTi_GB2312 \6977\4F53_GB2312 隶书 LiSu \96B6\4E66 幼园 YouYuan \5E7C\5706 华文细黑 STXihei \534E\6587\7EC6\9ED1 细明体 MingLiU \7EC6\660E\4F53 新细明体 PMingLiU \65B0\7EC6\660E\4F53 为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体 font-weight:字体粗细字体加粗除了用 b 和 strong 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 1font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。 小技巧： 1数字 400 等价于 normal，而 700 等价于 bold。 但是我们更喜欢用数字来表示。 font-style:字体风格字体倾斜除了用 i 和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： normal：默认值，浏览器会显示标准的字体样式。 italic：浏览器会显示斜体的字体样式。 oblique：浏览器会显示倾斜的字体样式。 小技巧： 1平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。 font:综合设置字体样式 (重点)font属性用于对字体样式进行综合设置，其基本语法格式如下： 1选择器&#123;font: font-style font-weight font-size/line-height font-family;&#125; 123使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 开发者工具（chrome）此工具是我们的必备工具，以后代码出了问题，我们首先第一反应就是： “按F12”或者是 “shift+ctrl+i” 打开 开发者工具。 菜单： 右击网页空白出—查看 小技巧： ctrl+滚轮 可以 放大开发者工具代码大小。 左边是HTML元素结构 右边是CSS样式。 右边CSS样式可以改动数值和颜色查看更改后效果。 选择器（重点）要想将CSS样式应用于特定的HTML元素，首先需要找到该目标元素。在CSS中，执行这一任务的样式规则部分被称为选择器（选择符）。 如上图所以，要把里面的小黄人分为2组，最快的方法怎办？ 很多， 比如 一只眼睛的一组，剩下的一组 这就用到基础选择器组： 标签选择器（元素选择器）标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下： 12标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 或者元素名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。 课堂案例： 传智简介 类选择器类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下： 1.类名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 1标签调用的时候用 class=“类名” 即可。 类选择器最大的优势是可以为元素对象定义单独或相同的样式。 小技巧： 121.长名称或词组可以使用中横线来为选择器命名。2.不建议使用“_”下划线来命名CSS选择器。 ​ 输入的时候少按一个shift键; 浏览器兼容问题 (比如使用tips的选择器命名，在IE6是无效的) 能良好区分JavaScript变量命名(JS变量命名是用“”) 13.不要纯数字、中文等命名， 尽量使用英文字母来表示。 猜谜底游戏： 你猜？ 命名规范： 见附件（Web前端开发规范手册.doc） 命名是我们通俗约定的，但是没有规定必须用这些常用的命名。 课堂案例： 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; span &#123; font-size: 100px; &#125; .blue &#123; color: blue; &#125; .red &#123; color: red; &#125; .orange &#123; color: orange; &#125; .green &#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class="blue"&gt;G&lt;/span&gt; &lt;span class="red"&gt;o&lt;/span&gt; &lt;span class="orange"&gt;o&lt;/span&gt; &lt;span class="blue"&gt;g&lt;/span&gt; &lt;span class="green"&gt;l&lt;/span&gt; &lt;span class="red"&gt;e&lt;/span&gt; &lt;/body&gt; 多类名选择器我们可以给标签指定多个类名，从而达到更多的选择目的。 注意： 121. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。2. 各个类名中间用空格隔开。 多类名选择器在后期布局比较复杂的情况下，还是较多使用的。 1234&lt;div class="pink fontWeight font20"&gt;亚瑟&lt;/div&gt;&lt;div class="font20"&gt;刘备&lt;/div&gt;&lt;div class="font14 pink"&gt;安其拉&lt;/div&gt;&lt;div class="font14"&gt;貂蝉&lt;/div&gt; id选择器id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下： 1#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。 用法基本和类选择器相同。 id选择器和类选择器区别W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。 类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜 id选择器 好比人的身份证号码， 全中国是唯一的， 不得重复。 只能使用一次。 id选择器和类选择器最大的不同在于 使用次数上。 通配符选择器通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下： 1* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 1234* &#123; margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/&#125; 注意： 这个通配符选择器，就像我们的电影明星中的梦中情人， 想想它就好了，但是它不会和你过日子。 伪类选择器 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。 1为了和我们刚才学的类选择器相区别， 类选择器是一个点 比如 .demo &#123;&#125; 而我们的伪类 用 2个点 就是 冒号 比如 :link&#123;&#125; 链接伪类选择器 :link / 未访问的链接 / :visited / 已访问的链接 / :hover / 鼠标移动到链接上 / :active / 选定的链接 / 注意写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。 love hate 爱上了讨厌 记忆法 或者 lv 包包 非常 hao 12345678a &#123; /* a是标签选择器 所有的链接 */truetruetruefont-weight: 700;truetruetruefont-size: 16px;truetruetruecolor: gray;truetrue&#125;a:hover &#123; /* :hover 是链接伪类选择器 鼠标经过 */truetruetruecolor: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */&#125; 结构(位置)伪类选择器（CSS3) :first-child :选取属于其父元素的首个子元素的指定选择器 :last-child :选取属于其父元素的最后一个子元素的指定选择器 :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型 :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式 ​ 123456789li:first-child &#123; /* 选择第一个孩子 */ color: pink; &#125;li:last-child &#123; /* 最后一个孩子 */ color: purple; &#125;li:nth-child(4) &#123; /* 选择第4个孩子 n 代表 第几个的意思 */ truetruetruetruecolor: skyblue; &#125; 目标伪类选择器(CSS3) :target目标伪类选择器 :选择器可用于选取当前活动的目标元素 1234:target &#123;truetruecolor: red;truetruefont-size: 30px;&#125; CSS注释1CSS规则是使用 /* 需要注释的内容 */ 进行注释的，即在需要注释的内容前使用 “/*” 标记开始注释，在内容的结尾使用 “*/”结束。 例如： 123p &#123; font-size: 14px; /* 所有的字体是14像素大小*/&#125; CSS外观属性color:文本颜色color属性用于定义文本的颜色，其取值方式有如下3种： 1.预定义的颜色值，如red，green，blue等。 2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。 3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。 需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。 line-height:行间距ine-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 一般情况下，行距比字号大7.8像素左右就可以了。 text-align:水平对齐方式1text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下： left：左对齐（默认值） right：右对齐 center：居中对齐 text-indent:首行缩进text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 letter-spacing:字间距letter-spacing属性用于定义字间距，所谓字间距就是字符与字符之间的空白。其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing:单词间距word-spacing属性用于定义英文单词之间的间距，对中文字符无效。和letter-spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。 颜色半透明(css3)文字颜色到了CSS3我们可以采取半透明的格式了语法格式如下： 1color: rgba(r,g,b,a) a 是alpha 透明的意思 取值范围 0~1之间 color: rgba(0,0,0,0.3) 文字阴影(CSS3)以后我们可以给我们的文字添加阴影效果了 Shadow 影子 1text-shadow:水平位置 垂直位置 模糊距离 阴影颜色; 前两项是必须写的。 后两项可以选写。 sublime快捷方式sublime可以快速提高我们代码的书写方式 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 如果想要生成多个相同标签 加上 就可以了 比如 div3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 ​ 引入CSS样式表（书写位置）CSS可以写到那个位置？ 是不是一定写到html文件里面呢？ 内部样式表内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下： 12345&lt;head&gt;&lt;style type="text/CSS"&gt; 选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;&lt;/style&gt;&lt;/head&gt; 语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。 type=”text/CSS” 在html5中可以省略， 写上也比较符合规范， 所以这个地方可以写也可以省略。 行内式（内联样式）内联样式，又有人称行内样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下： 1&lt;标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"&gt; 内容 &lt;/标签名&gt; 语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。 外部样式表（外链式）链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下： 123&lt;head&gt; &lt;link href="CSS文件的路径" type="text/CSS" rel="stylesheet" /&gt;&lt;/head&gt; 注意： link 是个单标签哦!!! 该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下： 123href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 三种样式表总结 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） 标签显示模式（display） 非洲黑人： 皮肤内黑色素含量高，以吸收阳光中的紫外线，保护皮肤内部结构免遭损害，头发象羊毛一样卷曲，使每根卷发周围都有许多空隙，空隙充满空气，卷发有隔热作用。 欧洲白人： 生活寒带或着是说常年温度较低的地缘,加上年日照时间少，身体的黑色素沉淀比较少所以出现皮肤、发色、瞳晕都呈现浅色 传智黄人： 我中间的。。。 最重要的总结： 是为了更好的适应环境而完成的自然选择。 同理，我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。 标签的类型(显示模式) HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下： 块级元素(block-level)每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 1常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素(inline-level)行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。 1常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。 我一样重要 行内元素的特点： （1）和相邻行内元素在一行上。 （2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。（a特殊） 注意： 只有 文字才 能组成段落 因此 p 里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 链接里面不能再放链接。 块级元素和行内元素区别12345块级元素的特点：（1）总是从新行开始（2）高度，行高、外边距以及内边距都可以控制。（3）宽度默认是容器的100%（4）可以容纳内联元素和其他块元素。 12345行内元素的特点：（1）和相邻行内元素在一行上。（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。（3）默认宽度就是它本身内容的宽度。（4）行内元素只能容纳文本或则其他行内元素。 行内块元素（inline-block）123456在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。行内块元素的特点：（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。（2）默认宽度就是它本身内容的宽度。（3）高度，行高、外边距以及内边距都可以控制。 标签显示模式转换 display块转行内：display:inline; 行内转块：display:block; 块、行内元素转换为行内块： display: inline-block; 此阶段，我们只需关心这三个，其他的是我们后面的工作。 CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。 交集选择器交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 1比如： p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用。 并集选择器并集选择器（CSS选择器分组）是各个选择器通过逗号连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。 记忆技巧： 并集选择器 和 的意思， 就是说，只要逗号隔开的，所有选择器都会执行后面样式。 1比如 .one, p , #test &#123;color: #F00;&#125; 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 他和他，在一起， 在一起 一起的意思 后代选择器后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 子元素选择器子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，符号左右两侧各保留一个空格。 白话： 这里的子 指的是 亲儿子 不包含孙子 重孙子之类。 1比如： .demo &gt; h3 &#123;color: red;&#125; 说明 h3 一定是demo 亲儿子。 demo 元素包含着h3。 测试题123456789101112131415161718&lt;div class="nav"&gt; &lt;!-- 主导航栏 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;公司首页&lt;/a&gt;&lt;/li&gt;true&lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt;true&lt;li&gt;&lt;a href="#"&gt;公司产品&lt;/a&gt;&lt;/li&gt;true&lt;li&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt;truetrue &lt;ul&gt;truetrue &lt;li&gt;&lt;a href="#"&gt;公司邮箱&lt;/a&gt;&lt;/li&gt;truetrue &lt;li&gt;&lt;a href="#"&gt;公司电话&lt;/a&gt;&lt;/li&gt;truetrue &lt;/ul&gt;true&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class="sitenav"&gt; &lt;!-- 侧导航栏 --&gt; &lt;div class="site-l"&gt;左侧侧导航栏&lt;/div&gt; &lt;div class="site-r"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/div&gt;&lt;/div&gt; 在不修改以上代码的前提下，完成以下任务： 链接 登录 的颜色为红色,同时主导航栏里面的所有的链接改为蓝色 (简单) 主导航栏和侧导航栏里面文字都是14像素并且是微软雅黑。（中等) 主导航栏里面的一级菜单链接文字颜色为绿色。（难) ​ 属性选择器选取标签带有某些特殊属性的选择器 我们成为属性选择器 12345678910/* 获取到 拥有 该属性的元素 */div[class^=font] &#123; /* class^=font 表示 font 开始位置就行了 */truetruetruecolor: pink;truetrue&#125;div[class$=footer] &#123; /* class$=footer 表示 footer 结束位置就行了 */truetruetruecolor: skyblue;truetrue&#125;div[class*=tao] &#123; /* class*=tao *= 表示tao 在任意位置都可以 */truetruetruecolor: green;truetrue&#125; 1234567891011&lt;div class="font12"&gt;属性选择器&lt;/div&gt; &lt;div class="font12"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="24font"&gt;属性选择器123&lt;/div&gt; &lt;div class="sub-footer"&gt;属性选择器footer&lt;/div&gt; &lt;div class="jd-footer"&gt;属性选择器footer&lt;/div&gt; &lt;div class="news-tao-nav"&gt;属性选择器&lt;/div&gt; &lt;div class="news-tao-header"&gt;属性选择器&lt;/div&gt; &lt;div class="tao-header"&gt;属性选择器&lt;/div&gt; 伪元素选择器（CSS3) E::first-letter文本的第一个单词或字（如中文、日文、韩文等） E::first-line 文本第一行； E::selection 可改变选中文本的样式； 1234567891011121314p::first-letter &#123; font-size: 20px; color: hotpink;&#125;/* 首行特殊样式 */p::first-line &#123; color: skyblue;&#125;p::selection &#123; /* font-size: 50px; */ color: orange;&#125; 4、E::before和E::after 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。 123456div::befor &#123; content:"开始";&#125;div::after &#123; content:"结束";&#125; E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。 E:after、E:before后面的练习中会反复用到，目前只需要有个大致了解 “:” 与 “::” 区别在于区分伪类和伪元素 CSS书写规范开始就形成良好的书写规范，是你专业化的开始。 空格规范【强制】 选择器 与 { 之间必须包含空格。 示例： .selector { } 【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例： font-size: 12px; 选择器规范【强制】 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。 示例： 123456789101112/* good */.post,.page,.comment &#123; line-height: 1.5;&#125;/* bad */.post, .page, .comment &#123; line-height: 1.5;&#125; 【建议】 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例： 1234567/* good */#username input &#123;&#125;.comment .avatar &#123;&#125;/* bad */.page .header .login #username input &#123;&#125;.comment div * &#123;&#125; 属性规范【强制】 属性定义必须另起一行。 示例： 12345678/* good */.selector &#123; margin: 0; padding: 0;&#125;/* bad */.selector &#123; margin: 0; padding: 0; &#125; 【强制】 属性定义后必须以分号结尾。 示例： 123456789/* good */.selector &#123; margin: 0;&#125;/* bad */.selector &#123; margin: 0&#125; CSS 背景(background)CSS 可以添加背景颜色和背景图片，以及来进行图片设置。 background-color 背景颜色 background-image 背景图片地址 background-repeat 是否平铺 background-position 背景位置 background-attachment 背景固定还是滚动 背景的合写（复合属性） background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 背景图片(image)语法： 1background-image : none | url (url) 参数： none : 无背景图（默认的）url : 使用绝对或相对地址指定背景图像 background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。 小技巧： 我们提倡 背景图片后面的地址，url不要加引号。 背景平铺（repeat）语法： 1background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数： repeat : 背景图像在纵向和横向上平铺（默认的） no-repeat : 背景图像不平铺 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 背景位置(position)语法： 123background-position : length || lengthbackground-position : position || position 参数： length : 百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位position : top | center | bottom | left | center | right 说明： 设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。 注意： position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top; 则 15px 一定是 x坐标 top是 y坐标。 实际工作用的最多的，就是背景图片居中对齐了。 背景附着语法： 1background-attachment : scroll | fixed 参数： scroll : 背景图像是随对象内容滚动fixed : 背景图像固定 说明： 设置或检索背景图像是随对象内容滚动还是固定的。 背景简写background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写： background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 1background: transparent url(image.jpg) repeat-y scroll 50% 0 ; 背景透明(CSS3)CSS3支持背景半透明的写法语法格式是: 1background: rgba(0,0,0,0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。 背景缩放(CSS3)通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。 其参数设置如下： a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高） b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多 c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。 1234background-image: url('images/gyt.jpg');truetruetruebackground-size: 300px 100px;truetruetrue/* background-size: contain; */truetruetrue/* background-size: cover; */ 多背景(CSS3)以逗号分隔可以设置多背景，可用于自适应布局 做法就是 用逗号隔开就好了。 一个元素可以设置多重背景图像。 每组属性间使用逗号分隔。 如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。 为了避免背景色将图像盖住，背景色通常都定义在最后一组上， 123background:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px ,true url(test1.jpg) no-repeat scroll 10px 20px/70px 90px ,true url(test1.jpg) no-repeat scroll 10px 20px/110px 130px c #aaa; ​ 凹凸文字12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125;truetruediv &#123;truetruetruecolor: #ccc;truetruetruefont: 700 80px "微软雅黑";truetrue&#125;truetruediv:first-child &#123;truetruetrue/* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */truetruetruetext-shadow: 1px 1px 1px #000, -1px -1px 1px #fff;truetrue&#125;truetruediv:last-child &#123;truetruetrue/* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */truetruetruetext-shadow: -1px -1px 1px #000, 1px 1px 1px #fff;truetrue&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是凸起的文字&lt;/div&gt; &lt;div&gt;我是凹下的文字&lt;/div&gt; &lt;/body&gt; 导航栏案例文本的装饰text-decoration 通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。下划线 也是我们链接自带的 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 使用技巧：在一行内的盒子内，我们设定行高等于盒子的高度，就可以使文字垂直居中。 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; body &#123; background-color: #000; &#125; a &#123; width: 200px; height: 50px; /* background-color: orange; */ display: inline-block; /* 把a 行内元素转换为行内块元素 */ text-align: center; /* 文字水平居中 */ line-height: 50px; /* 我们设定行高等于盒子的高度，就可以使文字垂直居中 */ color: #fff; font-size: 22px; text-decoration: none; /* 取消下划线 文本装饰 */ &#125; a:hover &#123; /* 鼠标经过 给我们的链接添加背景图片*/ background: url(images/h.png) no-repeat; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="#"&gt;专区说明&lt;/a&gt; &lt;a href="#"&gt;申请资格&lt;/a&gt; &lt;a href="#"&gt;兑换奖励&lt;/a&gt; &lt;a href="#"&gt;下载游戏&lt;/a&gt; &lt;/body&gt; CSS 三大特性层叠 继承 优先级 是我们学习CSS 必须掌握的三个特性。 CSS层叠性所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。 一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。 样式不冲突，不会层叠 1CSS最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 CSS继承性所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 1CSS最后的执行口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞。 注意： 1恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性） CSS优先级定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。 在考虑权重时，初学者还需要注意一些特殊的情况，具体如下： 1234567继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。 CSS特殊性（Specificity）关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下： specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 继承或者* 的贡献值 0,0,0,0 每个元素（标签）贡献值为 0,0,0,1 每个类，伪类贡献值为 0,0,1,0 每个ID贡献值为 0,1,0,0 每个行内样式贡献值 1,0,0,0 每个!important贡献值 ∞ 无穷大 权重是可以叠加的 比如的例子： 123456789div ul li ------&gt; 0,0,0,3.nav ul li ------&gt; 0,0,1,2a:hover -----—&gt; 0,0,1,1.nav a ------&gt; 0,0,1,1 #nav p -----&gt; 0,1,0,1 ​ ​ 注意： 1.数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 继承的 权重是 0 总结优先级： 使用了 !important声明的规则。 内嵌在 HTML 元素的 style属性里面的声明。 使用了 ID 选择器的规则。 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。 使用了元素选择器的规则。 只包含一个通用选择器的规则。 同一类选择器则遵循就近原则。 1总结：权重是优先级的算法，层叠是优先级的表现 盒子模型（CSS重点）其实，CSS就三个大模块： 盒子模型 、 浮动 、 定位，其余的都是细节。要求这三部分，无论如何也要学的非常精通。 所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。 看透网页布局的本质网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？ 牛奶是怎样运输，让消费者购买的呢？ 我们说过，行内元素比如 文字 类似牛奶，也需要一个盒子把他们装起来，我们前面学过的双标签都是一个盒子。有了盒子，我们就可以随意的，自由的，摆放位置了。 看透网页布局的本质： 把网页元素比如文字图片等等，放入盒子里面，然后利用CSS摆放盒子的过程，就是网页布局。 CSS 其实没有太多逻辑可言 ， 类似我们小时候玩的积木,我们可以自由的，随意的摆放出我们想要的效果。 盒子模型（Box Model）这里略过 老旧的ie盒子模型（IE6以下），对不起，我都没见过IE5的浏览器。 。首先，我们来看一张图，来体会下什么是盒子模型。 所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素再网页布局汇总所占的位置大小。因此，每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。 盒子边框（border）边框就是那层皮。 橘子皮。。柚子皮。。橙子皮。。。 语法： 1border : border-width || border-style || border-color 边框属性—设置边框样式（border-style） 边框样式用于定义页面中边框的风格，常用属性值如下： 123456789none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的)dashed：边框为虚线 dotted：边框为点线double：边框为双实线 盒子边框写法总结表 设置内容 样式属性 常用属性值 上边框 border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; 下边框 border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; 左边框 border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; 右边框 border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; 样式综合设置 border-style:上边 [右边 下边 左边]; none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 宽度综合设置 border-width:上边 [右边 下边 左边]; 像素值 颜色综合设置 border-color:上边 [右边 下边 左边]; 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%) 边框综合设置 border:四边宽度 四边样式 四边颜色; 表格的细线边框以前学过的html表格边框很粗，这里只需要CSS一句话就可以美观起来。 让我们真的相信，CSS就是我们的白马王子（白雪公主）。 table{ border-collapse:collapse; } collapse 单词是合并的意思 border-collapse:collapse; 表示边框合并在一起。 圆角边框(CSS3)从此以后，我们的世界不只有矩形。radius 半径（距离） 语法格式： 1border-radius: 左上角 右上角 右下角 左下角; 课堂案例: 123456789101112131415161718192021222324252627282930313233&lt;style&gt; div &#123; width: 200px; height: 200px; border: 1px solid red; &#125; div:first-child &#123; /* 结构伪类选择器 选亲兄弟 */ border-radius: 10px; /* 一个数值表示4个角都是相同的 10px 的弧度 */ &#125; div:nth-child(2) &#123; /*border-radius: 100px; 取宽度和高度 一半 则会变成一个圆形 */ border-radius: 50%; /* 100px 50% 取宽度和高度 一半 则会变成一个圆形 */ &#125; div:nth-child(3) &#123; border-radius: 10px 40px; /* 左上角 和 右下角 是 10px 右上角 左下角 40 对角线 */ &#125; div:nth-child(4) &#123; border-radius: 10px 40px 80px; /* 左上角 10 右上角 左下角 40 右下角80 */ &#125; div:nth-child(5) &#123; border-radius: 10px 40px 80px 100px; /* 左上角 10 右上角 40 右下角 80 左下角 右下角100 */ &#125; div:nth-child(6) &#123; border-radius: 100px; height: 100px; &#125; div:nth-child(7) &#123; border-radius: 100px 0; &#125; &lt;/style&gt; 内边距（padding）padding属性用于设置内边距。 是指 边框与内容之间的距离。 padding-top:上内边距 padding-right:右内边距 padding-bottom:下内边距 padding-left:左内边距 注意： 后面跟几个数值表示的意思是不一样的。 值的个数 表达意思 1个值 padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 2个值 padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 3个值 padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 4个值 padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 课堂案例： 新浪导航 外边距（margin）margin属性用于设置外边距。 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。 margin-top:上外边距 margin-right:右外边距 margin-bottom:下外边距 margin-left:上外边距 margin:上外边距 右外边距 下外边距 左外边 取值顺序跟内边距相同。 外边距实现盒子居中可以让一个盒子实现水平居中，需要满足一下两个条件： 必须是块级元素。 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto，就可使块级元素水平居中。 实际工作中常用这种方式进行网页布局，示例代码如下： 1.header&#123; width:960px; margin:0 auto;&#125; 文字盒子居中图片和背景区别 文字水平居中是 text-align: center 盒子水平居中 左右margin 改为 auto 12text-align: center; /* 文字居中水平 */margin: 10px auto; /* 盒子水平居中 左右margin 改为 auto 就阔以了 */ 插入图片 我们用的最多 比如产品展示类 背景图片我们一般用于小图标背景 或者 超大背景图片 12345678910111213141516section img &#123; truetruewidth: 200px;/* 插入图片更改大小 width 和 height */truetrueheight: 210px;truetruemargin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */truetruemargin-left: 50px; /* 插入当图片也是一个盒子 */true&#125;aside &#123;truetruewidth: 400px;truetrueheight: 400px;truetrueborder: 1px solid purple;truetruebackground: #fff url(images/sun.jpg) no-repeat;truetruetruebackground-size: 200px 210px; /* 背景图片更改大小只能用 background-size */truetruebackground-position: 30px 50px; /* 背景图片更该位置 我用 background-position */true&#125; 清除元素的默认内外边距为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： 1234* &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */&#125; 注意： 行内元素是只有左右外边距的，是没有上下外边距的。 内边距，在ie6等低版本浏览器也会有问题。 我们尽量不要给行内元素指定上下的内外边距就好了。 外边距合并使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案： 避免就好了。 嵌套块元素垂直外边距的合并对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。 解决方案： 可以为父元素定义1像素的上边框或上内边距。 可以为父元素添加overflow:hidden。 待续。。。。 content宽度和高度使用宽度属性width和高度属性height可以对盒子的大小进行控制。 width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。 大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是： 123456/*外盒尺寸计算（元素空间尺寸）*/Element空间高度 = content height + padding + border + marginElement 空间宽度 = content width + padding + border + margin/*内盒尺寸计算（元素实际大小）*/Element Height = content height + padding + border （Height为内容高度）Element Width = content width + padding + border （Width为内容宽度） 注意： 1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。 2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。 3、如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding 不会影响本盒子大小。 盒子模型布局稳定性开始学习盒子模型，同学们最大的困惑就是， 分不清内外边距的使用，什么情况下使用内边距，什么情况下使用外边距？ 答案是： 其实他们大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。 但是，总有一个最好用的吧，我们根据稳定性来分，建议如下： 按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。 1width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 ​ CSS3盒模型CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。 可以分成两种情况： 1、box-sizing: content-box 盒子大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode 2、box-sizing: border-box 盒子大小为 width 就是说 padding 和 border 是包含到width里面的 注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。 12345678910111213141516171819div:first-child &#123;truetruetruewidth: 200px;truetruetrueheight: 200px;truetruetruebackground-color: pink; truetruetruebox-sizing: content-box; /* 就是以前的标准盒模型 w3c */truetruetruepadding: 10px;truetruetrueborder: 15px solid red;truetruetrue/* 盒子大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode */truetrue&#125;truetruediv:last-child &#123;truetruetruewidth: 200px;truetruetrueheight: 200px;truetruetruebackground-color: purple;truetruetruepadding: 10px;truetruetruebox-sizing: border-box; /* padding border 不撑开盒子 */truetruetrueborder: 15px solid red;truetruetrue/* margin: 10px; */truetruetrue/* 盒子大小为 width 就是说 padding 和 border 是包含到width里面的 */&#125; 盒子阴影语法格式： 1box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影； 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 但是不能写 默认 想要内阴影 inset 123456789div &#123;truetruetruewidth: 200px;truetruetrueheight: 200px;truetruetrueborder: 10px solid red;truetruetrue/* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */truetruetrue/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */truetruetruebox-shadow: 0 15px 30px rgba(0, 0, 0, .4);truetruetrue&#125; 浮动(float)普通流(normal flow)这个单词很多人翻译为 文档流 ， 字面翻译 普通流 或者标准流都可以。 前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？ CSS的定位机制有3种：普通流（标准流）、浮动和定位。 html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 浮动(float)浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。 后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了。（CSS3已经我们真正意义上的网页布局，具体CSS3我们会详细解释） 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。 在CSS中，通过float属性来定义浮动，其基本语法格式如下： 1选择器&#123;float:属性值;&#125; 属性值 描述 left 元素向左浮动 right 元素向右浮动 none 元素不浮动（默认值） 浮动详细内幕特性浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。 1浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。 1浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。 1由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。 1元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。 总结： 浮动 —&gt; 浮动的目的就是为了让多个块级元素同一行上显示。 float 浮 漏 特 浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。特： 特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。 版心和布局流程阅读报纸时容易发现，虽然报纸中的内容很多，但是经过合理地排版，版面依然清晰、易读。同样，在制作网页时，要想使页面结构清晰、有条理，也需要对网页进行“排版”。 “版心”(可视区) 是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。 布局流程为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下： 1、确定页面的版心（可视区）。 2、分析页面中的行模块，以及每个行模块中的列模块。 3、制作HTML结构 。 4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 一列固定宽度且居中 最普通的，最为常用的结构 两列左窄右宽型 比如小米 小米官网 通栏平均分布型 比如锤子 锤子官网 清除浮动人生就像乘坐北京地铁一号线： 途经国贸，羡慕繁华； 途经天安门，幻想权力； 途经金融街，梦想发财； 经过公主坟，遥想华丽家族； 经过玉泉路，依然雄心勃勃… 这时，有个声音飘然入耳:乘客你好,八宝山马上就要到了！ 顿时醒悟：人生苦短，有始有终。 好比我们的浮动，有浮动开始，则就应该有浮动结束。 为什么要清除浮动我们前面说过，浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但是，你不能说浮动不好 。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。 准确地说，并不是清除浮动，而是清除浮动后造成的影响 如果浮动一开始就是一个美丽的错误，那么请用正确的方法挽救它。 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 清除浮动的方法其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 在CSS中，clear属性用于清除浮动，其基本语法格式如下： 1选择器&#123;clear:属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 额外标签法1是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解） 1可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 使用after伪元素清除浮动:after 方式为空元素的升级版，好处是不用单独加标签了 使用方法： 123.clearfix:after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123;*zoom: 1;&#125; /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等 注意： content:”.” 里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。 使用before和after双伪元素清除浮动使用方法： 12345678910.clearfix:before,.clearfix:after &#123; content:""; display:table; /* 这句话可以出发BFC BFC可以清除浮动,BFC我们后面讲 */&#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等 Photoshop图像处理专家 PS 工具是我们使用频率比较高的软件之一， 我们学习PS目的不是为了设计海报做电商和UI的，而是要求： 会简单的抠图 会简单的修改PSD效果图 熟练的切图 能和网站美工美眉有共同话题。。。。。 Photoshop基本使用PS界面组成：菜单栏、选项栏、工具栏、浮动面板（拖拽名称，可单独操作面板）、绘图窗口​ 窗口菜单，可显示隐藏所有面板 工作区：（新建） 调整浮动面板 基本操作文件下拉菜单：​ 1、新建 新建文档 CTRL+N 单位：像素 厘米 毫米 屏幕显示： 单位 像素 72像素/英寸 RGB颜色模式 2、关闭文档 CTRL+W 3、存储 CTRL+S （替存） 4、存储为 CTRL+SHIFT+S 另存一份文件 5、格式：​ .psd PS源文件格式 图层、文字、样式等，可再次编辑​ （给自己）​ .jpg 有损压缩格式 （给客户） 品质 最高12 6、文件打开：​ 1）文件下拉菜单-打开（CTRL+O欧） ​ 2）双击软件空白处也能打开​ 移动工具 V1、不同文件之间拖拽图像。 自由变形ctrl + T 可以改变图像的大小 按下enter 回车确认操作。 图层操作(重点) 图层面板快捷键 F7 其实图层就是一张张透明的纸 可以实现叠加问题。 图层选择： 使用移动工具V 1、图层缩览图判断 2、按住CTRL,在目标图像上单击 3、将光标放置在目标图像上右键，选择图层名称 图层面板中加选图层： 1、按SHIFT，单击另一目标图层 中间所有图层被选中 2、按CTRL，单击另一目标图层 只选中目标图层 复制图层：选中目标图层后（移动工具状态下） 1、按ALT拖拽图像 2、CTRL+J （重合） 案例： 摆放一个自行车 图层编组选中目标图层，CTRL+G 取消编组：CTRL+SHIFT+G 双击图层名称可重新命名 双击组名称，可命名组 移动工具V选择组或图层时，需设置选项栏 图层上下位置移动1、选中目标图层，在图层面拖拽 2、CTRL+] 向上移动图层​ CTRL+[ 向下移动图层 3、CTRL+SHIFT+] 图层置顶​ CTRL+SHIFT+[ 图层置底 移动选区或图像时： 移动过程中，没释放鼠标，按住SHIFT，可同一水平线、同一垂线、45度移动。 ps中的撤销操作是： ctrl+z 撤销一步 ctrl+alt+z 撤销多步 图层合并ctrl+e 可以合并图层 图层透明度不透明度：设置图层的不透明程度 0%完全透明，不可见 ​ 100%完全不透明，真实可见 填充：与不透明度效果类似 ) 键盘数字键，可快速设置透明度数值 矩形选区工具 M用来选择某部分区域 我们成为选区工具 取消选区： ctrl+d 颜色填充 套索工具 L1、套索工具 L 在屏幕上拖拽鼠标左键，释放后生成选区 2、多边形套索 L 连续单击绘制多边形选区 ​ 闭合方法：1、单击起始点 2、双击任意位置 ​ DELETE删除当前点 磁性套索 LL 在颜色交界的位置单击后拖动。单击起始点后，生成选区。 魔棒工具 W以单击位置为选择色，选择相似颜色生成选区。 容差：选择颜色的范围 容差小，颜色选择精确。 0-255 连续：勾选连续时，相连颜色生成选区。 ​ 不勾选，画面中所有相似颜色被选中生成选区。 按SHIFT在未生成选区位置单击，可选区相加。 选区反选：CTRL+SHIFT+I 选区布尔运算 选区面积大小的变化。 新选区：保持选中状态 添加到选区：相加运算（按住SHIFT再绘制选区） 从选区减去：相减（按住ALT再绘制选区） 与选区交叉：重合部分保留。（按住ALT+SHIFT再绘制选区） 梦幻星球 钢笔工具： P作用：绘制路径，生成选区，抠图。 组成;路径线和锚点 绘制路径后，CTRL+回车，生成选区。 路径类型： 直线型路径：连续单击 曲线型路径：第一点单击，第二点拖动鼠标。 文字工具T 可以直接输入文字 Photoshop 切图PS切图 可以 分为 手动 利用切片切图 以及 利用PS的插件快速切图 切片工具 利用切片工具手动划出 图层菜单—新建基于图层的切片 利用标尺 基于参考线的切片 （选择切片工具） ​ 先选个一个整个的切片， 切片选择工具– 属性面板中有 “划分” –可以等分数平分切图 导出切片： 文件– 存储为web设备所用格式 辅助线和切片使用及清除视图菜单– 清除 辅助线/ 清除切片 切图插件Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。 官网: http://www.cutterman.cn/zh/cutterman 注意： cutterman插件要求你的ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。 项目案例： 学成网案例练习目的是总结以前的css和html 还有ps的使用。 制作步骤： 准备相关文件。（内部样式表) html文件(index.html) 图片文件 准备CSS 初始化。 书写结构和样式 确定版心（是1200像素)和各个模块。 定位(position)如果，说浮动， 关键在一个 “浮” 字上面， 那么 我们的定位，关键在于一个 “位” 上。 PS: 定位是我们CSS算是数一数二难点的了，但是，你务必要学好它，我们CSS离不开定位，特别是后面的js特效，天天和定位打交道。不要抵触它，反而要爱上它，它可以让我们工作更加轻松哦！ 为什么要用定位？那么定位，最长运用的场景再那里呢？ 来看几幅图片，你一定会有感悟！ 第一幅图， 小黄色块可以再图片上移动： 第二幅图， 左右箭头压住图片： 第三幅图, hot 再盒子外面多出一块，更加突出： 以上三个小地方，如果用标准流或者浮动，实现会比较复杂或者难以实现，此时我们用定位来做，just soso！ 元素的定位属性元素的定位属性主要包括定位模式和边偏移两部分。 1、边偏移 边偏移属性 描述 top 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom 底部偏移量，定义元素相对于其父元素下边线的距离 left 左侧偏移量，定义元素相对于其父元素左边线的距离 right 右侧偏移量，定义元素相对于其父元素右边线的距离 也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px; left: 30px; 等等 2、定位模式(定位的分类) 在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下： 选择器{position:属性值;} position属性的常用值 值 描述 static 自动定位（默认定位方式） relative 相对定位，相对于其原文档流的位置进行定位 absolute 绝对定位，相对于其上一个已经定位的父元素进行定位 fixed 固定定位，相对于浏览器窗口进行定位 静态定位(static)静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。 上面的话翻译成白话： 就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。 在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。 PS： 静态定位其实没啥可说的。 相对定位relative(自恋型)12小笑话： 刚刚看到一个超级超级帅的帅哥，看得我都忍不住想和他搞基了。世间怎会有如此之完美的男人。我和他就这样一动不动的对视着，就仿佛一见钟情。时间也在这一瞬间停止了。直到我的手麻了。才恋恋不舍的放下镜子。。。。 相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。 对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示： 注意： 相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。 其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置） 就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标） 如果说浮动的主要目的是 让多个块级元素一行显示，那么定位的主要价值就是 移动位置， 让盒子到我们想要的位置上去。 绝对定位absolute (拼爹型)1234567小笑话：吃早饭时，老婆往儿子碗里放了两个煎蛋，儿子全给了我，还一本正经地说：“爸爸，多吃点，男人养家不容易。” &lt;br/&gt;我一阵感动，刚想夸他两句。 儿子接着说：“以后全靠你让我拼爹了！” [注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。 当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。 注意： 绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。 父级没有定位若所有父元素都没有定位，以浏览器为准对齐(document文档)。 父级有定位绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 子绝父相这个“子绝父相”太重要了，是我们学习定位的口诀，时时刻刻记住的。 这句话的意思是 子级是绝对定位的话， 父级要用相对定位。 首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。 就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。 但是，在我们网页布局的时候， 最常说的 子绝父相是怎么来的呢？ 请看如下图： 所以，我们可以得出如下结论： 因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。 父盒子布局时，需要占有位置，因此父亲只能是 相对定位. 这就是子绝父相的由来。 绝对定位的盒子水平/垂直居中普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了 定位的盒子也可以水平或者垂直居中，有一个算法。 首先left 50% 父盒子的一半大小 然后走自己外边距负的一半值就可以了 margin-left。 ​ 固定定位fixed(认死理型)固定定位是绝对定位的一种特殊形式，类似于 正方形是一个特殊的 矩形。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。 当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。 固定定位有两点： 固定定位的元素跟父亲没有任何关系，只认浏览器。 固定定位完全脱标，不占有位置，不随着滚动条滚动。 记忆法： 就类似于孙猴子， 无父无母，好不容易找到一个可靠的师傅（浏览器），就听的师傅的，别的都不听。 ie6等低版本浏览器不支持固定定位。 叠放次序（z-index）当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。 在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。 比如： z-index: 2; 注意： z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。 如果取值相同，则根据书写顺序，后来居上。 后面数字一定不能加单位。 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。 四种定位总结 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 不脱标，占有位置 可以 相对自身位置移动（自恋型） 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置（拼爹型） 固定定位fixed 完全脱标，不占有位置 可以 相对于浏览器移动位置（认死理型） 定位模式转换跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式， 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。 元素的显示与隐藏在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。 他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！ display 显示display 设置或检索对象是否及如何显示。 display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： 隐藏之后，不再保留位置。 visibility 可见性设置或检索是否显示对象。 visible : 对象可视 hidden : 对象隐藏 特点： 隐藏之后，继续保留原有位置。（停职留薪） overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 visible : 不剪切内容也不添加滚动条。 auto : 超出自动显示滚动条，不超出不显示滚动条 hidden : 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll : 不管超出内容否，总是显示滚动条 CSS高级技巧CSS用户界面样式 所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。 防止表单域拖拽 鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 1cursor : default 小白 | pointer 小手 | move 移动 | text 文本 鼠标放我身上查看效果哦： 123456&lt;ul&gt; &lt;li style="cursor:default"&gt;我是小白&lt;/li&gt; &lt;li style="cursor:pointer"&gt;我是小手&lt;/li&gt; &lt;li style="cursor:move"&gt;我是移动&lt;/li&gt; &lt;li style="cursor:text"&gt;我是文本&lt;/li&gt;&lt;/ul&gt; 尽量不要用hand 因为 火狐不支持 pointer ie6以上都支持的尽量用 轮廓 outline 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 1outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。 最直接的写法是 ： outline: 0; 或者 outline: none; 1&lt;input type="text" style="outline: 0;"/&gt; 防止拖拽文本域resizeresize：none 这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。 右下角可以拖拽： 右下角不可以拖拽： 1&lt;textarea style="resize: none;"&gt;&lt;/textarea&gt; vertical-align 垂直对齐以前我们讲过让带有宽度的块级元素居中对齐，是margin: 0 auto; 以前我们还讲过让文字居中对齐，是 text-align: center; 但是我们从来没有讲过有垂直居中的属性， 我们的妈妈一直很担心我们的垂直居中怎么做。 vertical-align 垂直对齐， 这个看上去很美好的一个属性， 实际有着不可捉摸的脾气，否则我们也不会这么晚来讲解。 1vertical-align : baseline |top |middle |bottom 设置或检索对象内容的垂直对其方式。 vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， 通常用来控制图片/表单与文字的对齐。 图片、表单和文字对齐所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。 去除图片底侧空白缝隙有个很重要特性你要记住： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。这样会造成一个问题，就是图片底侧会有一个空白缝隙。 解决的方法就是： 给img vertical-align:middle | top等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 溢出的文字隐藏word-break:自动换行normal 使用浏览器默认的换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。 主要处理英文单词 white-spacewhite-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容 normal : 默认处理方式nowrap : 强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。 可以处理中文 text-overflow 文字溢出text-overflow : clip | ellipsis 设置或检索是否使用一个省略标记（…）标示对象内文本的溢出 clip : 不显示省略标记（…），而是简单的裁切 ellipsis : 当对象内文本溢出时显示省略标记（…） 注意一定要首先强制一行内显示，再次和overflow属性 搭配使用 CSS精灵技术（sprite） 小妖精 雪碧精灵技术产生的背景 图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。 然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。 精灵技术本质简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图（雪碧图），如下图所示为京东网站中的一个精灵图。 精灵技术的使用CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。 制作精灵图CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。 大部分情况下，精灵图都是网页美工做。 1234我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。我们精灵图的宽度取决于最宽的那个背景。 我们可以横向摆放也可以纵向摆放，但是每个图片之间，间隔至少隔开偶数像素合适。在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。 结束语： 小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。 字体图标图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额不是出现了，是以前就有，是被从新”宠幸”啦。。 这就是字体图标（iconfont). 字体图标优点12345可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...本身体积更小，但携带的信息并没有削减。几乎支持所有的浏览器移动端设备必备良药... 字体图标使用流程总体来说，字体图标按照如下流程： 设计字体图标假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图： 之后保存为svg格式，然后给我们前端人员就好了。 其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。 上传生成字体包 当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。 ​ 推荐网站： http://icomoon.io icomoon字库 IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 推荐网站： http://www.iconfont.cn/ 阿里icon font字库 http://www.iconfont.cn/ 这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！ fontello http://fontello.com/ 在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。 Font-Awesome http://fortawesome.github.io/Font-Awesome/ 这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。 Glyphicon Halflings http://glyphicons.com/ 这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。 Icons8 https://icons8.com/ 提供PNG免费下载，像素大能到500PX 下载兼容字体包刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了 当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。 字体引入到HTML得到压缩包之后，最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。 首先把 以下4个文件放入到 fonts文件夹里面。 通俗的做法 第一步：在样式里面声明字体： 告诉别人我们自己定义的字体12345678910@font-face &#123; font-family: 'icomoon'; src: url('fonts/icomoon.eot?7kkyc2'); src: url('fonts/icomoon.eot?7kkyc2#iefix') format('embedded-opentype'), url('fonts/icomoon.ttf?7kkyc2') format('truetype'), url('fonts/icomoon.woff?7kkyc2') format('woff'), url('fonts/icomoon.svg?7kkyc2#icomoon') format('svg'); font-weight: normal; font-style: normal;&#125; 第二步：给盒子使用字体123span &#123;truetruefont-family: "icomoon";true&#125; 第三步：盒子里面添加结构12345span::before &#123;truetrue content: "\e900";true&#125;或者 &lt;span&gt;&lt;/span&gt; 追加新图标到原来库里面如果工作中，原来的字体图标不够用了，我们需要添加新的字体图标，但是原来的不能删除，继续使用，此时我们需要这样做 把压缩包里面的selection.json 从新上传，然后，选中自己想要新的图标，从新下载压缩包，替换原来文件即可。 滑动门先来体会下现实中的滑动门,或者你可以叫做推拉门： 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？ 为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。 核心技术核心技术就是利用CSS精灵（主要是背景位置）和盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： 12345&lt;li&gt; &lt;a href="#"&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 before和after伪元素(详解)之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。是伪元素在html代码机构中的展现，可以看出无法伪元素的结构无法审查 注意 伪元素:before和:after添加的内容默认是inline元素**；这个两个伪元素的content属性，表示伪元素的内容,设置:before和:after时必须设置其content属性，否则伪元素就不起作用。 过渡(CSS3)过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片 在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。 语法格式: 12transition: 要过渡的属性 花费时间 运动曲线 何时开始;如果有多组属性变化，还是用逗号隔开。 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 如果想要所有的属性都变化过渡， 写一个all 就可以 transition-duration 花费时间 单位是 秒 s 比如 0.5s 这个s单位必须写 ms 毫秒 运动曲线 默认是 ease 何时开始 默认是 0s 立马开始 运动曲线示意图： 1234567891011121314151617div &#123;truetruetruewidth: 200px;truetruetrueheight: 100px;truetruetruebackground-color: pink;truetruetrue/* transition: 要过渡的属性 花费时间 运动曲线 何时开始; */truetruetruetransition: width 0.6s ease 0s, height 0.3s ease-in 1s;truetruetrue/* transtion 过渡的意思 这句话写到div里面而不是 hover里面 */ truetruetrue&#125;div:hover &#123; /* 鼠标经过盒子，我们的宽度变为400 */truetruetruewidth: 600px;truetruetrueheight: 300px&#125;transition: all 0.6s; /* 所有属性都变化用all 就可以了 后面俩个属性可以省略 */ 2D变形(CSS3) transformtransform是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、倾斜、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。 变形转换 transform transform 变换 变形的意思 《 transformers 变形金刚》 移动 translate(x, y)translate 移动平移的意思 1translate(50px,50px); 使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。 可以改变元素的位置，x、y可为负值； 123translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）translateX(x)仅水平方向移动（X轴移动）translateY(Y)仅垂直方向移动（Y轴移动） 123456789.box &#123; width: 499.9999px; height: 400px; background: pink; position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); /* 走的自己的一半 */&#125; 让定位的盒子水平居中 缩放 scale(x, y) 1transform:scale(0.8,1); 可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。 123scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）scaleX(x)元素仅水平方向缩放（X轴缩放）scaleY(y)元素仅垂直方向缩放（Y轴缩放） scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大 旋转 rotate(deg)可以对元素进行旋转，正值为顺时针，负值为逆时针； 1transform:rotate(45deg); 注意单位是 deg 度数 transform-origin可以调整元素转换变形的原点 1div&#123;transform-origin: left top;transform: rotate(45deg); &#125; /* 改变元素原点到左上角，然后进行顺时旋转45度 */ 如果是4个角，可以用 left top这些，如果想要精确的位置， 可以用 px 像素。 1div&#123;transform-origin: 10px 10px;transform: rotate(45deg); &#125; /* 改变元素原点到x 为10 y 为10，然后进行顺时旋转45度 */ 案例旋转楚乔传 123456789101112131415161718192021222324252627282930313233343536div &#123;truetruetruewidth: 250px;truetruetrueheight: 170px;truetruetrueborder: 1px solid pink;truetruetruemargin: 200px auto;truetruetrueposition: relative;truetrue&#125;truetruediv img &#123;truetruetruewidth: 100%;truetruetrueheight: 100%;truetruetrueposition: absolute;truetruetruetop: 0;truetruetrueleft: 0;truetruetruetransition: all 0.6s;truetruetruetransform-origin: top right;truetruetruetrue&#125;truetruediv:hover img:nth-child(1) &#123; /* 鼠标经过div 第一张图片旋转 */truetruetruetransform: rotate(60deg);truetrue&#125;truetruediv:hover img:nth-child(2) &#123; truetruetruetransform: rotate(120deg);truetrue&#125;truetruediv:hover img:nth-child(3) &#123; truetruetruetransform: rotate(180deg);truetrue&#125;truetruediv:hover img:nth-child(4) &#123; truetruetruetransform: rotate(240deg);truetrue&#125;truetruediv:hover img:nth-child(5) &#123; truetruetruetransform: rotate(300deg);truetrue&#125;truetruediv:hover img:nth-child(6) &#123; truetruetruetransform: rotate(360deg);truetrue&#125; 倾斜 skew(deg, deg) 1transform:skew(30deg,0deg); 该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。 可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。 3D变形(CSS3) transform2d x y 3d x y z 左手坐标系 伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图 CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图 简单记住他们的坐标： x左边是负的，右边是正的 y 上面是负的， 下面是正的 z 里面是负的， 外面是正的 rotateX() 就是沿着 x 立体旋转. 1234567img &#123; transition:all 0.5s ease 0s;&#125;img:hove &#123; transform:rotateX(180deg);&#125; rotateY()沿着y轴进行旋转 1234567img &#123; transition:all 0.5s ease 0s;&#125;img:hove &#123; transform:rotateX(180deg);&#125; rotateZ()沿着z轴进行旋转 123456789img &#123; transition:all .25s ease-in 0s;&#125;img:hover &#123; /* transform:rotateX(180deg); */ /* transform:rotateY(180deg); */ /* transform:rotateZ(180deg); */ /* transform:rotateX(45deg) rotateY(180deg) rotateZ(90deg) skew(0,10deg); */&#125; 透视(perspective)电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。 透视可以将一个2D平面，在转换的过程当中，呈现3D效果。 透视原理： 近大远小 。 浏览器透视：把近大远小的所有图像，透视在屏幕上。 perspective：视距，表示视点距离屏幕的长短。视点，用于模拟透视效果时人眼的位置 注：并非任何情况下需要透视效果，根据开发需要进行设置。 perspective 一般作为一个属性，设置给父元素，作用于所有3D转换的子元素 理解透视距离原理： translateX(x)仅水平方向移动**（X轴移动） 主要目的实现移动效果 translateY(y)仅垂直方向移动（Y轴移动） translateZ(z)transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。 translate3d(x,y,z)[注意]其中，x和y可以是长度值，也可以是百分比，百分比是相对于其本身元素水平方向的宽度和垂直方向的高度和；z只能设置长度值 开门案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061body &#123;&#125;.door &#123; width: 300px; height: 300px; margin: 100px auto; border: 1px solid gray; perspective: 1000px; background: url('images/dog.gif') no-repeat cover; position: relative;&#125;.door &gt; div &#123; box-sizing: border-box; border: 1px solid black;&#125;.left &#123; float: left; width: 50%; height: 100%; background-color: brown; transform-origin: left center; transition: 1s; position: relative;&#125;.left::before &#123; content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; right: 0px; transform: translateY(-10px); border: 1px solid whitesmoke;&#125;.right &#123; width: 50%; height: 100%; float: left; background-color: brown; transform-origin: right center; transition: 1s; position: relative;&#125;.right::before &#123; content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; left: 0px; transform: translateY(-10px); border: 1px solid whitesmoke;&#125;.door:hover .left &#123; transform: rotateY(-130deg);&#125;.door:hover .right &#123; transform: rotateY(130deg);&#125; backface-visibilitybackface-visibility 属性定义当元素不面向屏幕时是否可见。 翻转盒子案例12345678910111213141516171819div &#123;truetruetruewidth: 224px;truetruetrueheight: 224px;truetruetruemargin: 100px auto;truetruetrueposition: relative;truetrue&#125;truetruediv img &#123;truetruetrueposition: absolute;truetruetruetop: 0;truetruetrueleft: 0;truetruetruetransition: all 1s; truetrue&#125;truetruediv img:first-child &#123;truetruetruez-index: 1;truetruetruebackface-visibility: hidden; /* 不是正面对象屏幕，就隐藏 */truetrue&#125;truetruediv:hover img &#123;truetruetruetransform: rotateY(180deg);&#125; 动画(CSS3) animation动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 语法格式： 1animation:动画名称 动画时间 运动曲线 何时开始 播放次数 是否反方向; 关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意r 1234@keyframes 动画名称 &#123; from&#123; 开始位置 &#125; 0% to&#123; 结束 &#125; 100%&#125; 12animation-iteration-count:infinite; 无限循环播放animation-play-state:paused; 暂停动画&quot; 小汽车案例123456789101112131415161718192021222324252627body &#123; background: white;&#125;img &#123; width: 200px;&#125;.animation &#123; animation-name: goback; animation-duration: 5s; animation-timing-function: ease; animation-iteration-count: infinite;&#125;@keyframes goback &#123; 0%&#123;&#125; 49%&#123; transform: translateX(1000px); &#125; 55%&#123; transform: translateX(1000px) rotateY(180deg); &#125; 95%&#123; transform: translateX(0) rotateY(180deg); &#125; 100%&#123; transform: translateX(0) rotateY(0deg); &#125;&#125; 伸缩布局(CSS3)CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。 主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向 侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的 方向：默认主轴从左向右，侧轴默认从上到下 主轴和侧轴并不是固定不变的，通过flex-direction可以互换。 Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多 2、各属性详解** 1.flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配 min-width 最小值 min-width: 280px 最小宽度 不能小于 280 max-width: 1280px 最大宽度 不能大于 1280 2.flex-direction调整主轴方向（默认为水平方向） flex-direction: column 垂直排列 flex-direction: row 水平排列 http://m.ctrip.com/html5/ 携程网手机端地址 3、justify-content调整主轴对齐（水平对齐） 子盒子如何在父盒子里面水平对齐 值 描述 白话文 flex-start 默认值。项目位于容器的开头。 让子元素从父容器的开头开始排序但是盒子顺序不变 flex-end 项目位于容器的结尾。 让子元素从父容器的后面开始排序但是盒子顺序不变 center 项目位于容器的中心。 让子元素在父容器中间显示 space-between 项目位于各行之间留有空白的容器内。 左右的盒子贴近父盒子，中间的平均分布空白间距 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 相当于给每个盒子添加了左右margin外边距 4、align-items调整侧轴对齐（垂直对齐） 子盒子如何在父盒子里面垂直对齐（单行） 值 描述 白话文 stretch 默认值。项目被拉伸以适应容器。 让子元素的高度拉伸适用父容器（子元素不给高度的前提下) center 项目位于容器的中心。 垂直居中 flex-start 项目位于容器的开头。 垂直对齐开始位置 上对齐 flex-end 项目位于容器的结尾。 垂直对齐结束位置 底对齐 5、flex-wrap控制是否换行 当我们子盒子内容宽度多于父盒子的时候如何处理 值 描述 nowrap 默认值。规定灵活的项目不拆行或不拆列。 不换行，则 收缩（压缩） 显示 强制一行内显示 wrap 规定灵活的项目在必要的时候拆行或拆列。 wrap-reverse 规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。 6、flex-flow是flex-direction、flex-wrap的简写形式 1flex-flow: flex-direction flex-wrap; 白话记： flex-flow: 排列方向 换不换行; 两个中间用空格 例如： 1234display: flex;/* flex-direction: row;flex-wrap: wrap; 这两句话等价于下面的这句话*/flex-flow: column wrap; /* 两者的综合 */ 7、align-content堆栈（由flex-wrap产生的独立行）多行垂直对齐方式齐 align-content是针对flex容器里面多轴(多行)的情况,align-items是针对一行的情况进行排列。 必须对父元素设置自由盒属性display:flex;，并且设置排列方式为横向排列flex-direction:row;并且设置换行，flex-wrap:wrap;这样这个属性的设置才会起作用。 值 描述 测试 stretch 默认值。项目被拉伸以适应容器。 center 项目位于容器的中心。 flex-start 项目位于容器的开头。 flex-end 项目位于容器的结尾。 space-between 项目位于各行之间留有空白的容器内。 space-around 项目位于各行之前、之间、之后都留有空白的容器内。 8、order控制子项目的排列顺序，正序方式排序，从小到大 用css 来控制盒子的前后顺序。 用order 就可以 用整数值来定义排列顺序，数值小的排在前面。可以为负值。 默认值是 0 1order: 1; 此知识点重在理解，要明确找出主轴、侧轴、方向，各属性对应的属性值]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Css2]]></title>
    <url>%2F2017%2F08%2F07%2F02-CSS%2F</url>
    <content type="text"><![CDATA[课程目标: 学会使用CSS选择器 熟记CSS样式和外观属性 熟练掌握CSS各种选择器 熟练掌握CSS各种选择器 熟练掌握CSS三种显示模式 熟练掌握CSS背景属性 熟练掌握CSS三大特性 熟练掌握CSS盒子模型 熟练掌握CSS浮动10.熟练掌握CSS定位11.熟练掌握CSS高级技巧强化CSStypora-copy-images-to: media CSS的发展历程从HTML被发明开始，样式就以各种形式存在。不同的浏览器结合它们各自的样式语言为用户提供页面效果的控制。最初的HTML只包含很少的显示属性。随着HTML的成长，为了满足页面设计者的要求，HTML添加了很多显示功能。但是随着这些功能的增加，HTML变的越来越杂乱，而且HTML页面也越来越臃肿。于是CSS便诞生了。 CSS 网页的美容师CSS的出现，拯救了混乱的HTML，当让更加拯救了我们web开发者。 让我们的网页更加丰富多彩。 CSS的最大贡献就是： 让 HTML 从样式中解脱苦海， 实现了 HTML 专注去做 结构呈现。 而样式交给 CSS 后，你完全可以放心的早点洗洗睡了！ 而且。。。。。 CSS 做的很出色，如果JavaScript是网页的魔法师，那么CSS它是我们网页的美容师，不信，你看: ps: 你跟Angelababy只差了一个妆容的距离 来个更直观的认识吧： 有人说， 没有不漂亮的女人，只有不会打扮的女人。 我想说， 没有不好看的网页，只有不会CSS的前端。 网页添加 CSS和不添加CSS 的对比： 带有CSS的页面 没有CSS的页面 CSS初识CSS(Cascading Style Sheets) CSS通常称为CSS样式表或层叠样式表（级联样式表），主要用于设置HTML页面中的文本内容（字体、大小、对齐方式等）、图片的外形（宽高、边框样式、边距等）以及版面的布局等外观显示样式。 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式。 CSS样式规则使用HTML时，需要遵从一定的规范。CSS亦如此，要想熟练地使用CSS对网页进行修饰，首先需要了解CSS样式规则，具体格式如下： 12345678在上面的样式规则中:1.选择器用于指定CSS样式作用的HTML对象，花括号内是对该对象设置的具体样式。2.属性和属性值以“键值对”的形式出现。3.属性是对指定的对象设置的样式属性，例如字体大小、文本颜色等。4.属性和属性值之间用英文“:”连接。5.多个“键值对”之间用英文“;”进行区分。可以用段落 和 表格的对齐的演示。 CSS字体样式属性font-size:字号大小font-size属性用于设置字号，该属性的值可以使用相对长度单位，也可以使用绝对长度单位。其中，相对长度单位比较常用，推荐使用像素单位px，绝对长度单位使用较少。具体如下： font-family:字体font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，例如将网页中所有段落文本的字体设置为微软雅黑，可以使用如下CSS样式代码： p{ font-family:”微软雅黑”;} 可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。 常用技巧： 1234561. 现在网页中普遍使用14px+。2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。3. 各种字体之间必须使用英文状态下的逗号隔开。4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。 CSS Unicode字体在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。 方案一： 你可以使用英文来替代。 比如 font-family:”Microsoft Yahei”。 方案二： 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。font-family: “\5FAE\8F6F\96C5\9ED1”，表示设置字体为“微软雅黑”。 可以通过escape() 来测试属于什么字体。 字体名称 英文名称 Unicode 编码 宋体 SimSun \5B8B\4F53 新宋体 NSimSun \65B0\5B8B\4F53 黑体 SimHei \9ED1\4F53 微软雅黑 Microsoft YaHei \5FAE\8F6F\96C5\9ED1 楷体_GB2312 KaiTi_GB2312 \6977\4F53_GB2312 隶书 LiSu \96B6\4E66 幼园 YouYuan \5E7C\5706 华文细黑 STXihei \534E\6587\7EC6\9ED1 细明体 MingLiU \7EC6\660E\4F53 新细明体 PMingLiU \65B0\7EC6\660E\4F53 为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体 font-weight:字体粗细字体加粗除了用 b 和 strong 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 1font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。 小技巧： 1数字 400 等价于 normal，而 700 等价于 bold。 但是我们更喜欢用数字来表示。 font-style:字体风格字体倾斜除了用 i 和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。 font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下： normal：默认值，浏览器会显示标准的字体样式。 italic：浏览器会显示斜体的字体样式。 oblique：浏览器会显示倾斜的字体样式。 小技巧： 1平时我们很少给文字加斜体，反而喜欢给斜体标签（em，i）改为普通模式。 font:综合设置字体样式 (重点)font属性用于对字体样式进行综合设置，其基本语法格式如下： 1选择器&#123;font: font-style font-weight font-size/line-height font-family;&#125; 123使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。 开发者工具（chrome）此工具是我们的必备工具，以后代码出了问题，我们首先第一反应就是： “按F12”或者是 “shift+ctrl+i” 打开 开发者工具。 菜单： 右击网页空白出—查看 小技巧： ctrl+滚轮 可以 放大开发者工具代码大小。 左边是HTML元素结构 右边是CSS样式。 右边CSS样式可以改动数值和颜色查看更改后效果。 选择器（重点）要想将CSS样式应用于特定的HTML元素，首先需要找到该目标元素。在CSS中，执行这一任务的样式规则部分被称为选择器（选择符）。 如上图所以，要把里面的小黄人分为2组，最快的方法怎办？ 很多， 比如 一只眼睛的一组，剩下的一组 这就用到基础选择器组： 标签选择器（元素选择器）标签选择器是指用HTML标签名称作为选择器，按标签名称分类，为页面中某一类标签指定统一的CSS样式。其基本语法格式如下： 12标签名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 或者元素名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 标签选择器最大的优点是能快速为页面中同类型的标签统一样式，同时这也是他的缺点，不能设计差异化样式。 课堂案例： 传智简介 类选择器类选择器使用“.”（英文点号）进行标识，后面紧跟类名，其基本语法格式如下： 1.类名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 1标签调用的时候用 class=“类名” 即可。 类选择器最大的优势是可以为元素对象定义单独或相同的样式。 小技巧： 121.长名称或词组可以使用中横线来为选择器命名。2.不建议使用“_”下划线来命名CSS选择器。 ​ 输入的时候少按一个shift键; 浏览器兼容问题 (比如使用tips的选择器命名，在IE6是无效的) 能良好区分JavaScript变量命名(JS变量命名是用“”) 13.不要纯数字、中文等命名， 尽量使用英文字母来表示。 猜谜底游戏： 你猜？ 命名规范： 见附件（Web前端开发规范手册.doc） 命名是我们通俗约定的，但是没有规定必须用这些常用的命名。 课堂案例： 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; span &#123; font-size: 100px; &#125; .blue &#123; color: blue; &#125; .red &#123; color: red; &#125; .orange &#123; color: orange; &#125; .green &#123; color: green; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;span class="blue"&gt;G&lt;/span&gt; &lt;span class="red"&gt;o&lt;/span&gt; &lt;span class="orange"&gt;o&lt;/span&gt; &lt;span class="blue"&gt;g&lt;/span&gt; &lt;span class="green"&gt;l&lt;/span&gt; &lt;span class="red"&gt;e&lt;/span&gt; &lt;/body&gt; 多类名选择器我们可以给标签指定多个类名，从而达到更多的选择目的。 注意： 121. 样式显示效果跟HTML元素中的类名先后顺序没有关系,受CSS样式书写的上下顺序有关。2. 各个类名中间用空格隔开。 多类名选择器在后期布局比较复杂的情况下，还是较多使用的。 1234&lt;div class="pink fontWeight font20"&gt;亚瑟&lt;/div&gt;&lt;div class="font20"&gt;刘备&lt;/div&gt;&lt;div class="font14 pink"&gt;安其拉&lt;/div&gt;&lt;div class="font14"&gt;貂蝉&lt;/div&gt; id选择器id选择器使用“#”进行标识，后面紧跟id名，其基本语法格式如下： 1#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 该语法中，id名即为HTML元素的id属性值，大多数HTML元素都可以定义id属性，元素的id值是唯一的，只能对应于文档中某一个具体的元素。 用法基本和类选择器相同。 id选择器和类选择器区别W3C标准规定，在同一个页面内，不允许有相同名字的id对象出现，但是允许相同名字的class。 类选择器（class） 好比人的名字， 是可以多次重复使用的， 比如 张伟 王伟 李伟 李娜 id选择器 好比人的身份证号码， 全中国是唯一的， 不得重复。 只能使用一次。 id选择器和类选择器最大的不同在于 使用次数上。 通配符选择器通配符选择器用“*”号表示，他是所有选择器中作用范围最广的，能匹配页面中所有的元素。其基本语法格式如下： 1* &#123; 属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125; 例如下面的代码，使用通配符选择器定义CSS样式，清除所有HTML标记的默认边距。 1234* &#123; margin: 0; /* 定义外边距*/ padding: 0; /* 定义内边距*/&#125; 注意： 这个通配符选择器，就像我们的电影明星中的梦中情人， 想想它就好了，但是它不会和你过日子。 伪类选择器 伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。 1为了和我们刚才学的类选择器相区别， 类选择器是一个点 比如 .demo &#123;&#125; 而我们的伪类 用 2个点 就是 冒号 比如 :link&#123;&#125; 链接伪类选择器 :link / 未访问的链接 / :visited / 已访问的链接 / :hover / 鼠标移动到链接上 / :active / 选定的链接 / 注意写的时候，他们的顺序尽量不要颠倒 按照 lvha 的顺序。 love hate 爱上了讨厌 记忆法 或者 lv 包包 非常 hao 12345678a &#123; /* a是标签选择器 所有的链接 */truetruetruefont-weight: 700;truetruetruefont-size: 16px;truetruetruecolor: gray;truetrue&#125;a:hover &#123; /* :hover 是链接伪类选择器 鼠标经过 */truetruetruecolor: red; /* 鼠标经过的时候，由原来的 灰色 变成了红色 */&#125; 结构(位置)伪类选择器（CSS3) :first-child :选取属于其父元素的首个子元素的指定选择器 :last-child :选取属于其父元素的最后一个子元素的指定选择器 :nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型 :nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。n 可以是数字、关键词或公式 ​ 123456789li:first-child &#123; /* 选择第一个孩子 */ color: pink; &#125;li:last-child &#123; /* 最后一个孩子 */ color: purple; &#125;li:nth-child(4) &#123; /* 选择第4个孩子 n 代表 第几个的意思 */ truetruetruetruecolor: skyblue; &#125; 目标伪类选择器(CSS3) :target目标伪类选择器 :选择器可用于选取当前活动的目标元素 1234:target &#123;truetruecolor: red;truetruefont-size: 30px;&#125; CSS注释1CSS规则是使用 /* 需要注释的内容 */ 进行注释的，即在需要注释的内容前使用 “/*” 标记开始注释，在内容的结尾使用 “*/”结束。 例如： 123p &#123; font-size: 14px; /* 所有的字体是14像素大小*/&#125; CSS外观属性color:文本颜色color属性用于定义文本的颜色，其取值方式有如下3种： 1.预定义的颜色值，如red，green，blue等。 2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。 3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。 需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。 line-height:行间距ine-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%，实际工作中使用最多的是像素px 一般情况下，行距比字号大7.8像素左右就可以了。 text-align:水平对齐方式1text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下： left：左对齐（默认值） right：右对齐 center：居中对齐 text-indent:首行缩进text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。 1em 就是一个字的宽度 如果是汉字的段落， 1em 就是一个汉字的宽度 letter-spacing:字间距letter-spacing属性用于定义字间距，所谓字间距就是字符与字符之间的空白。其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing:单词间距word-spacing属性用于定义英文单词之间的间距，对中文字符无效。和letter-spacing一样，其属性值可为不同单位的数值，允许使用负值，默认为normal。 word-spacing和letter-spacing均可对英文进行设置。不同的是letter-spacing定义的为字母之间的间距，而word-spacing定义的为英文单词之间的间距。 颜色半透明(css3)文字颜色到了CSS3我们可以采取半透明的格式了语法格式如下： 1color: rgba(r,g,b,a) a 是alpha 透明的意思 取值范围 0~1之间 color: rgba(0,0,0,0.3) 文字阴影(CSS3)以后我们可以给我们的文字添加阴影效果了 Shadow 影子 1text-shadow:水平位置 垂直位置 模糊距离 阴影颜色; 前两项是必须写的。 后两项可以选写。 sublime快捷方式sublime可以快速提高我们代码的书写方式 生成标签 直接输入标签名 按tab键即可 比如 div 然后tab 键， 就可以生成 如果想要生成多个相同标签 加上 就可以了 比如 div3 就可以快速生成3个div 如果有父子级关系的标签，可以用 &gt; 比如 ul &gt; li就可以了 如果有兄弟关系的标签，用 + 就可以了 比如 div+p 如果生成带有类名或者id名字的， 直接写 .demo 或者 #two tab 键就可以了 ​ 引入CSS样式表（书写位置）CSS可以写到那个位置？ 是不是一定写到html文件里面呢？ 内部样式表内嵌式是将CSS代码集中写在HTML文档的head头部标签中，并且用style标签定义，其基本语法格式如下： 12345&lt;head&gt;&lt;style type="text/CSS"&gt; 选择器 &#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3;&#125;&lt;/style&gt;&lt;/head&gt; 语法中，style标签一般位于head标签中title标签之后，也可以把他放在HTML文档的任何地方。 type=”text/CSS” 在html5中可以省略， 写上也比较符合规范， 所以这个地方可以写也可以省略。 行内式（内联样式）内联样式，又有人称行内样式、行间样式、内嵌样式。是通过标签的style属性来设置元素的样式，其基本语法格式如下： 1&lt;标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"&gt; 内容 &lt;/标签名&gt; 语法中style是标签的属性，实际上任何HTML标签都拥有style属性，用来设置行内式。其中属性和值的书写规范与CSS样式规则相同，行内式只对其所在的标签及嵌套在其中的子标签起作用。 外部样式表（外链式）链入式是将所有的样式放在一个或多个以.CSS为扩展名的外部样式表文件中，通过link标签将外部样式表文件链接到HTML文档中，其基本语法格式如下： 123&lt;head&gt; &lt;link href="CSS文件的路径" type="text/CSS" rel="stylesheet" /&gt;&lt;/head&gt; 注意： link 是个单标签哦!!! 该语法中，link标签需要放在head头部标签中，并且必须指定link标签的三个属性，具体如下： 123href：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径。type：定义所链接文档的类型，在这里需要指定为“text/CSS”，表示链接的外部文件为CSS样式表。rel：定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。 三种样式表总结 样式表 优点 缺点 使用情况 控制范围 行内样式表 书写方便，权重高 没有实现样式和结构相分离 较少 控制一个标签（少） 内部样式表 部分结构和样式相分离 没有彻底分离 较多 控制一个页面（中） 外部样式表 完全实现结构和样式相分离 需要引入 最多，强烈推荐 控制整个站点（多） 标签显示模式（display） 非洲黑人： 皮肤内黑色素含量高，以吸收阳光中的紫外线，保护皮肤内部结构免遭损害，头发象羊毛一样卷曲，使每根卷发周围都有许多空隙，空隙充满空气，卷发有隔热作用。 欧洲白人： 生活寒带或着是说常年温度较低的地缘,加上年日照时间少，身体的黑色素沉淀比较少所以出现皮肤、发色、瞳晕都呈现浅色 传智黄人： 我中间的。。。 最重要的总结： 是为了更好的适应环境而完成的自然选择。 同理，我们网页的标签非常多，再不同地方会用到不同类型的标签，以便更好的完成我们的网页。 标签的类型(显示模式) HTML标签一般分为块标签和行内标签两种类型，它们也称块元素和行内元素。具体如下： 块级元素(block-level)每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 1常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。 块级元素的特点： （1）总是从新行开始 （2）高度，行高、外边距以及内边距都可以控制。 （3）宽度默认是容器的100% （4）可以容纳内联元素和其他块元素。 行内元素(inline-level)行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。 1常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。 我一样重要 行内元素的特点： （1）和相邻行内元素在一行上。 （2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。 （3）默认宽度就是它本身内容的宽度。 （4）行内元素只能容纳文本或则其他行内元素。（a特殊） 注意： 只有 文字才 能组成段落 因此 p 里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。 链接里面不能再放链接。 块级元素和行内元素区别12345块级元素的特点：（1）总是从新行开始（2）高度，行高、外边距以及内边距都可以控制。（3）宽度默认是容器的100%（4）可以容纳内联元素和其他块元素。 12345行内元素的特点：（1）和相邻行内元素在一行上。（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。（3）默认宽度就是它本身内容的宽度。（4）行内元素只能容纳文本或则其他行内元素。 行内块元素（inline-block）123456在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。行内块元素的特点：（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。（2）默认宽度就是它本身内容的宽度。（3）高度，行高、外边距以及内边距都可以控制。 标签显示模式转换 display块转行内：display:inline; 行内转块：display:block; 块、行内元素转换为行内块： display: inline-block; 此阶段，我们只需关心这三个，其他的是我们后面的工作。 CSS复合选择器复合选择器是由两个或多个基础选择器，通过不同的方式组合而成的,目的是为了可以选择更准确更精细的目标元素标签。 交集选择器交集选择器由两个选择器构成，其中第一个为标签选择器，第二个为class选择器，两个选择器之间不能有空格，如h3.special。 记忆技巧： 交集选择器 是 并且的意思。 即…又…的意思 1比如： p.one 选择的是： 类名为 .one 的 段落标签。 用的相对来说比较少，不太建议使用。 并集选择器并集选择器（CSS选择器分组）是各个选择器通过逗号连接而成的，任何形式的选择器（包括标签选择器、class类选择器id选择器等），都可以作为并集选择器的一部分。如果某些选择器定义的样式完全相同，或部分相同，就可以利用并集选择器为它们定义相同的CSS样式。 记忆技巧： 并集选择器 和 的意思， 就是说，只要逗号隔开的，所有选择器都会执行后面样式。 1比如 .one, p , #test &#123;color: #F00;&#125; 表示 .one 和 p 和 #test 这三个选择器都会执行颜色为红色。 通常用于集体声明。 他和他，在一起， 在一起 一起的意思 后代选择器后代选择器又称为包含选择器，用来选择元素或元素组的后代，其写法就是把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。 子孙后代都可以这么选择。 或者说，它能选择任何包含在内 的标签。 子元素选择器子元素选择器只能选择作为某元素子元素的元素。其写法就是把父级标签写在前面，子级标签写在后面，中间跟一个 &gt; 进行连接，注意，符号左右两侧各保留一个空格。 白话： 这里的子 指的是 亲儿子 不包含孙子 重孙子之类。 1比如： .demo &gt; h3 &#123;color: red;&#125; 说明 h3 一定是demo 亲儿子。 demo 元素包含着h3。 测试题123456789101112131415161718&lt;div class="nav"&gt; &lt;!-- 主导航栏 --&gt; &lt;ul&gt; &lt;li&gt;&lt;a href="#"&gt;公司首页&lt;/a&gt;&lt;/li&gt;true&lt;li&gt;&lt;a href="#"&gt;公司简介&lt;/a&gt;&lt;/li&gt;true&lt;li&gt;&lt;a href="#"&gt;公司产品&lt;/a&gt;&lt;/li&gt;true&lt;li&gt; &lt;a href="#"&gt;联系我们&lt;/a&gt;truetrue &lt;ul&gt;truetrue &lt;li&gt;&lt;a href="#"&gt;公司邮箱&lt;/a&gt;&lt;/li&gt;truetrue &lt;li&gt;&lt;a href="#"&gt;公司电话&lt;/a&gt;&lt;/li&gt;truetrue &lt;/ul&gt;true&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class="sitenav"&gt; &lt;!-- 侧导航栏 --&gt; &lt;div class="site-l"&gt;左侧侧导航栏&lt;/div&gt; &lt;div class="site-r"&gt;&lt;a href="#"&gt;登录&lt;/a&gt;&lt;/div&gt;&lt;/div&gt; 在不修改以上代码的前提下，完成以下任务： 链接 登录 的颜色为红色,同时主导航栏里面的所有的链接改为蓝色 (简单) 主导航栏和侧导航栏里面文字都是14像素并且是微软雅黑。（中等) 主导航栏里面的一级菜单链接文字颜色为绿色。（难) ​ 属性选择器选取标签带有某些特殊属性的选择器 我们成为属性选择器 12345678910/* 获取到 拥有 该属性的元素 */div[class^=font] &#123; /* class^=font 表示 font 开始位置就行了 */truetruetruecolor: pink;truetrue&#125;div[class$=footer] &#123; /* class$=footer 表示 footer 结束位置就行了 */truetruetruecolor: skyblue;truetrue&#125;div[class*=tao] &#123; /* class*=tao *= 表示tao 在任意位置都可以 */truetruetruecolor: green;truetrue&#125; 1234567891011&lt;div class="font12"&gt;属性选择器&lt;/div&gt; &lt;div class="font12"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="font24"&gt;属性选择器&lt;/div&gt; &lt;div class="24font"&gt;属性选择器123&lt;/div&gt; &lt;div class="sub-footer"&gt;属性选择器footer&lt;/div&gt; &lt;div class="jd-footer"&gt;属性选择器footer&lt;/div&gt; &lt;div class="news-tao-nav"&gt;属性选择器&lt;/div&gt; &lt;div class="news-tao-header"&gt;属性选择器&lt;/div&gt; &lt;div class="tao-header"&gt;属性选择器&lt;/div&gt; 伪元素选择器（CSS3) E::first-letter文本的第一个单词或字（如中文、日文、韩文等） E::first-line 文本第一行； E::selection 可改变选中文本的样式； 1234567891011121314p::first-letter &#123; font-size: 20px; color: hotpink;&#125;/* 首行特殊样式 */p::first-line &#123; color: skyblue;&#125;p::selection &#123; /* font-size: 50px; */ color: orange;&#125; 4、E::before和E::after 在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。 123456div::befor &#123; content:"开始";&#125;div::after &#123; content:"结束";&#125; E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。 E:after、E:before后面的练习中会反复用到，目前只需要有个大致了解 “:” 与 “::” 区别在于区分伪类和伪元素 CSS书写规范开始就形成良好的书写规范，是你专业化的开始。 空格规范【强制】 选择器 与 { 之间必须包含空格。 示例： .selector { } 【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。 示例： font-size: 12px; 选择器规范【强制】 当一个 rule 包含多个 selector 时，每个选择器声明必须独占一行。 示例： 123456789101112/* good */.post,.page,.comment &#123; line-height: 1.5;&#125;/* bad */.post, .page, .comment &#123; line-height: 1.5;&#125; 【建议】 选择器的嵌套层级应不大于 3 级，位置靠后的限定条件应尽可能精确。 示例： 1234567/* good */#username input &#123;&#125;.comment .avatar &#123;&#125;/* bad */.page .header .login #username input &#123;&#125;.comment div * &#123;&#125; 属性规范【强制】 属性定义必须另起一行。 示例： 12345678/* good */.selector &#123; margin: 0; padding: 0;&#125;/* bad */.selector &#123; margin: 0; padding: 0; &#125; 【强制】 属性定义后必须以分号结尾。 示例： 123456789/* good */.selector &#123; margin: 0;&#125;/* bad */.selector &#123; margin: 0&#125; CSS 背景(background)CSS 可以添加背景颜色和背景图片，以及来进行图片设置。 background-color 背景颜色 background-image 背景图片地址 background-repeat 是否平铺 background-position 背景位置 background-attachment 背景固定还是滚动 背景的合写（复合属性） background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 背景图片(image)语法： 1background-image : none | url (url) 参数： none : 无背景图（默认的）url : 使用绝对或相对地址指定背景图像 background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。 小技巧： 我们提倡 背景图片后面的地址，url不要加引号。 背景平铺（repeat）语法： 1background-repeat : repeat | no-repeat | repeat-x | repeat-y 参数： repeat : 背景图像在纵向和横向上平铺（默认的） no-repeat : 背景图像不平铺 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 repeat-x : 背景图像在横向上平铺 repeat-y : 背景图像在纵向平铺 设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。 背景位置(position)语法： 123background-position : length || lengthbackground-position : position || position 参数： length : 百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位position : top | center | bottom | left | center | right 说明： 设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。 注意： position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。 如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top; 则 15px 一定是 x坐标 top是 y坐标。 实际工作用的最多的，就是背景图片居中对齐了。 背景附着语法： 1background-attachment : scroll | fixed 参数： scroll : 背景图像是随对象内容滚动fixed : 背景图像固定 说明： 设置或检索背景图像是随对象内容滚动还是固定的。 背景简写background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写： background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置 1background: transparent url(image.jpg) repeat-y scroll 50% 0 ; 背景透明(CSS3)CSS3支持背景半透明的写法语法格式是: 1background: rgba(0,0,0,0.3); 最后一个参数是alpha 透明度 取值范围 0~1之间 注意： 背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。 背景缩放(CSS3)通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。 其参数设置如下： a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高） b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多 c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。 1234background-image: url('images/gyt.jpg');truetruetruebackground-size: 300px 100px;truetruetrue/* background-size: contain; */truetruetrue/* background-size: cover; */ 多背景(CSS3)以逗号分隔可以设置多背景，可用于自适应布局 做法就是 用逗号隔开就好了。 一个元素可以设置多重背景图像。 每组属性间使用逗号分隔。 如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。 为了避免背景色将图像盖住，背景色通常都定义在最后一组上， 123background:url(test1.jpg) no-repeat scroll 10px 20px/50px 60px ,true url(test1.jpg) no-repeat scroll 10px 20px/70px 90px ,true url(test1.jpg) no-repeat scroll 10px 20px/110px 130px c #aaa; ​ 凹凸文字12345678910111213141516171819202122232425&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; body &#123; background-color: #ccc; &#125;truetruediv &#123;truetruetruecolor: #ccc;truetruetruefont: 700 80px "微软雅黑";truetrue&#125;truetruediv:first-child &#123;truetruetrue/* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */truetruetruetext-shadow: 1px 1px 1px #000, -1px -1px 1px #fff;truetrue&#125;truetruediv:last-child &#123;truetruetrue/* text-shadow: 水平位置 垂直位置 模糊距离 阴影颜色; */truetruetruetext-shadow: -1px -1px 1px #000, 1px 1px 1px #fff;truetrue&#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;我是凸起的文字&lt;/div&gt; &lt;div&gt;我是凹下的文字&lt;/div&gt; &lt;/body&gt; 导航栏案例文本的装饰text-decoration 通常我们用于给链接修改装饰效果 值 描述 none 默认。定义标准的文本。 underline 定义文本下的一条线。下划线 也是我们链接自带的 overline 定义文本上的一条线。 line-through 定义穿过文本下的一条线。 使用技巧：在一行内的盒子内，我们设定行高等于盒子的高度，就可以使文字垂直居中。 12345678910111213141516171819202122232425262728&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;style&gt; body &#123; background-color: #000; &#125; a &#123; width: 200px; height: 50px; /* background-color: orange; */ display: inline-block; /* 把a 行内元素转换为行内块元素 */ text-align: center; /* 文字水平居中 */ line-height: 50px; /* 我们设定行高等于盒子的高度，就可以使文字垂直居中 */ color: #fff; font-size: 22px; text-decoration: none; /* 取消下划线 文本装饰 */ &#125; a:hover &#123; /* 鼠标经过 给我们的链接添加背景图片*/ background: url(images/h.png) no-repeat; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;a href="#"&gt;专区说明&lt;/a&gt; &lt;a href="#"&gt;申请资格&lt;/a&gt; &lt;a href="#"&gt;兑换奖励&lt;/a&gt; &lt;a href="#"&gt;下载游戏&lt;/a&gt; &lt;/body&gt; CSS 三大特性层叠 继承 优先级 是我们学习CSS 必须掌握的三个特性。 CSS层叠性所谓层叠性是指多种CSS样式的叠加。 是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉 比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。 一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。 样式不冲突，不会层叠 1CSS最后的执行口诀： 长江后浪推前浪，前浪死在沙滩上。 CSS继承性所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。 简单的理解就是： 子承父业。 1CSS最后的执行口诀： 龙生龙，凤生凤，老鼠生的孩子会打洞。 注意： 1恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性） CSS优先级定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。 在考虑权重时，初学者还需要注意一些特殊的情况，具体如下： 1234567继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。 CSS特殊性（Specificity）关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下： specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。 继承或者* 的贡献值 0,0,0,0 每个元素（标签）贡献值为 0,0,0,1 每个类，伪类贡献值为 0,0,1,0 每个ID贡献值为 0,1,0,0 每个行内样式贡献值 1,0,0,0 每个!important贡献值 ∞ 无穷大 权重是可以叠加的 比如的例子： 123456789div ul li ------&gt; 0,0,0,3.nav ul li ------&gt; 0,0,1,2a:hover -----—&gt; 0,0,1,1.nav a ------&gt; 0,0,1,1 #nav p -----&gt; 0,1,0,1 ​ ​ 注意： 1.数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。 继承的 权重是 0 总结优先级： 使用了 !important声明的规则。 内嵌在 HTML 元素的 style属性里面的声明。 使用了 ID 选择器的规则。 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。 使用了元素选择器的规则。 只包含一个通用选择器的规则。 同一类选择器则遵循就近原则。 1总结：权重是优先级的算法，层叠是优先级的表现 盒子模型（CSS重点）其实，CSS就三个大模块： 盒子模型 、 浮动 、 定位，其余的都是细节。要求这三部分，无论如何也要学的非常精通。 所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。 看透网页布局的本质网页布局中，我们是如何把里面的文字，图片，按照美工给我们的效果图排列的整齐有序呢？ 牛奶是怎样运输，让消费者购买的呢？ 我们说过，行内元素比如 文字 类似牛奶，也需要一个盒子把他们装起来，我们前面学过的双标签都是一个盒子。有了盒子，我们就可以随意的，自由的，摆放位置了。 看透网页布局的本质： 把网页元素比如文字图片等等，放入盒子里面，然后利用CSS摆放盒子的过程，就是网页布局。 CSS 其实没有太多逻辑可言 ， 类似我们小时候玩的积木,我们可以自由的，随意的摆放出我们想要的效果。 盒子模型（Box Model）这里略过 老旧的ie盒子模型（IE6以下），对不起，我都没见过IE5的浏览器。 。首先，我们来看一张图，来体会下什么是盒子模型。 所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素再网页布局汇总所占的位置大小。因此，每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。 盒子边框（border）边框就是那层皮。 橘子皮。。柚子皮。。橙子皮。。。 语法： 1border : border-width || border-style || border-color 边框属性—设置边框样式（border-style） 边框样式用于定义页面中边框的风格，常用属性值如下： 123456789none：没有边框即忽略所有边框的宽度（默认值）solid：边框为单实线(最为常用的)dashed：边框为虚线 dotted：边框为点线double：边框为双实线 盒子边框写法总结表 设置内容 样式属性 常用属性值 上边框 border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色; 下边框 border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色; 左边框 border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色; 右边框 border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色; 样式综合设置 border-style:上边 [右边 下边 左边]; none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线 宽度综合设置 border-width:上边 [右边 下边 左边]; 像素值 颜色综合设置 border-color:上边 [右边 下边 左边]; 颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%) 边框综合设置 border:四边宽度 四边样式 四边颜色; 表格的细线边框以前学过的html表格边框很粗，这里只需要CSS一句话就可以美观起来。 让我们真的相信，CSS就是我们的白马王子（白雪公主）。 table{ border-collapse:collapse; } collapse 单词是合并的意思 border-collapse:collapse; 表示边框合并在一起。 圆角边框(CSS3)从此以后，我们的世界不只有矩形。radius 半径（距离） 语法格式： 1border-radius: 左上角 右上角 右下角 左下角; 课堂案例: 123456789101112131415161718192021222324252627282930313233&lt;style&gt; div &#123; width: 200px; height: 200px; border: 1px solid red; &#125; div:first-child &#123; /* 结构伪类选择器 选亲兄弟 */ border-radius: 10px; /* 一个数值表示4个角都是相同的 10px 的弧度 */ &#125; div:nth-child(2) &#123; /*border-radius: 100px; 取宽度和高度 一半 则会变成一个圆形 */ border-radius: 50%; /* 100px 50% 取宽度和高度 一半 则会变成一个圆形 */ &#125; div:nth-child(3) &#123; border-radius: 10px 40px; /* 左上角 和 右下角 是 10px 右上角 左下角 40 对角线 */ &#125; div:nth-child(4) &#123; border-radius: 10px 40px 80px; /* 左上角 10 右上角 左下角 40 右下角80 */ &#125; div:nth-child(5) &#123; border-radius: 10px 40px 80px 100px; /* 左上角 10 右上角 40 右下角 80 左下角 右下角100 */ &#125; div:nth-child(6) &#123; border-radius: 100px; height: 100px; &#125; div:nth-child(7) &#123; border-radius: 100px 0; &#125; &lt;/style&gt; 内边距（padding）padding属性用于设置内边距。 是指 边框与内容之间的距离。 padding-top:上内边距 padding-right:右内边距 padding-bottom:下内边距 padding-left:左内边距 注意： 后面跟几个数值表示的意思是不一样的。 值的个数 表达意思 1个值 padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素 2个值 padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素 3个值 padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素 4个值 padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针 课堂案例： 新浪导航 外边距（margin）margin属性用于设置外边距。 设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。 margin-top:上外边距 margin-right:右外边距 margin-bottom:下外边距 margin-left:上外边距 margin:上外边距 右外边距 下外边距 左外边 取值顺序跟内边距相同。 外边距实现盒子居中可以让一个盒子实现水平居中，需要满足一下两个条件： 必须是块级元素。 盒子必须指定了宽度（width） 然后就给左右的外边距都设置为auto，就可使块级元素水平居中。 实际工作中常用这种方式进行网页布局，示例代码如下： 1.header&#123; width:960px; margin:0 auto;&#125; 文字盒子居中图片和背景区别 文字水平居中是 text-align: center 盒子水平居中 左右margin 改为 auto 12text-align: center; /* 文字居中水平 */margin: 10px auto; /* 盒子水平居中 左右margin 改为 auto 就阔以了 */ 插入图片 我们用的最多 比如产品展示类 背景图片我们一般用于小图标背景 或者 超大背景图片 12345678910111213141516section img &#123; truetruewidth: 200px;/* 插入图片更改大小 width 和 height */truetrueheight: 210px;truetruemargin-top: 30px; /* 插入图片更改位置 可以用margin 或padding 盒模型 */truetruemargin-left: 50px; /* 插入当图片也是一个盒子 */true&#125;aside &#123;truetruewidth: 400px;truetrueheight: 400px;truetrueborder: 1px solid purple;truetruebackground: #fff url(images/sun.jpg) no-repeat;truetruetruebackground-size: 200px 210px; /* 背景图片更改大小只能用 background-size */truetruebackground-position: 30px 50px; /* 背景图片更该位置 我用 background-position */true&#125; 清除元素的默认内外边距为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距： 1234* &#123; padding:0; /* 清除内边距 */ margin:0; /* 清除外边距 */&#125; 注意： 行内元素是只有左右外边距的，是没有上下外边距的。 内边距，在ie6等低版本浏览器也会有问题。 我们尽量不要给行内元素指定上下的内外边距就好了。 外边距合并使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。 相邻块元素垂直外边距的合并当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。 解决方案： 避免就好了。 嵌套块元素垂直外边距的合并对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。 解决方案： 可以为父元素定义1像素的上边框或上内边距。 可以为父元素添加overflow:hidden。 待续。。。。 content宽度和高度使用宽度属性width和高度属性height可以对盒子的大小进行控制。 width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，实际工作中最常用的是像素值。 大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是： 123456/*外盒尺寸计算（元素空间尺寸）*/Element空间高度 = content height + padding + border + marginElement 空间宽度 = content width + padding + border + margin/*内盒尺寸计算（元素实际大小）*/Element Height = content height + padding + border （Height为内容高度）Element Width = content width + padding + border （Width为内容宽度） 注意： 1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。 2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。 3、如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding 不会影响本盒子大小。 盒子模型布局稳定性开始学习盒子模型，同学们最大的困惑就是， 分不清内外边距的使用，什么情况下使用内边距，什么情况下使用外边距？ 答案是： 其实他们大部分情况下是可以混用的。 就是说，你用内边距也可以，用外边距也可以。 你觉得哪个方便，就用哪个。 但是，总有一个最好用的吧，我们根据稳定性来分，建议如下： 按照 优先使用 宽度 （width） 其次 使用内边距（padding） 再次 外边距（margin）。 1width &gt; padding &gt; margin 原因： margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。 padding 会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。 width 没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。 ​ CSS3盒模型CSS3中可以通过box-sizing 来指定盒模型，即可指定为content-box、border-box，这样我们计算盒子大小的方式就发生了改变。 可以分成两种情况： 1、box-sizing: content-box 盒子大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode 2、box-sizing: border-box 盒子大小为 width 就是说 padding 和 border 是包含到width里面的 注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。 12345678910111213141516171819div:first-child &#123;truetruetruewidth: 200px;truetruetrueheight: 200px;truetruetruebackground-color: pink; truetruetruebox-sizing: content-box; /* 就是以前的标准盒模型 w3c */truetruetruepadding: 10px;truetruetrueborder: 15px solid red;truetruetrue/* 盒子大小为 width + padding + border content-box:此值为其默认值，其让元素维持W3C的标准Box Mode */truetrue&#125;truetruediv:last-child &#123;truetruetruewidth: 200px;truetruetrueheight: 200px;truetruetruebackground-color: purple;truetruetruepadding: 10px;truetruetruebox-sizing: border-box; /* padding border 不撑开盒子 */truetruetrueborder: 15px solid red;truetruetrue/* margin: 10px; */truetruetrue/* 盒子大小为 width 就是说 padding 和 border 是包含到width里面的 */&#125; 盒子阴影语法格式： 1box-shadow:水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影； 前两个属性是必须写的。其余的可以省略。 外阴影 (outset) 但是不能写 默认 想要内阴影 inset 123456789div &#123;truetruetruewidth: 200px;truetruetrueheight: 200px;truetruetrueborder: 10px solid red;truetruetrue/* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4); */truetruetrue/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色 内/外阴影； */truetruetruebox-shadow: 0 15px 30px rgba(0, 0, 0, .4);truetruetrue&#125; 浮动(float)普通流(normal flow)这个单词很多人翻译为 文档流 ， 字面翻译 普通流 或者标准流都可以。 前面我们说过，网页布局的核心，就是用CSS来摆放盒子位置。如何把盒子摆放到合适的位置？ CSS的定位机制有3种：普通流（标准流）、浮动和定位。 html语言当中另外一个相当重要的概念———-标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。 浮动(float)浮动最早是用来控制图片，以便达到其他元素（特别是文字）实现“环绕”图片的效果。 后来，我们发现浮动有个很有意思的事情：就是让任何盒子可以一行排列,因此我们就慢慢的偏离主题，用浮动的特性来布局了。（CSS3已经我们真正意义上的网页布局，具体CSS3我们会详细解释） 什么是浮动？元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。 在CSS中，通过float属性来定义浮动，其基本语法格式如下： 1选择器&#123;float:属性值;&#125; 属性值 描述 left 元素向左浮动 right 元素向右浮动 none 元素不浮动（默认值） 浮动详细内幕特性浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。 1浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。 1浮动的元素排列位置，跟上一个元素（块级）有关系。如果上一个元素有浮动，则A元素顶部会和上一个元素的顶部对齐；如果上一个元素是标准流，则A元素的顶部会和上一个元素的底部对齐。 1由2可以推断出，一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示。 1元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。 总结： 浮动 —&gt; 浮动的目的就是为了让多个块级元素同一行上显示。 float 浮 漏 特 浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。特： 特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。 版心和布局流程阅读报纸时容易发现，虽然报纸中的内容很多，但是经过合理地排版，版面依然清晰、易读。同样，在制作网页时，要想使页面结构清晰、有条理，也需要对网页进行“排版”。 “版心”(可视区) 是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。 布局流程为了提高网页制作的效率，布局时通常需要遵守一定的布局流程，具体如下： 1、确定页面的版心（可视区）。 2、分析页面中的行模块，以及每个行模块中的列模块。 3、制作HTML结构 。 4、CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。 一列固定宽度且居中 最普通的，最为常用的结构 两列左窄右宽型 比如小米 小米官网 通栏平均分布型 比如锤子 锤子官网 清除浮动人生就像乘坐北京地铁一号线： 途经国贸，羡慕繁华； 途经天安门，幻想权力； 途经金融街，梦想发财； 经过公主坟，遥想华丽家族； 经过玉泉路，依然雄心勃勃… 这时，有个声音飘然入耳:乘客你好,八宝山马上就要到了！ 顿时醒悟：人生苦短，有始有终。 好比我们的浮动，有浮动开始，则就应该有浮动结束。 为什么要清除浮动我们前面说过，浮动本质是用来做一些文字混排效果的，但是被我们拿来做布局用，则会有很多的问题出现， 但是，你不能说浮动不好 。 由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。 准确地说，并不是清除浮动，而是清除浮动后造成的影响 如果浮动一开始就是一个美丽的错误，那么请用正确的方法挽救它。 清除浮动本质清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题。 清除浮动的方法其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 在CSS中，clear属性用于清除浮动，其基本语法格式如下： 1选择器&#123;clear:属性值;&#125; 属性值 描述 left 不允许左侧有浮动元素（清除左侧浮动的影响） right 不允许右侧有浮动元素（清除右侧浮动的影响） both 同时清除左右两侧浮动的影响 额外标签法1是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 &lt;div style=”clear:both”&gt;&lt;/div&gt;，或则其他标签br等亦可。 优点： 通俗易懂，书写方便 缺点： 添加许多无意义的标签，结构化较差。 我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。 父级添加overflow属性方法可以通过触发BFC的方式，可以实现清除浮动效果。（BFC后面讲解） 1可以给父级添加： overflow为 hidden|auto|scroll 都可以实现。 优点： 代码简洁 缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。 使用after伪元素清除浮动:after 方式为空元素的升级版，好处是不用单独加标签了 使用方法： 123.clearfix:after &#123; content: "."; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearfix &#123;*zoom: 1;&#125; /* IE6、7 专有 */ 优点： 符合闭合浮动思想 结构语义化正确 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 百度、淘宝网、网易等 注意： content:”.” 里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。 使用before和after双伪元素清除浮动使用方法： 12345678910.clearfix:before,.clearfix:after &#123; content:""; display:table; /* 这句话可以出发BFC BFC可以清除浮动,BFC我们后面讲 */&#125;.clearfix:after &#123; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 优点： 代码更简洁 缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。 代表网站： 小米、腾讯等 Photoshop图像处理专家 PS 工具是我们使用频率比较高的软件之一， 我们学习PS目的不是为了设计海报做电商和UI的，而是要求： 会简单的抠图 会简单的修改PSD效果图 熟练的切图 能和网站美工美眉有共同话题。。。。。 Photoshop基本使用PS界面组成：菜单栏、选项栏、工具栏、浮动面板（拖拽名称，可单独操作面板）、绘图窗口​ 窗口菜单，可显示隐藏所有面板 工作区：（新建） 调整浮动面板 基本操作文件下拉菜单：​ 1、新建 新建文档 CTRL+N 单位：像素 厘米 毫米 屏幕显示： 单位 像素 72像素/英寸 RGB颜色模式 2、关闭文档 CTRL+W 3、存储 CTRL+S （替存） 4、存储为 CTRL+SHIFT+S 另存一份文件 5、格式：​ .psd PS源文件格式 图层、文字、样式等，可再次编辑​ （给自己）​ .jpg 有损压缩格式 （给客户） 品质 最高12 6、文件打开：​ 1）文件下拉菜单-打开（CTRL+O欧） ​ 2）双击软件空白处也能打开​ 移动工具 V1、不同文件之间拖拽图像。 自由变形ctrl + T 可以改变图像的大小 按下enter 回车确认操作。 图层操作(重点) 图层面板快捷键 F7 其实图层就是一张张透明的纸 可以实现叠加问题。 图层选择： 使用移动工具V 1、图层缩览图判断 2、按住CTRL,在目标图像上单击 3、将光标放置在目标图像上右键，选择图层名称 图层面板中加选图层： 1、按SHIFT，单击另一目标图层 中间所有图层被选中 2、按CTRL，单击另一目标图层 只选中目标图层 复制图层：选中目标图层后（移动工具状态下） 1、按ALT拖拽图像 2、CTRL+J （重合） 案例： 摆放一个自行车 图层编组选中目标图层，CTRL+G 取消编组：CTRL+SHIFT+G 双击图层名称可重新命名 双击组名称，可命名组 移动工具V选择组或图层时，需设置选项栏 图层上下位置移动1、选中目标图层，在图层面拖拽 2、CTRL+] 向上移动图层​ CTRL+[ 向下移动图层 3、CTRL+SHIFT+] 图层置顶​ CTRL+SHIFT+[ 图层置底 移动选区或图像时： 移动过程中，没释放鼠标，按住SHIFT，可同一水平线、同一垂线、45度移动。 ps中的撤销操作是： ctrl+z 撤销一步 ctrl+alt+z 撤销多步 图层合并ctrl+e 可以合并图层 图层透明度不透明度：设置图层的不透明程度 0%完全透明，不可见 ​ 100%完全不透明，真实可见 填充：与不透明度效果类似 ) 键盘数字键，可快速设置透明度数值 矩形选区工具 M用来选择某部分区域 我们成为选区工具 取消选区： ctrl+d 颜色填充 套索工具 L1、套索工具 L 在屏幕上拖拽鼠标左键，释放后生成选区 2、多边形套索 L 连续单击绘制多边形选区 ​ 闭合方法：1、单击起始点 2、双击任意位置 ​ DELETE删除当前点 磁性套索 LL 在颜色交界的位置单击后拖动。单击起始点后，生成选区。 魔棒工具 W以单击位置为选择色，选择相似颜色生成选区。 容差：选择颜色的范围 容差小，颜色选择精确。 0-255 连续：勾选连续时，相连颜色生成选区。 ​ 不勾选，画面中所有相似颜色被选中生成选区。 按SHIFT在未生成选区位置单击，可选区相加。 选区反选：CTRL+SHIFT+I 选区布尔运算 选区面积大小的变化。 新选区：保持选中状态 添加到选区：相加运算（按住SHIFT再绘制选区） 从选区减去：相减（按住ALT再绘制选区） 与选区交叉：重合部分保留。（按住ALT+SHIFT再绘制选区） 梦幻星球 钢笔工具： P作用：绘制路径，生成选区，抠图。 组成;路径线和锚点 绘制路径后，CTRL+回车，生成选区。 路径类型： 直线型路径：连续单击 曲线型路径：第一点单击，第二点拖动鼠标。 文字工具T 可以直接输入文字 Photoshop 切图PS切图 可以 分为 手动 利用切片切图 以及 利用PS的插件快速切图 切片工具 利用切片工具手动划出 图层菜单—新建基于图层的切片 利用标尺 基于参考线的切片 （选择切片工具） ​ 先选个一个整个的切片， 切片选择工具– 属性面板中有 “划分” –可以等分数平分切图 导出切片： 文件– 存储为web设备所用格式 辅助线和切片使用及清除视图菜单– 清除 辅助线/ 清除切片 切图插件Cutterman是一款运行在photoshop中的插件，能够自动将你需要的图层进行输出， 以替代传统的手工 “导出web所用格式” 以及使用切片工具进行挨个切图的繁琐流程。 它支持各种各样的图片尺寸、格式、形态输出，方便你在pc、ios、Android等端上使用。 它不需要你记住一堆的语法、规则，纯点击操作，方便、快捷，易于上手。 官网: http://www.cutterman.cn/zh/cutterman 注意： cutterman插件要求你的ps 必须是完整版，不能是绿色版，所以大家需要从新安装完整版本。 项目案例： 学成网案例练习目的是总结以前的css和html 还有ps的使用。 制作步骤： 准备相关文件。（内部样式表) html文件(index.html) 图片文件 准备CSS 初始化。 书写结构和样式 确定版心（是1200像素)和各个模块。 定位(position)如果，说浮动， 关键在一个 “浮” 字上面， 那么 我们的定位，关键在于一个 “位” 上。 PS: 定位是我们CSS算是数一数二难点的了，但是，你务必要学好它，我们CSS离不开定位，特别是后面的js特效，天天和定位打交道。不要抵触它，反而要爱上它，它可以让我们工作更加轻松哦！ 为什么要用定位？那么定位，最长运用的场景再那里呢？ 来看几幅图片，你一定会有感悟！ 第一幅图， 小黄色块可以再图片上移动： 第二幅图， 左右箭头压住图片： 第三幅图, hot 再盒子外面多出一块，更加突出： 以上三个小地方，如果用标准流或者浮动，实现会比较复杂或者难以实现，此时我们用定位来做，just soso！ 元素的定位属性元素的定位属性主要包括定位模式和边偏移两部分。 1、边偏移 边偏移属性 描述 top 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom 底部偏移量，定义元素相对于其父元素下边线的距离 left 左侧偏移量，定义元素相对于其父元素左边线的距离 right 右侧偏移量，定义元素相对于其父元素右边线的距离 也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px; left: 30px; 等等 2、定位模式(定位的分类) 在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下： 选择器{position:属性值;} position属性的常用值 值 描述 static 自动定位（默认定位方式） relative 相对定位，相对于其原文档流的位置进行定位 absolute 绝对定位，相对于其上一个已经定位的父元素进行定位 fixed 固定定位，相对于浏览器窗口进行定位 静态定位(static)静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。 上面的话翻译成白话： 就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。 在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。 PS： 静态定位其实没啥可说的。 相对定位relative(自恋型)12小笑话： 刚刚看到一个超级超级帅的帅哥，看得我都忍不住想和他搞基了。世间怎会有如此之完美的男人。我和他就这样一动不动的对视着，就仿佛一见钟情。时间也在这一瞬间停止了。直到我的手麻了。才恋恋不舍的放下镜子。。。。 相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。 对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示： 注意： 相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。 其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置） 就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标） 如果说浮动的主要目的是 让多个块级元素一行显示，那么定位的主要价值就是 移动位置， 让盒子到我们想要的位置上去。 绝对定位absolute (拼爹型)1234567小笑话：吃早饭时，老婆往儿子碗里放了两个煎蛋，儿子全给了我，还一本正经地说：“爸爸，多吃点，男人养家不容易。” &lt;br/&gt;我一阵感动，刚想夸他两句。 儿子接着说：“以后全靠你让我拼爹了！” [注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。 当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。 注意： 绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。 父级没有定位若所有父元素都没有定位，以浏览器为准对齐(document文档)。 父级有定位绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。 子绝父相这个“子绝父相”太重要了，是我们学习定位的口诀，时时刻刻记住的。 这句话的意思是 子级是绝对定位的话， 父级要用相对定位。 首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。 就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。 但是，在我们网页布局的时候， 最常说的 子绝父相是怎么来的呢？ 请看如下图： 所以，我们可以得出如下结论： 因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。 父盒子布局时，需要占有位置，因此父亲只能是 相对定位. 这就是子绝父相的由来。 绝对定位的盒子水平/垂直居中普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了 定位的盒子也可以水平或者垂直居中，有一个算法。 首先left 50% 父盒子的一半大小 然后走自己外边距负的一半值就可以了 margin-left。 ​ 固定定位fixed(认死理型)固定定位是绝对定位的一种特殊形式，类似于 正方形是一个特殊的 矩形。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。 当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。 固定定位有两点： 固定定位的元素跟父亲没有任何关系，只认浏览器。 固定定位完全脱标，不占有位置，不随着滚动条滚动。 记忆法： 就类似于孙猴子， 无父无母，好不容易找到一个可靠的师傅（浏览器），就听的师傅的，别的都不听。 ie6等低版本浏览器不支持固定定位。 叠放次序（z-index）当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。 在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。 比如： z-index: 2; 注意： z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。 如果取值相同，则根据书写顺序，后来居上。 后面数字一定不能加单位。 只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。 四种定位总结 定位模式 是否脱标占有位置 是否可以使用边偏移 移动位置基准 静态static 不脱标，正常模式 不可以 正常模式 相对定位relative 不脱标，占有位置 可以 相对自身位置移动（自恋型） 绝对定位absolute 完全脱标，不占有位置 可以 相对于定位父级移动位置（拼爹型） 固定定位fixed 完全脱标，不占有位置 可以 相对于浏览器移动位置（认死理型） 定位模式转换跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式， 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。 元素的显示与隐藏在CSS中有三个显示和隐藏的单词比较常见，我们要区分开，他们分别是 display visibility 和 overflow。 他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。 最常见的是网站广告，当我们点击类似关闭不见了，但是我们重新刷新页面，它们又会出现和你玩躲猫猫！！ display 显示display 设置或检索对象是否及如何显示。 display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。 特点： 隐藏之后，不再保留位置。 visibility 可见性设置或检索是否显示对象。 visible : 对象可视 hidden : 对象隐藏 特点： 隐藏之后，继续保留原有位置。（停职留薪） overflow 溢出检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。 visible : 不剪切内容也不添加滚动条。 auto : 超出自动显示滚动条，不超出不显示滚动条 hidden : 不显示超过对象尺寸的内容，超出的部分隐藏掉 scroll : 不管超出内容否，总是显示滚动条 CSS高级技巧CSS用户界面样式 所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。 防止表单域拖拽 鼠标样式cursor 设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。 1cursor : default 小白 | pointer 小手 | move 移动 | text 文本 鼠标放我身上查看效果哦： 123456&lt;ul&gt; &lt;li style="cursor:default"&gt;我是小白&lt;/li&gt; &lt;li style="cursor:pointer"&gt;我是小手&lt;/li&gt; &lt;li style="cursor:move"&gt;我是移动&lt;/li&gt; &lt;li style="cursor:text"&gt;我是文本&lt;/li&gt;&lt;/ul&gt; 尽量不要用hand 因为 火狐不支持 pointer ie6以上都支持的尽量用 轮廓 outline 是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。 1outline : outline-color ||outline-style || outline-width 但是我们都不关心可以设置多少，我们平时都是去掉的。 最直接的写法是 ： outline: 0; 1&lt;input type="text" style="outline: 0;"/&gt; 防止拖拽文本域resizeresize：none 这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。 右下角可以拖拽： 右下角不可以拖拽： 1&lt;textarea style="resize: none;"&gt;&lt;/textarea&gt; vertical-align 垂直对齐以前我们讲过让带有宽度的块级元素居中对齐，是margin: 0 auto; 以前我们还讲过让文字居中对齐，是 text-align: center; 但是我们从来没有讲过有垂直居中的属性， 我们的妈妈一直很担心我们的垂直居中怎么做。 vertical-align 垂直对齐， 这个看上去很美好的一个属性， 实际有着不可捉摸的脾气，否则我们也不会这么晚来讲解。 1vertical-align : baseline |top |middle |bottom 设置或检索对象内容的垂直对其方式。 vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， 通常用来控制图片和表单等。 图片和文字对齐所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。 去除图片底侧空白缝隙有个很重要特性你要记住： 如果一个元素没有基线，比如图片或者表单等行内块元素，则他的底线会和父级盒子的基线对齐。 这样会造成一个问题，就是图片底侧会有一个空白缝隙。 解决的方法就是： 给img vertical-align:middle | top等等。 让图片不要和基线对齐。 给img 添加 display：block; 转换为块级元素就不会存在问题了。 溢出的文字隐藏word-break:自动换行normal 使用浏览器默认的换行规则。 break-all 允许在单词内换行。 keep-all 只能在半角空格或连字符处换行。 text-overflow 文字溢出text-overflow : clip | ellipsis 设置或检索是否使用一个省略标记（…）标示对象内文本的溢出 clip : 不显示省略标记（…），而是简单的裁切 ellipsis : 当对象内文本溢出时显示省略标记（…） CSS精灵技术（sprite）精灵技术产生的背景 图所示为网页的请求原理图，当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。 然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。 精灵技术本质简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图，如下图所示为京东网站中的一个精灵图。 精灵技术的使用CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。 制作精灵图CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。 大部分情况下，精灵图都是网页美工做。 1234我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。我们精灵图的宽度取决于最宽的那个背景。 我们可以横向摆放也可以纵向摆放，但是每个图片之间，间隔至少隔开偶数像素合适。在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。 结束语： 小公司，背景图片很少的情况，没有必要使用精灵技术，维护成本太高。 如果是背景图片比较多，可以建议使用精灵技术。 字体图标图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的”http请求”，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额不是出现了，是以前就有，是被从新”宠幸”啦。。 这就是字体图标（iconfont). 字体图标优点12345可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...本身体积更小，但携带的信息并没有削减。几乎支持所有的浏览器移动端设备必备良药... 字体图标使用流程总体来说，字体图标按照如下流程： 设计字体图标假如图标是我们公司单独设计，那就需要第一步了，这个属于UI设计人员的工作， 他们在 illustrator 或 Sketch 这类矢量图形软件里创建 icon图标， 比如下图： 之后保存为svg格式，然后给我们前端人员就好了。 其实第一步，我们不需要关心，只需要给我们这些图标就可以了，如果图标是大众的，网上本来就有的，可以直接跳过第一步，进入第三步。 上传生成字体包 当UI设计人员给我们svg文件的时候，我们需要转换成我们页面能使用的字体文件， 而且需要生成的是兼容性的适合各个浏览器的。 ​ 推荐网站： http://icomoon.io icomoon字库 IcoMoon成立于2011年，推出的第一个自定义图标字体生成器，它允许用户选择他们所需要的图标，使它们成一字型。 内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。 推荐网站： http://www.iconfont.cn/ 阿里icon font字库 http://www.iconfont.cn/ 这个是阿里妈妈M2UX的一个icon font字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用AI制作图标上传生成。 一个字，免费，免费！！ fontello http://fontello.com/ 在线定制你自己的icon font字体图标字库，也可以直接从GitHub下载整个图标集，该项目也是开源的。 Font-Awesome http://fortawesome.github.io/Font-Awesome/ 这是我最喜欢的字库之一了，更新比较快。目前已经有369个图标了。 Glyphicon Halflings http://glyphicons.com/ 这个字体图标可以在Bootstrap下免费使用。自带了200多个图标。 Icons8 https://icons8.com/ 提供PNG免费下载，像素大能到500PX 下载兼容字体包刚才上传完毕， 网站会给我们把UI做的svg图片转换为我们的字体格式， 然后下载下来就好了 当然，我们不需要自己专门的图标，是想网上找几个图标使用，以上2步可以直接省略了， 直接到刚才的网站上找喜欢的下载使用吧。 字体引入到HTML最后一步，是最重要的一步了， 就是字体文件已经有了，我们需要引入到我们页面中。 首先把 以下4个文件放入到 fonts文件夹里面。 通俗的做法 第一步：引入项目下面生成的fontclass代码：1&lt;link rel="stylesheet" type="text/CSS" href="./iconfont.CSS"&gt; 第二步：挑选相应图标并获取类名，应用于页面：1&lt;i class="iconfont icon-xxx"&gt;&lt;/i&gt; 滑动门先来体会下现实中的滑动门,或者你可以叫做推拉门： 滑动门出现的背景制作网页时，为了美观，常常需要为网页元素设置特殊形状的背景，比如微信导航栏，有凸起和凹下去的感觉，最大的问题是里面的字数不一样多，咋办？ 为了使各种特殊形状的背景能够自适应元素中文本内容的多少，出现了CSS滑动门技术。它从新的角度构建页面，使各种特殊形状的背景能够自由拉伸滑动，以适应元素内部的文本内容，可用性更强。 最常见于各种导航栏的滑动门。 核心技术核心技术就是利用CSS精灵（主要是背景位置）和盒子padding撑开宽度, 以便能适应不同字数的导航栏。 一般的经典布局都是这样的： 12345&lt;li&gt; &lt;a href="#"&gt; &lt;span&gt;导航栏内容&lt;/span&gt; &lt;/a&gt;&lt;/li&gt; 总结： a 设置 背景左侧，padding撑开合适宽度。 span 设置背景右侧， padding撑开合适宽度 剩下由文字继续撑开宽度。 之所以a包含span就是因为 整个导航都是可以点击的。 伸缩布局(CSS3)CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。 主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向 侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的 方向：默认主轴从左向右，侧轴默认从上到下 主轴和侧轴并不是固定不变的，通过flex-direction可以互换。 Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多 2、各属性详解** a、flex-direction调整主轴方向（默认为水平方向） b、justify-content调整主轴对齐 c、align-items调整侧轴对齐 d、flex-wrap控制是否换行 e、align-content堆栈（由flex-wrap产生的独立行）对齐 f、flex-flow是flex-direction、flex-wrap的简写形式 g、flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配 h、order控制子项目的排列顺序，正序方式排序，从小到大 此知识点重在理解，要明确找出主轴、侧轴、方向，各属性对应的属性值 before和after伪元素过渡(CSS3)过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。 帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片 在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。 语法格式: 1transition: 要过渡的属性 花费时间 运动曲线 何时开始; 属性 描述 CSS transition 简写属性，用于在一个属性中设置四个过渡属性。 3 transition-property 规定应用过渡的 CSS 属性的名称。 3 transition-duration 定义过渡效果花费的时间。默认是 0。 3 transition-timing-function 规定过渡效果的时间曲线。默认是 “ease”。 3 transition-delay 规定过渡效果何时开始。默认是 0。 3 运动曲线示意图： 1234567img &#123; width:80px; height: 80px; border:8px solid #ccc; border-radius: 50%; transition:transform 0.5s ease-in 0s;&#125;img:hover &#123; transform:rotate(180deg);&#125; 2D变形(CSS3)转换是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、变形、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。 变形转换 transform 移动 translate(x, y) 1translate(50px,50px); 使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。 可以改变元素的位置，x、y可为负值； 123translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）translateX(x)仅水平方向移动（X轴移动）translateY(Y)仅垂直方向移动（Y轴移动） 123456789.box &#123; width: 499.9999px; height: 400px; background: pink; position: absolute; left:50%; top:50%; transform:translate(-50%,-50%); /* 走的自己的一半 */&#125; 让定位的盒子水平居中 缩放 scale(x, y) 1transform:scale(0.8,1); 可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。 123scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）scaleX(x)元素仅水平方向缩放（X轴缩放）scaleY(y)元素仅垂直方向缩放（Y轴缩放） scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大 旋转 rotate(deg) 可以对元素进行旋转，正值为顺时针，负值为逆时针； 1transform:rotate(45deg); 当元素旋转以后，坐标轴也跟着发生的转变 调整顺序可以解决，把旋转放到最后 注意单位是 deg 度数 案例旋转扑克牌 12345678910111213141516171819202122232425262728293031323334353637body &#123; background-color: skyblue;&#125;.container &#123; width: 100px; height: 150px; border: 1px solid gray; margin: 300px auto; position: relative;&#125;.container &gt; img &#123; display: block; width: 100%; height: 100%; position: absolute; transform-origin: top right; /* 添加过渡 */ transition: all 1s;&#125;.container:hover img:nth-child(1) &#123; transform: rotate(60deg);&#125;.container:hover img:nth-child(2) &#123; transform: rotate(120deg);&#125;.container:hover img:nth-child(3) &#123; transform: rotate(180deg);&#125;.container:hover img:nth-child(4) &#123; transform: rotate(240deg);&#125;.container:hover img:nth-child(5) &#123; transform: rotate(300deg);&#125;.container:hover img:nth-child(6) &#123; transform: rotate(360deg);&#125; 倾斜 skew(deg, deg) 1transform:skew(30deg,0deg); 该实例通过skew方法把元素水平方向上倾斜30度，处置方向保持不变。 可以使元素按一定的角度进行倾斜，可为负值，第二个参数不写默认为0。 5.transform-origin可以调整元素转换的原点 1div&#123;transform-origin: left top;transform: rotate(45deg); &#125; /* 改变元素原点到左上角，然后进行顺时旋转45度 */ 案例： 菱形照片 三角盒子 3D变形左手坐标系 伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图 CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图 rotateX() 就是沿着 x 立体旋转. 1234567img &#123; transition:all 0.5s ease 0s;&#125;img:hove &#123; transform:rotateX(180deg);&#125; rotateY()沿着y轴进行旋转 1234567img &#123; transition:all 0.5s ease 0s;&#125;img:hove &#123; transform:rotateX(180deg);&#125; rotateZ()沿着z轴进行旋转 123456789img &#123; transition:all .25s ease-in 0s;&#125;img:hover &#123; /* transform:rotateX(180deg); */ /* transform:rotateY(180deg); */ /* transform:rotateZ(180deg); */ /* transform:rotateX(45deg) rotateY(180deg) rotateZ(90deg) skew(0,10deg); */&#125; 透视(perspective)电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。 透视可以将一个2D平面，在转换的过程当中，呈现3D效果。 注：并非任何情况下需要透视效果，根据开发需要进行设置。 perspective有两种写法 作为一个属性，设置给父元素，作用于所有3D转换的子元素 作为transform属性的一个值，做用于元素自身 理解透视距离原理： 开门案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061body &#123;&#125;.door &#123; width: 300px; height: 300px; margin: 100px auto; border: 1px solid gray; perspective: 1000px; background: url('images/dog.gif') no-repeat center/cover; position: relative;&#125;.door &gt; div &#123; box-sizing: border-box; border: 1px solid black;&#125;.left &#123; float: left; width: 50%; height: 100%; background-color: brown; transform-origin: left center; transition: 1s; position: relative;&#125;.left::before &#123; content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; right: 0px; transform: translateY(-10px); border: 1px solid whitesmoke;&#125;.right &#123; width: 50%; height: 100%; float: left; background-color: brown; transform-origin: right center; transition: 1s; position: relative;&#125;.right::before &#123; content: ''; position: absolute; width: 20px; height: 20px; border-radius: 50%; top: 50%; left: 0px; transform: translateY(-10px); border: 1px solid whitesmoke;&#125;.door:hover .left &#123; transform: rotateY(-130deg);&#125;.door:hover .right &#123; transform: rotateY(130deg);&#125; translateX(x)仅水平方向移动**（X轴移动） 主要目的实现移动效果 translateY(y)仅垂直方向移动（Y轴移动） translateZ(z)transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。 3D呈现（transform-style）设置内嵌的元素在 3D 空间如何呈现，这些子元素必须为转换原素。 flat：所有子元素在 2D 平面呈现 preserve-3d：保留3D空间 3D元素构建是指某个图形是由多个元素构成的，可以给这些元素的父元素设置transform-style: preserve-3d来使其变成一个真正的3D图形。 一般而言，该声明应用在3D变换的兄弟元素们的父元素上。 翻转盒子案例(百度钱包)1234567891011121314151617181920212223242526272829303132333435363738394041body &#123; margin: 0; padding: 0; background-color: #B3C04C;&#125;.wallet &#123; width: 300px; height: 300px; margin: 50px auto; position: relative; transform-style: preserve-3d; transition: all 0.5s;&#125;.wallet::before, .wallet::after &#123; content: ''; position: absolute; left: 0; top: 0; display: block; width: 100%; height: 100%; background-image: url(./images/bg.png); background-repeat: no-repeat;&#125;.wallet::before &#123; background-position: right top; transform: rotateY(180deg);&#125;.wallet::after &#123; background-position: left top; transform: translateZ(2px);&#125;.wallet:hover &#123; transform: rotateY(180deg);&#125; 动画(CSS3)动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。 语法格式： 1animation:动画名称 动画时间 运动曲线 何时开始 播放次数 是否反方向; 关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意r 1234@keyframes 动画名称 &#123; from&#123; 开始位置 &#125; 0% to&#123; 结束 &#125; 100%&#125; 12animation-iteration-count:infinite; 无限循环播放animation-play-state:paused; 暂停动画&quot; 小汽车案例123456789101112131415161718192021222324252627body &#123; background: white;&#125;img &#123; width: 200px;&#125;.animation &#123; animation-name: goback; animation-duration: 5s; animation-timing-function: ease; animation-iteration-count: infinite;&#125;@keyframes goback &#123; 0%&#123;&#125; 49%&#123; transform: translateX(1000px); &#125; 55%&#123; transform: translateX(1000px) rotateY(180deg); &#125; 95%&#123; transform: translateX(0) rotateY(180deg); &#125; 100%&#123; transform: translateX(0) rotateY(0deg); &#125;&#125;]]></content>
      <categories>
        <category>Css</category>
      </categories>
      <tags>
        <tag>Css笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML]]></title>
    <url>%2F2017%2F07%2F05%2F01-HTML%2F</url>
    <content type="text"><![CDATA[学习目标: 了解常用浏览器 掌握WEB标准 理解标签语义化 掌握常用的排版标签 掌握常用的文本格式化图像链接等标签 掌握三种列表标签 掌握表格标签 掌握表格标签 掌握表单标签 掌握H5新增表单和表单属性typora-copy-images-to: media 认识网页1网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。 1思考： 网页是如何形成的呢? 常见浏览器介绍1浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。 查看浏览器占有的市场份额（知晓）查看网站： http://tongji.baidu.com/data/browser 浏览器内核（理解）12345浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。 （1）Trident(IE内核) 国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。 Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 （2）Gecko(firefox) Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。 （3） webkit(Safari) Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。 现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。 代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器， （4） Chromium/Bink(chrome) 在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。 ​ 大部分国产浏览器最新版都采用Blink内核。 （5） Presto(Opera) Presto 是挪威产浏览器 opera 的 “前任” 内核，为何说是 “前任”，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。 1了解一点： 移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 等，其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android4.4 系统浏览器切换到了Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。 Web标准（重点）通过以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。 1问： 哪个语言再全国基本都可以听得懂？ Web 标准的好处1、让Web的发展前景更广阔2、内容能被更广泛的设备访问3、更容易被搜寻引擎搜索4、降低网站流量费用5、使网站更易于维护6、提高页面浏览速度 Web 标准构成 Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。 123结构标准：结构用于对网页元素进行整理和分类，主要包括XML和XHTML两个部分。样式标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，主要包括DOM和ECMAScript两个部分 理想状态我们的源码： .HTML .css .js 1专业的人，写专业的代码 直观感受： 总结WEB标准： 结构标准： 决定你是否有个好天然身体 样式标准： 决定你是否打扮的美丽外观 行为标准： 决定你是否有吸引人的行为 HTML 初识一般先学习HTML+CSS， 这里我们先定一个小目标，先学HTML,后学习CSS。 HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”，主要是通过HTML标签对网页中的文本、图片、声音等内容进行描述。 1&lt;strong&gt; 我是加粗的字体 &lt;/strong&gt; 注意： 体会 文本 标签 语言 几个词语 HTML骨架格式日常生活的书信，我们要遵循共同的约定。 同理：HTML 有自己的语言语法骨架格式： 1234567&lt;HTML&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/HTML&gt; 课堂练习1： 书写我们的第一个HTML 页面！ 新建一个demo 的 TXT 文件。 里面写入刚才的HTML 骨架。 把后缀名改为 .HTML。 右击–谷歌浏览器打开。 1234567891011121314151617181920211 HTML标签：作用所有HTML中标签的一个根节点。2 head标签：作用：用于存放：title,meta,base,style,script,link注意在head标签中我们必须要设置的标签是title3.title标签：作用：让页面拥有一个属于自己的标题。4.body标签：作用：页面在的主体部分，用于存放所有的HTML标签：p,h,a,b,u,i,s,em,del,ins,strong,img 为了便于记忆，我们请出刚才要辞职回家养猪的二师兄来帮忙， 我称之为 猪八戒记忆法 HTML标签分类 在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素 1.双标签 1&lt;标签名&gt; 内容 &lt;/标签名&gt; 该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。 12&gt; 比如 &lt;body&gt;我是文字 &lt;/body&gt;&gt; 2.单标签 1&lt;标签名 /&gt; 单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。 12&gt; 比如 &lt;br /&gt;&gt; HTML标签关系标签的相互关系就分为两种： 1.嵌套关系 1&lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; 2.并列关系 12&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 测试题： 1请问下列哪个标签是错误的？ 1A &lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt; 1B &lt;strong&gt;&lt;div&gt;&lt;/div&gt;&lt;/strong&gt; 1C &lt;head&gt;&lt;title&gt;&lt;/head&gt;&lt;/title&gt; 1D &lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt; 倡议： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位。如果是并列关系，最好上下对齐。 开发工具 这些工具你认识几个？ 普通青年 Dreamweaver 文艺青年 sublime 高手和傻子 用记事本 其实。。。。 sublime 一些常用快捷键 点我查看 1234再页面中输入 以下2个单词1. html: 5 2. ! 在sublime里面然后按下tab键盘即可生成HTML骨架 文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; 这句话就是告诉我们使用哪个html版本？ 我们使用的是 html 5 的版本。 html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。 &lt;!DOCTYPE&gt; 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。 注意： 一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。 字符集 utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则包含全世界所有国家需要用到的字符 1记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。 HTML标签的语义化白话： 所谓标签语义化，就是指标签的含义。 为什么要有语义化标签 方便代码的阅读和维护 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容 使用语义化标签会具有更好地搜索引擎优化 核心：合适的地方给一个最为合理的标签。 语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。 不管是谁都能看懂这块内容是什么。 遵循的原则：先确定语义的HTML ，再选合适的CSS。 HTML标签 首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。 HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。 排版标签排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。 标题标签 (熟记) 单词缩写： head 头部. 标题 为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即 、、、、和 1标题标签语义： 作为标题使用，并且依据重要性递减 其基本语法格式如下： 1&lt;hn&gt; 标题文本 &lt;/hn&gt; 注意： h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。 一般h1 都是给logo使用。 段落标签( 熟记)单词缩写： paragraph 段落 在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是 1&lt;p&gt; 文本内容 &lt;/p&gt; 是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。 水平线标签(认识)单词缩写： horizontal 横线 在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，就是创建横跨网页水平线的标签。其基本语法格式如下： 1&lt;hr /&gt;是单标签 在网页中显示默认样式的水平线。 课堂练习2： 新闻页面 换行标签(熟记)单词缩写： break 打断 ,换行 在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签 1&lt;br /&gt; 这时如果还像在word中直接敲回车键换行就不起作用了。 div span标签(重点)div span 是没有语义的 是我们网页布局主要的2个盒子 div 就是 division 的缩写 分割， 分区的意思 其实有很多div 来组合网页。 span, 跨度，跨距；范围 语法格式： 1&lt;div&gt; 这是头部 &lt;/div&gt; &lt;span&gt;今日价格&lt;/span&gt; 文本格式化标签(熟记)在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。 b i s u 只有使用 没有 强调的意思 strong em del ins 语义更强烈 标签属性 属性就是特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。 使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下： 1&lt;标签名 属性1="属性值1" 属性2="属性值2" …&gt; 内容 &lt;/标签名&gt; 在上面的语法中， 1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。 2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。 3.任何标签的属性都有默认值，省略该属性则取默认值。 采取 键值对 的格式 key=”value” 的格式 比如: 1&lt;hr width="400" /&gt; 属性 是 宽度 值 是 400 提倡： 尽量不使用 样式属性。 图像标签img (重点)单词缩写： image 图像 HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签以及和他相关的属性。其基本语法格式如下： 该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。 1&lt;img src="图像URL" /&gt; 链接标签(重点)单词缩写： anchor 的缩写 。基本解释 锚, 铁锚 的 在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下： 1&lt;a href="跳转目标" target="目标窗口的弹出方式"&gt;文本或图像&lt;/a&gt; href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用 target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。 注意： 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 锚点定位 （难点）通过创建锚点链接，用户能够快速定位到目标内容。创建锚点链接分为两步： 1231.使用“a href=”#id名&gt;“链接文本"&lt;/a&gt;创建链接文本。2.使用相应的id名标注跳转目标的位置。 base 标签base 可以设置整体链接的打开状态 base 写到 之间 特殊字符标签 （理解） 注释标签在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：​ 1&lt;!-- 注释语句 --&gt; 注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。 注释重要性： 路径(重点、难点) 实际工作中，通常新建一个文件夹专门用于存放图像文件，这时再插入图像，就需要采用“路径”的方式来指定图像文件的位置。 路径可以分为： 相对路径和绝对路径 相对路径 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。 绝对路径绝对路径 “D:\web\img\logo.gif”，或完整的网络地址，例如“http://www.itcast.cn/images/logo.gif”。 列表标签什么是列表？ 把…制成表,以表显示 容器里面装载着文字或图表的一种形式，叫列表。 列表最大的特点就是 整齐 、整洁、 有序 无序列表 ul （重点）无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下： 123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。 脚下留心： 1231. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表 ol （了解） 有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下： 123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 所有特性基本与ul 一致。 但是实际工作中， 较少用 ol ，因此我们用一句话来总结下 ol： 自定义列表（理解）定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下： 12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 用的还可以： 总结 每一天都有一个主题 我们HTML第一天的主题就是 &lt;认识标签&gt; 学HTML 之前 觉得 很神秘 等你学完之后忽然发现 总结今天的思路贯穿线： 表格 table(会使用)存在即是合理的。 表格的现在还是较为常用的一种标签，但不是用来布局，常见处理表格式数据。 ps: 这些地方用表格，你会觉得生活还是那么美好。。。。忍不住想说 PPAP i hava a pen 创建表格在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下： 1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 在上面的语法中包含三对HTML标签，分别为 &lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释。 123451.table用于定义一个表格。2.tr 用于定义表格中的一行，必须嵌套在 table /table标签中，在 table /table中包含几对 tr /tr，就有几行表格。3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。 注意： 11. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt; 12. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素 表格属性 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构（了解）12345678910在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示：&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。 合并单元格跨行合并：rowspan 跨列合并：colspan 合并单元格的思想： ​ 将多个内容合并的时候，就会有多余的东西，把它删除。 例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。 ​ 公式： 删除的个数 = 合并的个数 - 1 总结表格 表格提供了HTML 中定义表格式数据的方法。 表格中由行中的单元格组成。 表格中没有列元素，列的个数取决于行的单元格个数。 表格不要纠结于外观，那是CSS 的作用。 表单标签(掌握)现实中的表单，类似我们去银行办理信用卡填写的单子。 如下图 目的是为了收集用户信息。 在我们网页中， 我们也需要跟用户进行交互，收集用户资料，此时也需要表单。 在HTML中，一个完整的表单通常由表单控件（也称为表单元素）、提示信息和表单域3个部分构成。 表单控件： ​ 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： ​ 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： ​ 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 input 控件(重点)在上面的语法中，&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input /&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。 label标签(理解)label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ for 属性规定 label 与哪个表单元素绑定。 12&lt;label for="male"&gt;Male&lt;/label&gt;&lt;input type="radio" name="sex" id="male" value="male"&gt; textarea控件(文本域)如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 123&lt;textarea cols="每行中的字符数" rows="显示的行数"&gt; 文本内容&lt;/textarea&gt; 下拉菜单使用select控件定义下拉菜单的基本语法格式如下 123456&lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option 中定义selected =” selected “时，当前项即为默认选中项。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 123&lt;form action="url地址" method="提交方式" name="表单名称"&gt; 各种表单控件&lt;/form&gt; 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method用于设置表单数据的提交方式，其取值为get或post。 name用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。 HTML5新标签与特性文档类型设定 document HTML: XHTML: HTML5 字符设定 ：HTML与XHTML中建议这样去写 ：HTML5的标签中建议这样去写 常用新标签 header：定义文档的页眉 nav：定义导航链接的部分 footer：定义文档或节的页脚 article：标签规定独立的自包含内容 section：定义文档中的节（section、区段） aside：定义其所处内容之外的内容 常用新属性 属性** 用法** 含义** placeholder** 占位符提供可描述输入字段预期值的提示信息 autofocus** 规定当页面加载时 input 元素应该自动获得焦点 multiple** 多文件上传 autocomplete** 规定表单是否应该启用自动完成功能 required** 必填项 accesskey** 规定激活（使元素获得焦点）元素的快捷键 新增的type属性值： 类型** 使用示例** 含义** email** 输入邮箱格式 tel** 输入手机号码格式 url** 输入url格式 number** 输入数字格式 search** 搜索框（体现语义化） range** 自由拖动滑块 time** date** datetime** month** week** 综合案例123456789101112131415161718192021222324252627&lt;form action=""&gt; &lt;fieldset&gt; &lt;legend&gt;学生档案&lt;/legend&gt; &lt;label for="userName"&gt;姓名:&lt;/label&gt; &lt;input type="text" name="userName" id="userName" placeholder="请输入用户名"&gt; &lt;br&gt; &lt;label for="userPhone"&gt;手机号码:&lt;/label&gt; &lt;input type="tel" name="userPhone" id="userPhone" pattern="^1\d&#123;10&#125;$"&gt;&lt;br&gt; &lt;label for="email"&gt;邮箱地址:&lt;/label&gt; &lt;input type="email" required name="email" id="email"&gt;&lt;br&gt; &lt;label for="collage"&gt;所属学院:&lt;/label&gt; &lt;input type="text" name="collage" id="collage" list="cList" placeholder="请选择"&gt;&lt;br&gt; &lt;datalist id="cList"&gt; &lt;option value="前端与移动开发学院"&gt;&lt;/option&gt; &lt;option value="java学院"&gt;&lt;/option&gt; &lt;option value="c++学院"&gt;&lt;/option&gt; &lt;/datalist&gt;&lt;br&gt; &lt;label for="score"&gt;入学成绩:&lt;/label&gt; &lt;input type="number" max="100" min="0" value="0" id="score"&gt;&lt;br&gt; &lt;label for="level"&gt;基础水平:&lt;/label&gt; &lt;meter id="level" max="100" min="0" low="59" high="90"&gt;&lt;/meter&gt;&lt;br&gt; &lt;label for="inTime"&gt;入学日期:&lt;/label&gt; &lt;input type="date" id="inTime" name="inTime"&gt;&lt;br&gt; &lt;label for="leaveTime"&gt;毕业日期:&lt;/label&gt; &lt;input type="date" id="leaveTime" name="leaveTime"&gt;&lt;br&gt; &lt;input type="submit"&gt; &lt;/fieldset&gt;&lt;/form&gt; 多媒体标签 embed：标签定义嵌入的内容 audio：播放音频 video：播放视频 多媒体 embed（会使用）embed可以用来插入各种多媒体，格式可以是 Midi、Wav、AIFF、AU、MP3等等。url为音频或视频文件及其路径，可以是相对路径或绝对路径。 因为兼容性问题，我们这里只讲解 插入网络视频， 后面H5会讲解 audio 和video 视频多媒体。 1&lt;embed src="http://player.youku.com/player.php/sid/XMTI4MzM2MDIwOA==/v.swf" allowFullScreen="true" quality="high" width="480" height="400" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"&gt;&lt;/embed&gt; ​ 优酷，土豆，爱奇艺，腾讯、乐视等等 先上传 在分享 多媒体 audioHTML5通过标签来解决音频播放的问题。 使用相当简单，如下图所示 并且可以通过附加属性可以更友好控制音频的播放，如： autoplay 自动播放 controls 是否显不默认播放控件 loop 循环播放 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图 多媒体 video#HTML5通过video标签来解决音频播放的问题。 #同音频播放一样，video使用也相当简单，如下图 同样，通过附加属性可以更友好的控制视频的播放 autoplay 自动播放 controls 是否显示默认播放控件 loop 循环播放 width 设置播放窗口宽度 height 设置播放窗口的高度 由于版权等原因，不同的浏览器可支持播放的格式是不一样的，如下图供参考 多浏览器支持的方案，如下图** 总结 HTML 第二天的主题： 熟悉列表— 会使用表格 — 掌握常用表单]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>Html笔记</tag>
      </tags>
  </entry>
</search>
